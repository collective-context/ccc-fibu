/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Programme-Name: BA_SAA.C        Revision: 1.3         (C) 1989/1991    บ
  บ  Function      : euroSOFT Basisprogramm                                 บ
  บ                                                                         บ
  บ  Rev.-Date     : 01.05.1991, Graz           Update: 16.07.1991, Graz    บ
  บ  Author        : Peter Mayer                Author: Peter Mayer         บ
  บ  Copyright (C) : euroSOFT-WAREengineering,  Peter Mayer, A-8010 Graz    บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                         Deklarations-Dateien                            บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
#define NDEBUG 1
#include <string.h>
#include <app_tool.h>
#include "..\c\ba_ovl.h"
#include "..\c\ba_proto.h"

STATIC VOID Browse_Handling(VOID);
STATIC VOID i_Read_Up(VOID);
STATIC VOID i_Read_Down(VOID);

IMPORT CHAR   strModemTyp_g[];

IMPORT SWORD  aswAktLine_g[];            /* aus m_input.c GLOBAL */
IMPORT WORD   awMaxLine_g[];             /* aus m_input.c GLOBAL */

STATIC CHAR strNewRecord_m[TB_MAX];
STATIC CHAR strOldRecord_m[TB_MAX];
STATIC CHAR strBtrvPos_m[5];
STATIC SWORD wBrowseFld_m;

/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ     Application_Mask()                                                  บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD Application_Mask()
{
LONG lBrowse=BROWSE;
REGISTER i;
WORD wR;
wBrowseFld_m=-1;

wFinis_g=NEIN;
Read_Default();
while(!wFinis_g)                                     /* Haupt-Eingabe-Schl.  */
  {
  LONG lBrowse=BROWSE;
  if(lBlockVer_g&lBrowse)
    {SWORD wM;
    for(wM=0; apWkbMask_g[wM]; wM++)
      {WORD wF=awBlocks_g[wM][0];
      for(; wF<=awBlocks_g[wM][1]; wF++)
        apTextBox_g[wM][wF]->wFensterZ=awScroll_g[wM][0]+1;
      }
    M_Reset_Masks();                                 /* Beim neuen aktivier. */
    }                                                /* Hintergrundtext dr.  */

  if(!awExistingRecord_g[0] && !awNewRecord_g[0] &&
    wEscFlag_g!=9999)				     /* Bei Druckprogrammen  */
    for(i=0; i<wFileHandler_g; i++)
      if(awFileMode_g[i] != PARA_F)		     /* Keine Parameter Datei*/
        memset(apstrRecord_g[i], '\0',
        awRecLength_g[i]);                           /* Records lschen      */

  wFieldNumber_g=awFirstFieldNumber_g[0];            /* auf 1. Eingabefeld   */
  wMaskNumber_g=0;                                   /* und 1. Maske setzen  */
  Set_Default();

  wEscFlag_g=NO;                                     /* ESC-Taste rcksetzen */
  wKeyCode_g=AUS;                                    /* Verweilen bis die    */
  while(wKeyCode_g!=9999 && !wEscFlag_g)             /* ESC-Taste gedrckt   */
    {
    WORD wNextFieldNumber=wFieldNumber_g;            /*                      */
    WORD wNextMaskNumber=wMaskNumber_g;              /*                      */
    WORD wRec=0, wOff=awRecKeyOffset_g[0];
    WORD wLen=awRecKeyLength_g[0];
    memset(strOldString_g, '\0', TB_MAX);
    memset(strNewString_g, '\0', TB_MAX);

    M_KeyCode(apWkbMask_g, wKeyCode_g,               /* Fr Application_Set  */
      &wNextMaskNumber, &wNextFieldNumber,
      &wNextBlockNumber_g, apTextBox_g,
      apstrRecord_g, awRecLength_g, awBlocks_g );    /* Key-Code auswerten   */

    Application_Set(wNextMaskNumber,
      wNextFieldNumber);                             /* Vorbelegungen        */

    memcpy(strOldRecord_m,
       &apstrRecord_g[wRec][wOff], wLen);            /* Offset aus Fieldinput*/

    /*{BOOL boTest=boTestModus_g;boTestModus_g=EIN;
    Wi_TestPrintf(pWkbInfo_g, "\nawRecLen[%d][%d].", awRecLength_g[0], awInitRecLen_g[0]);
    boTestModus_g=boTest;}*/

    M_Input(apWkbMask_g, &wMaskNumber_g,             /* Masken-Interpreter   */
      apstrRecord_g, apstrMaskText_g,                /*                      */
      apstrBrowseText_g,apTextBox_g,&wFieldNumber_g, /*                      */
      strOldString_g, strNewString_g, &wKeyCode_g,   /*                      */
      awBlocks_g, awScroll_g, awRecLength_g,         /*                      */
      &wBlockNumber_g, strApp_g, pstrIndexKey_g);    /*                      */

    /* {BOOL boTest=boTestModus_g;boTestModus_g=EIN;
    Wi_TestPrintf(pWkbInfo_g, "\nOld(%s)/New(%s)",
      strOldString_g, strNewString_g);
    boTestModus_g=boTest;} */

    memcpy(strNewRecord_m,
       &apstrRecord_g[wRec][wOff], wLen);            /* Offset aus Fieldinput*/

    wR=apTextBox_g[_MSK][_FLD]->wRecord;
    wChangeFlag_g=(awChangeFlag_g[wR]||
    if(wFieldNumber_g!=awFirstFieldNumber_g[0])      /* nicht 1. Eingabefeld */
      awChangeFlag_g[wR]=(awChangeFlag_g[wR] ||
	strcmp(strNewString_g, strOldString_g) ||
	memcmp(strNewRecord_m, strOldRecord_m, wLen));

    awChangeFlag_g[0]=(wChangeFlag_g||awChangeFlag_g[0]);

    wFail_g=NO;                                      /* unglt.Eingabe zurck*/
    if(pEvent_g->wArt==EVENT_WAHL)
      Menu_Handler(&wKeyCode_g, strApp_g,
                   pstrIndexKey_g);

    if(lBlockVer_g&lBrowse && (wKeyCode_g==T_C_PGUP  /* Beim neuen aktivier. */
      || wKeyCode_g==T_C_PGDN) )                     /* Hintergrundtext dr.  */
      M_BrowseMasks();

    KeyCode_Handler();
    if(strchr(strSpecialKeyCodes_g,wKeyCode_g ) > 0) /* Wenn Funktionstaste  */
      Special_Functions();                           /* gedrckt dann aus-   */
    else                                             /* werten sonst:        */
      {                                              /* Feldnummer auf Key-  */
      BOOL boSh=pEvent_g->wKbflags & (LEFT_SHIFT|RIGHT_SHIFT) || boShift_g;
      if(boSh) Browse_Handling();

      Field_Classification();                        /* Feld prfen          */
      if(wRecKey_g>0 && boRecMask_g)                 /* Wenn Stammschlssel  */
        Record_Key_Handler();                        /* dann abhandeln       */
      else                                           /* sonst: wenn Referenz-*/
        if(wRefKey_g>0)                              /* schlssel dann such  */
          Reference_Key_Handler();                   /* Referenzdatei        */
        else                                         /* sonst: andere Felder */
          Other_Fields_Handler();                    /* abhandeln            */

      if(!boSh) Browse_Handling();
      } /*end ! strSpecialKeyCodes */                /*                      */

    All_Fields_Handler();
    boShift_g=NEIN;

    if(wFail_g)                                    /* Wenn ungltige Ein-  */
      {                                            /* gabe                 */
      strcpy(apTextBox_g[_MSK][_FLD]->acText,      /*                      */
        strOldString_g);                           /*                      */

      wKeyCode_g=AUS;                              /*                      */
      i_Beep();                                    /* Wenn erlaubt ฏ Ton   */
      }

    } /*end: while(!wEscFlag_g)*/

  Store();                                           /* speichern, wenn      */
  } /*end while(wFinis_g)*/                          /* !wFinis dann Eingabe */

return(OK);
} /*end Application_Mask() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Special_Functions()                                                     บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Diese Routine wird angesprungen, wenn vom Anwender eine Sonderfunk-     บ
  บ tionstaste bettigt wurde, die fr die Applikation eine bestimmte       บ
  บ Bedeutung hat.                                                          บ
  บ Siehe Konstanten-Deklaration                                            บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID Special_Functions()
{
REGISTER i;
WORD wKeyCode=wKeyCode_g;
if(i_Special_Functions())
  return;

if(wKeyCode_g==T_F3)				    /* wegen T_ESC in Read  */
  {						    /* Next wenn File leer. */
  if(awExistingRecord_g[0])			    /* Falls vorhanden	    */
    {Delete_Record();				    /* Satz lschen und n. */
    wEscFlag_g=NO; wKeyCode_g=T_RETURN; 	    /* Satz lesen.	    */
    wNdx_g=0; Read_Next();}
  }

switch(wKeyCode_g)                                   /*                      */
  {
  case T_F2:                                         /* Match-Code-Suche:    */
    if(Matchcode_Handler())                          /*                      */
      {
      if(*strSelection_g)                            /* Wenn ein Schlssel ge*/
        {                                            /* whlt wurde dann:    */
        if(wRecKey_g > 0)                            /* Wenn Schlssel zum   */
          {                                          /* Stammsatz:           */
          memcpy(&apstrRecord_g[0]                   /* Kopiere die Wahl auf */
            [awRecKeyOffset_g[0]], strSelection_g,   /* das Record           */
            awRecKeyLength_g[0]);                    /* StringToRecord !!!   */

	  /* Db_UnlockAllMulti(0, apstrFileBlock_g, "Match_Code", _F, _L);
          awRecordLocked_g[0]=NEIN; muแ gelscht werden */

          strcpy(strKeyValue_g, strSelection_g);     /* Kopiere die Wahl auf */
          strcpy(strNewString_g, strSelection_g);    /* KeyValue und auf New-*/
          strcpy(strNewRecord_m, strSelection_g);    /* KeyValue und auf New-*/
          Primary_Key_Handler("Match_Code");         /* String und gehe      */
          }                                          /* zum Handler          */
        else if(wRefKey_g > 0)                       /* Zeigt Schlssel in   */
          {                                          /* eine Referenzdatei   */
          Copy_Selection();
          Reference_Key_Handler();                   /* ฏ Referenz-Datei ab- */
          }                                          /* abhandlen            */

        } /* end if(strSelection_g[0]) */
      else
        if(wRecKey_g > 0 && !awChangeFlag_g[0] &&
          (awNewRecord_g[0]                          /* Wenn nichts gewhlt  */
          || awExistingRecord_g[0]))                 /* die Pos-Info fr     */
          Read_Record();                             /* Btrieve aktualisieren*/
      } /* end if(Matchcode_Handler()) */
    break;

  case T_F4:                                         /* Memo ndern, falls   */
    if(awNewRecord_g[0]||awExistingRecord_g[0])      /* Datensatz vorhanden  */
      if(pstrMemoFile_g)
	M_Memo(pstrMemoFile_g, apstrRecKey_g[0],
	  pstrMemoTitel_g);
    break;

  case T_S_F4:                                       /* Memo ndern, falls   */
    if(awNewRecord_g[0]||awExistingRecord_g[0])      /* Datensatz vorhanden  */
      {
      CHAR strMemoKey[TB_MAX];
      stradd(strMemoKey, strApp_g, "\x01\x02",
              apstrRecKey_g[0], NULL);

      if(pstrMemoFile_g)
	M_Memo(pstrMemoFile_g, strMemoKey,
	  pstrAppTitel_g);
      }
    break;

  case T_C_F4:
    {                                                /* Memo ndern, falls   */
    CHAR strMemoFile[TB_MAX];
    CHAR strText[TB_MAX], strKey[TB_MAX];
    sprintf(strMemoFile,"%sEUROMEMO.BTR",strDat_g);
    strcpy(strText, "Nachrichten an Alle");
    strcpy(strKey, "ALLE");

    M_Memo(strMemoFile, strKey, strText);
    }
   break;

  case T_A_F4:                                       /* Memo ndern, falls   */
    {
    CHAR strMemoFile[TB_MAX];
    CHAR strText[TB_MAX];
    sprintf(strMemoFile,"%sEUROMEMO.BTR",strDat_g);
    sprintf(strText, "Privates Notizfach fr den "
       "Arbeitsplatz ฏ%sฎ.", strNrTeil_g);

    M_Memo(strMemoFile, strNrTeil_g, strText);
    }
    break;

  case T_S_F5:                                       /* Zwingend speichern...*/
      for(i=0; i<wFileHandler_g; i++)
        if(awNewRecord_g[i]||awExistingRecord_g[i])
          awChangeFlag_g[i]=YES;
      break;

  case T_F5:                                         /* Kopie des Datensatzes*/
    if(!awExistingRecord_g[0] || CopyDoesNotExist()) /* wenn Record da, dann */
      {                                              /* als verndert, neu   */
      wKeyCode_g=T_RETURN;                           /* und nicht existierend*/
      for(i=0; i<wFileHandler_g; i++)                /* kennzeichenen, damit */
        if(awChangeFlag_g[i] ||                      /* unter dem eingegebe- */
          awExistingRecord_g[i])                     /* nen Key kein neuer   */
          {                                          /* Datensatz gesucht    */
          awChangeFlag_g[i]=YES;                     /* wird. Aber nur wenn  */
          awNewRecord_g[i]=YES;                      /* ein Datensatz geladen*/
          awExistingRecord_g[i]=NO;                  /* ist und die Kopie    */
          }                                          /* noch nicht existiert!*/
      }
    break;

  case T_F9:
    /* Dl_TastenHilfe(); */
    break;

  case T_PGUP:
    i_Read_Up();
    break;

  case T_PGDN:
    i_Read_Down();
    break;

  case T_ESC:
    wFinis_g=( wMaskNumber_g==0 &&                   /* Primrschlssel und  */
    wFieldNumber_g==awFirstFieldNumber_g[0] &&       /* kein Datensatz vor-  */
    !awNewRecord_g[0] && !awExistingRecord_g[0] );   /* handen, dann das     */
                                                     /* Programm verlassen.  */
    wEscFlag_g=YES;                                  /* Esc und Finis ist JA.*/
    break;

  case T_C_D:
    awChangeFlag_g[apTextBox_g[_MSK][_FLD]->wRecord]=YES;
    break;

  } /*end switch*/

i_Special_Functions_2(wKeyCode);
return;
} /*end Special_Functions() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ i_Read_Up()                                                             บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ                                                                         บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_Read_Up(VOID)
{
WORD wEmpty=NEIN;

if(awNewRecord_g[0] || awExistingRecord_g[0])	 /* satz blttern, nur	 */
  {                                              /* wenn Datensatz vorha.*/
  strcpy(strKeyValue_g,                          /* Kopiere Wert aus Pri-*/
    aFiles_g[0].apKeys[0]->acText);              /* mrschlssel-Feld    */

  if(boRecMask_g)                                /* Bei Stammdatenmasken */
    wEmpty=Validate_Primary_Key();               /* Primrkey prfen     */

  if(!wFail_g && !wEmpty)                        /* Wenn nicht leer und  */
    {                                            /* gltig, dann Daten-  */
    WORD wOkAbort=Store();                       /* satz speichern       */
    if(!wOkAbort)                                /* Wenn nicht abgebro-  */
      {                                          /* chen dann ReadIndex  */
      Field_Classification();

      if(wRecKey_g > 0)                          /*!!!!!!!!!!!!!!!!!!!!!!*/
        wNdx_g=wRecKey_g-1;                      /*! Stimmt nur fr max.!*/
      else                                       /*! ..... 2 Keys ..... !*/
        wNdx_g=0;                                /*!!!!!!!!!!!!!!!!!!!!!!*/

      Read_Previous();                               /* Satz lesen           */
      } /* end if(wOkAbort) */                       /* Hintergrundtext dr.  */
    } /* end if(wFail_g && wEmpty) */

  } /* end if (wExistingRecord_g)  */

return;
} /* end i_Read_Up() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ i_Read_Down()                                                           บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ                                                                         บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_Read_Down(VOID)
{
WORD wEmpty=NEIN;

if(awNewRecord_g[0] || awExistingRecord_g[0])	 /* satz blttern, nur	 */
  {                                              /* wenn Datensatz vorha.*/
  strcpy(strKeyValue_g,                          /* Kopiere Wert aus Pri-*/
    aFiles_g[0].apKeys[0]->acText);		 /* mrschlssel-Feld	 */

  if(boRecMask_g)                                /* Bei Stammdatenmasken */
    wEmpty=Validate_Primary_Key();               /* Primrkey prfen     */

  if(!wFail_g && !wEmpty)                        /* Wenn nicht leer und  */
    {                                            /* gltig, dann Daten-  */
    WORD wOkAbort=Store();                       /* satz speichern       */
    if(!wOkAbort)                                /* Wenn nicht abgebro-  */
      {                                          /* chen dann ReadIndex  */
      Field_Classification();                    /* auf Primr- oder     */

      if(wRecKey_g > 0)
        wNdx_g=wRecKey_g-1;
      else
        wNdx_g=0;

      Read_Next();
      } /* end if(wOkAbort)   */
    } /* end if(wFail_g && wEmpty) */

  } /* end if(wExistingRecord_g)  */

return;
} /* end i_Read_Down() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Browse_Handling()                                                       บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ                                                                         บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID Browse_Handling(VOID)
{
LONG lBrowse=BROWSE;
BOOL boSh=pEvent_g->wKbflags&(LEFT_SHIFT|RIGHT_SHIFT) || boShift_g;
WORD wF=awBlocks_g[_MSK][1];
BOOL boT_RETURN;

if(!(lBlockVer_g&lBrowse)) return;

while(!(apTextBox_g[_MSK][wF]->pFeld->bArt & IS_EINGABE)) wF--;
if(wBrowseFld_m>-1 && wBrowseFld_m<wF) wF=wBrowseFld_m;

boT_RETURN=_FLD==wF && (!boSh && wKeyCode_g==T_RETURN);

if(boSh && wKeyCode_g==T_RETURN)
  if(wBrowseFld_m>-1)
    {wBrowseFld_m= -1; wKeyCode_g=NULL;}
  else
    {wBrowseFld_m=_FLD; wKeyCode_g=NULL;}

if(_FLD==awBlocks_g[_MSK][0] && wBrowseFld_m>0
  && !boSh && wKeyCode_g==T_RETURN)
  _FLD=wBrowseFld_m-1;

    /*{BOOL boTest=boTestModus_g;boTestModus_g=EIN;
    Wi_TestPrintf(pWkbInfo_g, "\n_FLD/wF(%d/%d), boSh(%d/%d), "
      "boT_RETURN(%d).", _FLD, wF, boSh, wKeyCode_g, boT_RETURN);
    boTestModus_g=boTest;}*/

if((boSh&&wKeyCode_g==T_DOWN) || boT_RETURN)         /* alle Masken          */
  {WORD wM, wZ;                                      /* alle Block-Felder    */
  for(wM=0; apWkbMask_g[wM]; wM++)
    {WORD wF=awBlocks_g[wM][0];
    if(apTextBox_g[wM][wF]->wFensterZ-1<awScroll_g[wM][2])
      for(; wF<=awBlocks_g[wM][1]; wF++)
        apTextBox_g[wM][wF]->wFensterZ++;
    else
      {for(wZ=awScroll_g[wM][0]-2; apstrBrowseText_g[wM][wZ+1]; wZ++)
        memcpy(apstrBrowseText_g[wM][wZ],
          apstrBrowseText_g[wM][wZ+1], awScroll_g[wM][3]);

      if(wM==_MSK)
        M_ScrollUp(1, wM, apstrMaskText_g, awScroll_g);}
    }

  i_Read_Down();
  if(!boSh) wFieldNumber_g=awBlocks_g[_MSK][0];
  }                                                  /* Hintergrundtext dr.  */

if(boSh&&wKeyCode_g==T_UP)
  {WORD wM, wZ;
  for(wM=0; apWkbMask_g[wM]; wM++)                   /* alle Masken          */
    {WORD wF=awBlocks_g[wM][0];
    if(apTextBox_g[wM][wF]->wFensterZ-1>awScroll_g[wM][0])
      for(; wF<=awBlocks_g[wM][1]; wF++)             /* alle Block-Felder    */
        apTextBox_g[wM][wF]->wFensterZ--;
    else
      {for(wZ=awScroll_g[wM][2]-2; apstrBrowseText_g[wM][wZ]
        && wZ>awScroll_g[wM][0]-2; wZ--)
        memcpy(apstrBrowseText_g[wM][wZ],
          apstrBrowseText_g[wM][wZ-1], awScroll_g[wM][3]);

      if(wM==_MSK)
        M_ScrollDown(1, wM, apstrMaskText_g, awScroll_g);}
    }

  i_Read_Up();
  }                                                  /* Hintergrundtext dr.  */

return;
} /* end Browse_Handling() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Field_Classification()                                                  บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Field_Classification() teilt das vom Anwender gerade verlassene Feld in บ
  บ eine der Kategorien "Schlssel zum Stammsatz", "Schlsselfeld mit Ver-  บ
  บ weis auf eine Referenzdatei" oder "allgemeines Stammdatenfeld" ein.     บ
  บ Soll die Eingabe bei einem Verweis auf eine Reference-Datei sich nicht  บ
  บ auf den Primarkey in der Reference-Datei beziehen, so muแ dies in der   บ
  บ Sub-Funktion i_Field_Classification nachgetragen werden.                บ
  บ Auch bei scrollbaren Zeilen im Maskentyp 1 muแe bei einem Verweis auf   บ
  บ Reference-Dateien der Eintrag in i_Field_Classification() erfolgen.     บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD Field_Classification()
{
LONG lBlock=BLOCK, lBrowse=BROWSE;
REGISTER i, j;

wRecKey_g=0;                                         /* Stammsatz-Schlssel  */
wRefKey_g=0;                                         /* Referenz-Schlssel   */

memset(strKeyValue_g, '\0', TB_MAX);                 /* alte Werte lschen   */

for(i=0; i<wMaxRecKey_g; i++)                        /* fr alle Schlssel   */
  if(awRecKeyField_g[i]==_FLD &&                     /* prfen, ob man in    */
    (awRecKeyMask_g[i]==_MSK ||
    (lBlockVer_g&lBrowse && awBlocks_g[_MSK][1]) ))  /* einem Key-Feld steht */
    {                                                /* Wenn JA, dann berge-*/
    wRecKey_g=i+1;                                   /* ben ob 1, 2, etc     */
    return(ABBRUCH);                                 /* Schlssel            */
    }

for(i=0; i<wFileHandler_g; i++)                      /* Ref-Dateien suchen   */
  for(j=0; awFileMode_g[i]==REF_F && j<aFiles_g[i].wNbKeyFields; j++)
    if(apTextBox_g[_MSK][_FLD]->strDatenfeld ==
      aFiles_g[i].apKeys[j]->strDatenfeld)
      {
      wRefFile_g=i;
      wRefKey_g = j+1;
      }

i_Field_Classification(&wRefKey_g, &wRefFile_g);
return(OK);
} /*end Field_Classification() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ i_Field_Class()							    บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ									    บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID i_Field_Class(PSTR pFIELD, PWORD pwRefKey, PWORD pwRefFile)
{
PTEXTBOX pTB=TBpt(pFIELD, _MSK, 99);

memset(apstrRecord_g[pTB->wRecord],
  '\0', awRecLength_g[pTB->wRecord]);		   /* wenn Wahl ungltig   */

*pwRefKey=1;
*pwRefFile=pTB->wRecord;

strcpy(pt(pFIELD), apTextBox_g[_MSK][_FLD]->acText);

return;
}


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Copy_Selection()                                                        บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Diese Funktion wird nach drcken der [F2]-Taste nach Ausfhrung der     บ
  บ Funktion Matchcode_Handler() in der Funktion Special_Funktions() vor    บ
  บ der Funktion Reference_Key_Handler() aufgerufen.                        บ
  บ Weiters wird die Funktion in der Funktion Field_Classification() und    บ
  บ damit ebenfalls vor Reference_Key_Handler() aufgerufen.                 บ
  บ Aufgabe:                                                                บ
  บ   1) In der Funktion Matchcode_Handler wird nach einem beliebigen       บ
  บ      Schlssel in der angebenen Datei gesucht. Unter strSelection_g     บ
  บ      wird vom gewhlten Datensatz der Primrkey der Datei zurckgegeben.บ
  บ oder: (R-2)                                                             บ
  บ   2) In der Funktion Field_Classification() wird nach einem beliebigen  บ
  บ      Schlssel in der angebenen Datei gesucht. Unter strSelection_g     บ
  บ      wird vom gewhlten Datensatz der Primrkey der Datei zurckgegeben.บ
  บ In beiden Fllen kopiert diese Funktion strSelection_g an die Primarkey-บ
  บ stelle des Records sowie auf die Varaiblen strKey_Value_g und strNew-   บ
  บ string_g.                                                               บ
  บ Danach steht der Primrkey nach der Wahl fr die Funktion Referenc_Key- บ
  บ Handler() an der richtigen Stelle.                                      บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD Copy_Selection()
{
WORD wOfs1=0, wMaxL1=0; 			     /* 		     */
/* WORD wPre=0; Set_Prefix(&wPre); */

if(aFiles_g[wRefFile_g].wNbKeyFields < 1)
  Dl_Abbruch(str("In File %d kein Keyfeld", wRefFile_g),
    _L,_F,apTextBox_g[_MSK][_FLD]->strDatenfeld);
else
  {wOfs1=aFiles_g[wRefFile_g].apKeys[0]->wOffset;      /* +wPre;	     */
  wMaxL1=aFiles_g[wRefFile_g].apKeys[0]->wMaxL;}       /* -wPre 	     */

wRefKey_g=1;
memcpy(&apstrRecord_g[wRefFile_g][wOfs1],            /*                      */
  strSelection_g, wMaxL1);                           /*                      */

strcpy(strKeyValue_g,strSelection_g);                /* Wahl auf Schlssel,  */
strcpy(strNewString_g,strSelection_g);		     /* und NewString kopi.  */
						     /* strNewString_g+wPre  */
return(OK);
} /* end Copy_Selection() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Record_Key_Handler()                                                    บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Diese Routine behandelt die Eingaben, die in einem Schlsselfeld        บ
  บ zum Stammsatz gemacht wurden.                                           บ
  บ Hier wird berprft, ob der Schlssel Gltigkeit besitzt und in         บ
  บ der Stammdaten-Datei vorhanden ist. Danach wird entschieden, ob ein     บ
  บ bestehender Satz mutiert werden soll, oder ob ein neuer Satz ange-      บ
  บ legt werden soll.                                                       บ
  บ Bei Leereingaben ohne aktuellen Datensatz wird in das nchste           บ
  บ Schlsselfeld zum Stammdaten-Satz verzweigt.                            บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
WORD Record_Key_Handler()
{
WORD wEmpty;                                         /*                      */

switch(wRecKey_g)                                    /* Key im Stammsatz     */
  {
  case 1:                                            /* Primrschlssel      */
    strcpy(strKeyValue_g, strNewString_g);           /* Kopiere Eingabe und  */
    wEmpty=Validate_Primary_Key();                   /* prfe Gltigkeit     */

    if(!wFail_g  && !wEmpty)                         /* Bei gltig und !leer */
      Primary_Key_Handler(NULL);                     /* abhandeln sonst      */
    else if(wEmpty)                                  /* bei Leereingabe ins  */
           Next_Key_Field();                         /* nchste Key-Feld     */
  break;

  default:                                           /* Sekundrschlssel    */
    awChangeFlag_g[0]=(strcmp(strNewString_g,        /* Wurde die Stammdatei */
      strOldString_g)||awChangeFlag_g[0] );          /* verndert ?          */

  if(!awNewRecord_g[0] && !awExistingRecord_g[0])    /* Bei Record nicht da  */
    Next_Key_Field();                                /* ins nchste Key-Feld */
  break;                                             /*                      */

  }  /*end switch*/

return(OK);
} /*end Record_Key_Handler (04) */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Primary_KeyHandler()                                                    บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Diese Funktion wird aufgerufen, wenn das Primrkeyfeld verlassen wird.  บ
  บ Der Primary_KeyHandler wird auch in einem Rec-Schlsselfeld nach dem    บ
  บ Drcken der [F2]-Taste angesprungen.                                    บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
WORD Primary_Key_Handler(PSTR pstrCall)
{
LONG lBlock=BLOCK, lBrowse=BROWSE;
WORD wRec=0;
WORD wOff=awRecKeyOffset_g[0];
WORD wLen=awRecKeyLength_g[0];
WORD wOkAbort=NO;

if(strcmp(strOldString_g, strKeyValue_g) ||       /* neuer Schlssel wur- */
  (!awNewRecord_g[0] && !awExistingRecord_g[0]))     /* de eingegeben        */
  {
  if(awNewRecord_g[0] || awExistingRecord_g[0])      /*                      */
    {
    WORD wBufLen=INIT_RECORD_LENGTH;
    memcpy(pstrDataBuffer_g, strBtrvPos_m, 4);
    if(pstrCall && !strcmp(pstrCall, "Match_Code"))
      BTRV(B_GET_DIRECT,apstrFileBlock_g[0],
        pstrDataBuffer_g,&wBufLen,apstrRecKey_g[0],0);

    /*{BOOL boTest=boTestModus_g;boTestModus_g=EIN;
    Wi_TestPrintf(pWkbInfo_g, "\nxxx.");
    boTestModus_g=boTest;}*/

    memcpy(&apstrRecord_g[wRec][wOff],
      strOldRecord_m, wLen);                         /* Offset aus Fieldinput*/

    wOkAbort=Store();                                /* Stammsatz beenden    */

    memcpy(&apstrRecord_g[wRec][wOff],
      strNewRecord_m, wLen);                         /* Offset aus Fieldinput*/

    /*{BOOL boTest=boTestModus_g;boTestModus_g=EIN;
    Wi_TestPrintf(pWkbInfo_g, "\napstrRecord_g[%d][%d]<%d>(%s), ฏ%s|%sฎ[%s|%s].", wRec, wOff, wLen,
      &apstrRecord_g[wRec][wOff], strOldRecord_m, strNewRecord_m, strOldString_g, strNewString_g);
    boTestModus_g=boTest;}*/
    }

  i_Primary_Key_Handler();

  if(!wOkAbort)                              /* neuen Datensatz aktivieren   */
    Read_Record();                           /* Neuen Datensatz lesen        */
  else                                       /* OK-Fenster wurde abgebrochen */
    wFail_g=YES;                             /* Datensatz nicht gltig       */
  }


return(OK);
} /* end Primary_Key_Handler() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Reference_Key_Handler()                                                 บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Reference_Key_Handler() behandelt die Eingaben, die in einem Schlssel- บ
  บ feld auf eine Referenz-Datei gemacht wurden.                            บ
  บ Es werden Referenz-Zugriffe (sofern erwnscht) auf die jeweiligen       บ
  บ Dateien vorgenommen.                                                    บ
  บ Der laut Field_Classification() oder Matchcode_Handler gewhlte Primr- บ
  บ key in der Reference-Datei wird geladen.                                บ
  บ In i_Reference_Key_Handler() knnen etwaige Feldzuordnungen nachgetra-  บ
  บ gen werden.                                                             บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD Reference_Key_Handler()
{

if(wRefKey_g==1)
  if(!Read_Ref(wRefFile_g, 0) &&
    strcmp(strNewString_g, strOldString_g))
    {
    if(aFiles_g[wRefFile_g].apKeys[0]->pRefField)
      awChangeFlag_g[aFiles_g[wRefFile_g].
        apKeys[0]->pRefField->wRecord]=YES;
    else
      awChangeFlag_g[wRefFile_g]=YES;
    }

i_Reference_Key_Handler();
return(OK);
} /*end Reference_Key_Handler() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Next_Key_Field ()                                                       บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Diese Routine setzt den Feld-Cursor auf das nchste Schlsselfeld.      บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID Next_Key_Field ()
{

if(wRecKey_g>0)                                      /* Wenn ein Schlssel-  */
  {                                                  /* feld vorliegt dann:  */
  switch(wKeyCode_g)
    {
    case T_RETURN:                                   /* Bei Return und       */
    case T_DOWN:                                     /* Cursor abwrts den   */
      if(wRecKey_g<wMaxRecKey_g)                     /* Schlssel bis zum    */
        wRecKey_g++;                                 /* Max-Wert erhhen oder*/
      else                                           /* 1 geben              */
        wRecKey_g=1;
      break;

    case T_UP:                                       /* Bei Cursor aufwrts  */
      if(wRecKey_g>1)                                /* den Schlsselwert    */
        --wRecKey_g;                                 /* bis zum Minimalwert  */
      else                                           /* senken oder Maximal- */
        wRecKey_g=wMaxRecKey_g;                      /* wert geben           */
      break;

    }  /*end switch*/
  } /*end if (wRecKey_g > 0)*/

wFieldNumber_g=awRecKeyField_g[wRecKey_g -1];        /*                      */
wMaskNumber_g=awRecKeyMask_g[wRecKey_g -1];          /*                      */
wKeyCode_g=AUS;                                      /*                      */
return;
} /* end Next_Key_Field() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Matchcode_Handler()                                                     บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Matchcode_Handler() behandelt die Matchcode-Anfragen zu Key-Feldern.    บ
  บ Fr scrollbare Zeilen im Maskentyp 1 und fr spezielle Wnsche bei      บ
  บ Zugriffen auf Referenz-Dateien knnen in i_Matchcode_Handler() Eintrge บ
  บ erfolgen.                                                               บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD Matchcode_Handler()
{
PMATCH	pMatchCode=NULL; /* PPMATCH ppMatchCode=&pMatchCode; */
WORD wRetCode, wSpalte, wZeile, wDummy, wFileNb, wMatchNb, wNbFile;
CHAR strNull[TB_MAX];
WORD wBufLen=4, wNull=0;
WORD wStatus=BTRV(B_GET_POS, apstrFileBlock_g[0],    /*                      */
       strBtrvPos_m, &wBufLen, strNull, wNull);      /*                      */

Vi_GetCursor(&wSpalte,&wZeile,&wDummy, &wDummy);

for(wFileNb=0; wFileNb<wFileHandler_g; wFileNb++)
  for(wMatchNb=0; wMatchNb<aFiles_g[wFileNb].wNbMatchFields; wMatchNb++)
    if(aFiles_g[wFileNb].aMatch[wMatchNb].
      pMatchField->strDatenfeld==apTextBox_g[_MSK][_FLD]->strDatenfeld)
      {
      pMatchCode=&aFiles_g[wFileNb].aMatch[wMatchNb];
      wNbFile=wFileNb; /* wNbFile=0; */
      }

/* Matchcode_Handler_1(ppMatchCode, &wNbFile, &wFileNb); */
Matchcode_Handler_1(&pMatchCode, &wNbFile, &wFileNb);
wRecKey_g=wRefFile_g=wRefKey_g=0;
if(pMatchCode)
  {
  WORD wReadIndex=pMatchCode->ppKey -aFiles_g[wNbFile].apKeys;

  if(awFileMode_g[wNbFile]==REF_F)
    {wRefFile_g=wNbFile;
    wRefKey_g=wReadIndex+1;}
  else
    wRecKey_g=wReadIndex+1;

  if( (*pMatchCode->ppKey)->acText==NULL )
    Dl_Abbruch("Kein Matchcode-Feld", _L, _F,
      apTextBox_g[_MSK][_FLD]->strDatenfeld);
  else
    strcpy(strSelection_g, (*pMatchCode->ppKey)->acText);

  wRetCode=M_MatchCode(wZeile+3, wSpalte-12,
    apstrFileBlock_g, wReadIndex, pMatchCode,
    awRecKeyOffset_g, strSelection_g, apfsFileBuffer_g);

  if(*strSelection_g && awFileMode_g[wNbFile]==REC_F && wReadIndex>0)
    wRetCode=Db_GetEq(wNbFile, apstrFileBlock_g,
      apstrRecord_g, awRecLength_g, awInitRecLen_g,
      B_NO, strSelection_g, 0, _F, _L);   /* Fr [F2] in Druckprogramm */

  memcpy(strNewRecord_m, strSelection_g, awRecKeyLength_g[0]);
  Matchcode_Handler_2();

  wRetCode=JA;
  }
else
  wRetCode=NEIN;

return(wRetCode);
} /* end Matchcode_Handler() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ i_Matchcode_Handler()                                                   บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Diese Routine behandelt die Matchcode-Anfragen zu Key-Feldern           บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
PTEXTBOX i_Matchcode_Handler(PSTR pMATCH_FLD, PSTR pstrMatchTxt,
                         PPMATCH ppMatchCode, PWORD pwNbFile, PWORD pwFileNb)
{
PTEXTBOX pTB;
PMATCH  pMatch;
PPMATCH ppMatch=&pMatch;

if(pMATCH_FLD==NULL)
  {
  if((*(*ppMatchCode)->ppKey)->acText==NULL)
    Dl_Abbruch("Kein Matchcode-Feld", _L, _F,
      apTextBox_g[_MSK][_FLD]->strDatenfeld);
  else if(pstrMatchTxt)
    strcpy((*(*ppMatchCode)->ppKey)->acText, pstrMatchTxt);

  return(NULL);
  }
else
  pTB=TBpt(pMATCH_FLD, _MSK, 99);
*ppMatch=&aFiles_g[pTB->wRecord].aMatch[0]; /* Match 0 ?? */

if((*(*ppMatch)->ppKey)->acText==NULL)
  Dl_Abbruch("Kein Matchcode-Feld", _L, _F, pMATCH_FLD);
else
  {
  *ppMatchCode=&aFiles_g[pTB->wRecord].aMatch[0];
  *pwNbFile=*pwFileNb=pTB->wRecord;

  if(pstrMatchTxt)
    strcpy((*(*ppMatchCode)->ppKey)->acText, pstrMatchTxt);  /* Default [F2] */

  /*strcpy(pt(pMATCH_FLD), pstrMatchTxt);*/
  }

return(pTB);
}


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Read_Default()                                                          บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Legt fest, ob beim Aufruf eines Programmes bereits ein Datensatz gele-  บ
  บ sen werden soll.                                                        บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD i_Read_Default(PSTR pMATCH_FLD)
{
WORD wValid=JA, wRec, wOff;
CHAR strKey[TB_MAX];                                 /*                      */

if(aFiles_g[0].wNbKeyFields < 1)
  Dl_Abbruch("In File 0 kein Keyfeld", _L, _F,
    apTextBox_g[_MSK][_FLD]->strDatenfeld);
else
  {wRec=aFiles_g[0].apKeys[0]->wRecord; 	     /* 		     */
  wOff=aFiles_g[0].apKeys[0]->wOffset;} 	     /* 		     */

if(boStrCmp(pMATCH_FLD, "TEILNEHMER"))               /*                      */
  strcpy(strKey, strNrTeil_g);                       /*                      */
else if(boStrCmp(pMATCH_FLD, "MODEM"))               /*                      */
  strcpy(strKey, strModemTyp_g);                     /*                      */
else if(boStrCmp(pMATCH_FLD, "MANDANT"))             /*                      */
  {strcpy(strKey, strMan_g);                         /*                      */
  if(strMan_g[0]=='0') strKey[0]=' ';}               /*                      */

memcpy(&apstrRecord_g[wRec][wOff],                   /*                      */
  strKey, awRecKeyLength_g[0]);                      /*                      */
                                                     /*                      */
memcpy(apstrRecKey_g[0], strKey,                     /*                      */
  awRecKeyLength_g[0]);                              /*                      */
                                                     /*                      */
strcpy(strKeyValue_g, apstrRecKey_g[0]);             /*                      */

wValid=Read_Record();                                /*                      */
return(wValid);                                      /*                      */
}


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ MissingKey()                                                            บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ                                                                         บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID MissingKey()
{

if(awNewRecord_g[0] || awExistingRecord_g[0])        /* falscher Schlssel   */
  {
  PSTR apstrMessage[25];
  wFail_g=YES;                                       /* ungltige Eingabe    */
  wMaskNumber_g=awRecKeyMask_g[0];
  wFieldNumber_g=awRecKeyField_g[0];
  wKeyCode_g=AUS;

  Ut_SchreibArray(apstrMessage,
    "Unzulssiger Schlssel",
    "Bitte einen gltigen Schlssel angeben", NULL); /*                      */

  Dl_Info(apstrMessage, DLG_KRITISCH);
  Ut_LoeschArray(apstrMessage);
  }

return;
} /* end MissingKey() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ CopyDoesNotExist()                                                      บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ                                                                         บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
WORD CopyDoesNotExist(VOID)
{
WORD wFH=0, wKey, wRetCode;	 /*WORD wFH=apTextBox_g[_MSK][_FLD]->wRecord */
WORD wRecLen=awRecLength_g[wFH];
PSTR pstrRec=apstrRecord_g[wFH], pstrDataBuffer=NULL;

Field_Classification();
if(wKey=wRecKey_g-1 != 0) return(0);   /* Jetzt nur Key 1 no duplicates max. */

apstrRecord_g[wFH]=pstrDataBuffer;
memcpy(apstrRecKey_g[wKey],
  strNewRecord_m, awRecKeyLength_g[0]);

wRetCode=Db_GetEq(wFH, apstrFileBlock_g,
  apstrRecord_g, awRecLength_g, awInitRecLen_g,
  B_MNW, apstrRecKey_g[wKey], wKey, _F, _L);

if(wRetCode==4)
  wRetCode=JA;
else if(wRetCode==0)
  {
  if(!(apfsFileBuffer_g[wFH]->ksKeyBuf[wKey].wKeyFlags & DUP))
    {
    PSTR apstrMessage[25];
    Ut_SchreibArray(apstrMessage,
                  "  Der eingegebene Schlssel ",
                  "  existiert in dieser Datei schon!  ",
                  " ",
                  "  Da hier zwei Datenstze nicht den ",
                  "  gleichen Schlssel haben drfen,  ",
                  "  kann die Kopie  ฏn i c h tฎ",
                  "  durchgefhrt werden!",
                  NULL);
    Dl_Info(apstrMessage, DLG_KRITISCH);
    Ut_LoeschArray(apstrMessage);
    wRetCode=NEIN;
    }
  else wRetCode=JA;
  Ut_Free(apstrRecord_g[wFH]);			     /* Wenn gefunden, wieder*/
  }						     /* freigeben !	     */

/* if(wRetCode==JA)			   /* Key doesn't allow duplicates ! */
/*  Unlock("TEST_COPY"); */

apstrRecord_g[wFH]=pstrRec;
awRecLength_g[wFH]=wRecLen;

if(!wRetCode)					     /* Wenn schon vorhanden */
  {WORD wRec=0, wOff=awRecKeyOffset_g[0];	     /* copy Old-Key	     */
  memcpy(&apstrRecord_g[wRec][wOff],
    strOldRecord_m, awRecKeyLength_g[0]);	     /* Offset aus Fieldinput*/
  Extract_Keys(wFH);}				     /* Schlssel eintragen  */

return(wRetCode);
} /* End CopyDoesNotExist() */


/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Menu_Handler()                                                          บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ                                                                         บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD Menu_Handler(PWORD pwKeyCode, PSTR pstrApp, PSTR pstrIndexKey)
{
STATIC BOOL boMnSchatten=JA;
STATIC WORD wMnRahmen=RT_EEEE;

switch(pEvent_g->wOption)
  {
  case 101: *pwKeyCode=T_ESC;  break;
  case 102: *pwKeyCode=T_F2;   break;
  case 103: *pwKeyCode=T_F3;   break;
  case 104: *pwKeyCode=T_F4;   break;
  case 105: *pwKeyCode=T_S_F4; break;
  case 106: *pwKeyCode=T_C_F4; break;
  case 107: *pwKeyCode=T_A_F4; break;
  case 108: *pwKeyCode=T_F5;   break;
  case 201: Dl_MausTempo();    break;
  case 202: Dl_Warnton();      break;

  case 203:
    wMnRahmen=(wMnRahmen == RT_DDDD) ? RT_EEEE : RT_DDDD;
    Mn_SetRahmenTyp(1, wMnRahmen);
    if(wMnRahmen==RT_EEEE)
      Mn_Marker(pEvent_g->wOption, AUS);
    else
      Mn_Marker(pEvent_g->wOption, EIN);
    break;

  case 204:
    boMnSchatten=(boMnSchatten == EIN) ? AUS : EIN;
    Mn_SetSchatten(1, boMnSchatten);
    Mn_Marker(pEvent_g->wOption, !boMnSchatten);
    break;

  case 205:
    Ut_DosShell(NORMAL, NULL);
    break;

  case 206:
    boTestModus_g=(boTestModus_g==EIN) ? AUS : EIN;
    Mn_Marker(pEvent_g->wOption, boTestModus_g);
    break;

  case 207:
    boPrepare_g=(boPrepare_g==EIN) ? AUS : EIN;
    Mn_Marker(pEvent_g->wOption, boPrepare_g);
    break;

  case 31001:
    *pwKeyCode=T_F9;
    break;

  case 31002:
    M_HilfeIndex(pstrApp,pstrIndexKey);
    break;
  }

return (OK);
}



/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ i_FieldClass							    บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ alternativ !!!							    บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID i_FieldClass(PWORD pwRefKey, PWORD pwRefFile, PSTR pFIELD, PSTR pREF)
{
WORD wBlock=wBlockNumber_g*awBlockLength_g[_MSK];

if(TBox(pFIELD))
  {
  PTEXTBOX pTB=TBpt(pREF, 99, 99);
  WORD wR=pTB->wRecord;

  *pwRefFile=pTB->wRecord;
  *pwRefKey=1;
  memset(apstrRecord_g[wR],'\0',awRecLength_g[wR]);

  strcpy(pt(pREF), pt(pFIELD)+wBlock);
  }
return;
} /* end i_FieldClass() */

i_FieldClass(pwRefKey,pwRefFile,"GELDKONTO","KONTONR");
i_FieldClass(pwRefKey,pwRefFile,"KONTO_NR", "KONTONR");

if(*(pt("PO_ART")+wBlk)=='a')
  i_FieldClass(pwRefKey,pwRefFile,"AR_NUMMER","ARTNR");


  if(*strSelection_g && awFileMode_g[wNbFile]==REC_F && wReadIndex>0)
    {
    /*WORD wBufLength=4, wNull=0;                      /*                    */
    /*CHAR strNull[TB_MAX];                            /*                    */
    /*wRetCode=Db_GetEq(0, apstrFileBlock_g,           /*                    */
    /*  apstrRecord_g, awRecLength_g, awInitRecLen_g,  /*                    */
    /*  B_NO, strSelection_g, 0, _F, _L);            /*                    */

    /*wRetCode=BTRV(B_GET_POS, apstrFileBlock_g[wNbFile],     /*             */
    /*  apstrRecord_g[wNbFile], &wBufLength, strNull, wNull); /*             */

    /*wRetCode=BTRV(B_GET_DIRECT, apstrFileBlock_g[wNbFile],  /*             */
    /*  apstrRecord_g[wNbFile], &awRecLength_g[wNbFile],      /*             */
    /*  strSelection_g, 0);                                   /*             */

    /*wRetCode=BTRV(B_GET_EQ, apstrFileBlock_g[wNbFile],      /*             */
    /*  apstrRecord_g[wNbFile], &awRecLength_g[wNbFile],      /*             */
    /*  strSelection_g, 0);                                   /*             */
    /* Db_SetRecLenth();                                      /*             */
    }

/*ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ Menu_Handler1()                                                         บ
  บ ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ บ
  บ Ohne Hilfsindex im Erfassen Rechnungen                                  บ
  ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD Menu_Handler1(PWORD pwKeyCode)
{
STATIC BOOL boMnSchatten=JA;
STATIC WORD wMnRahmen=RT_EEEE;

switch (pEvent_g->wOption)
  {
  case 101: *pwKeyCode=T_ESC;  break;
  case 102: *pwKeyCode=T_F2;   break;
  case 103: *pwKeyCode=T_F3;   break;
  case 104: *pwKeyCode=T_F4;   break;
  case 105: *pwKeyCode=T_S_F4; break;
  case 106: *pwKeyCode=T_C_F4; break;
  case 107: *pwKeyCode=T_A_F4; break;
  case 108: *pwKeyCode=T_F5;   break;
  case 201: Dl_MausTempo();    break;
  case 202: Dl_Warnton();      break;

  case 203:
    wMnRahmen = (wMnRahmen == RT_DDDD) ? RT_EEEE : RT_DDDD;
    Mn_SetRahmenTyp (1, wMnRahmen);
    if(wMnRahmen==RT_EEEE)
      Mn_Marker (pEvent_g->wOption, AUS);
    else
      Mn_Marker (pEvent_g->wOption, EIN);
    break;

  case 204:
    boMnSchatten=(boMnSchatten == EIN) ? AUS : EIN;
    Mn_SetSchatten (1, boMnSchatten);
    Mn_Marker (pEvent_g->wOption, !boMnSchatten);
    break;

  case 205:
    Ut_DosShell (NORMAL, NULL);
    break;

  case 206:
    boTestModus_g=(boTestModus_g==EIN) ? AUS : EIN;
    Mn_Marker(pEvent_g->wOption, boTestModus_g);
    break;

  case 207:
    boPrepare_g=(boPrepare_g==EIN) ? AUS : EIN;
    Mn_Marker(pEvent_g->wOption, boPrepare_g);
    break;
  }

return (OK);
}



/*WORD wRec=aFiles_g[0].apKeys[0]->wRecord;      /*                      */
/*WORD wOff=aFiles_g[0].apKeys[0]->wOffset;      /*                      */

/* for(i=0; i<wFileHandler_g; i++)
    if(awFileMode_g[i]==REC_F) Extract_Keys(i);    /* Schlssel filtern    */


/*  if(awBlocks_g[_MSK][0]|awBlocks_g[_MSK][1])  Wenn Maske Blockmaske */


  if(lBlockVer_g&lBrowse)
    {SWORD wM, wMax;
    for(wMax=0; apWkbMask_g[wMax+1]; wMax++) ;
    if(_MSK!=wMax)
      Wi_Verstecken(apWkbMask_g[_MSK]);    /* Window verstecken    */

    for(wM=wMax; wM>=0; wM--)
      {
      WORD wF=awBlocks_g[wM][0];
      for(; wF<=awBlocks_g[wM][1]; wF++)
        apTextBox_g[wM][wF]->wFensterZ=awScroll_g[wM][0]+1;

      /*if(!Wi_IsAktiv(apWkbMask_g[wM]))               /* Window nicht aktiv   */
      /*  Wi_Aktivieren(apWkbMask_g[wM]);              /* Window aktivieren    */

      /* Wi_Cls();
      for(wF=0; apstrMaskText_g[wM][wF]; wF++)
        Wi_Ss(0, wF, apstrMaskText_g[wM][wF]);
      if(wM!=0) Wi_Verstecken(apWkbMask_g[wM]);      /* Window verstecken    */
      }

    M_Reset_Masks();                                 /* Beim neuen aktivier. */
    }                                                /* Hintergrundtext dr.  */


      {for(wZ=awScroll_g[wM][0]-1; apstrBrowseText_g[wM][wZ+1]
        && wZ<awScroll_g[wM][2]-1; wZ++)
        strcpy(apstrBrowseText_g[wM][wZ], apstrBrowseText_g[wM][wZ+1]);



      {for(wZ=awScroll_g[wM][2]-3; apstrBrowseText_g[wM][wZ]
        && wZ>awScroll_g[wM][0]-1; wZ--)
        strcpy(apstrBrowseText_g[wM][wZ], apstrBrowseText_g[wM][wZ-1]);


/* PSTR pstrBlk=apstrFileBlock_g[wFH]; */
CHAR strFileBlock[128]; */
/*strcpy(strFileBlock, apstrFileBlock_g[wFH]);
  apstrFileBlock_g[wFH]=strFileBlock; */
