/*������������������������������������������������������������������������ͻ
  �  Funktionsname:    i_Dl_LiesZK                    Datum: 20.12.88      �
  ������������������������������������������������������������������������Ķ
  �                                                                        �
  �  Parameter:        pTextBox      Zeiger auf die Struktur TEXTBOX       �
  �                    pEvent        Zeiger auf die Ereignisstruktur       �
  �                    wInit         interne Strukturen aktual.            �
  �                                                                        �
  �  Beschreibung:     Diese Funktion dient zur Unterst�tzung der Text-    �
  �                    boxen in einem Dialogfeld. Sie stellt im wesent-    �
  �                    lichen einen zeilenorientierten Texteditor dar,     �
  �                    wobei die Textbearbeitung wahlweise mit Tastatur    �
  �                    oder Maus erfolgen kann.                            �
  �                                                                        �
  �                    Die Struktur �TEXTBOX� enth�lt s�mtliche Infor-     �
  �                    mationen �ber die Textbox (Gr��e, Lage, Text). Zur  �
  �                    Bearbeitung wird der Text in einen Buffer kopiert.  �
  �                    Um die Ausgabegeschwindigkeit zu erh�hen, werden    �
  �                    die Zeichen zusammen mit ihrem Attribut in dem      �
  �                    Buffer abgelegt. Bevor die Funktion einen Text be-  �
  �                    arbeiten kann, mu� ein Aufruf erfolgen, bei dem dem �
  �                    Parameter �wInit� die Textkonstante AKT_BUFFER      �
  �                    �bergeben werden mu�. Die beiden ersten Parameter   �
  �                    sind in diesem Fall bedeutungslos.                  �
  �                    Um den editierten Text wieder in die Textbox-Struk- �
  �                    tur zur�ckzuschreiben, mu� ein Aufruf erfolgen, bei �
  �                    dem f�r den Parameter �wInit� die Textkonstante     �
  �                    AKT_TEXTBOX �bergeben wird. Auch in diesem Fall     �
  �                    sind die beiden ersten Parameter bedeutungslos.     �
  �                                                                        �
  �                    Bei jeder Cursorbewegung wird die neue Position     �
  �                    in die Struk.pmtur eingetragen.                        �
  �                                                                        �
  �                    Die Funktion speichert den Zeiger auf die zu-       �
  �                    letzt bearbeitete Struktur und kann so erkennen,    �
  �                    ob der aktuelle Aufruf sich auf diese oder eine     �
  �                    neue Struktur bezieht.                              �
  �                    Bevor eine Textbox editiert werden kann mu� die     �
  �                    aufrufende Funktion den Text auf dem Bildschirm     �
  �                    ausgeben.                                           �
  �                                                                        �
  �                    Folgende Sondertasten werden unterst�tzt:           �
  �                                                                        �
  �                    <- , ->   bewegen den Cursor um eine Spalte         �
  �                    HOME      bewegt den Cursor an den Textanfang       �
  �                    END       bewegt den Cursor an das Textende         �
  �                    BACKSPACE l�scht das Zeichen links neben dem Cursor �
  �                    DELETE    l�scht das Zeichen unter dem Cursor       �
  �                    INSERT    schaltet Einf�ge-Modus ein oder aus       �
  �                    SHIFT-DEL und CTRL-Y l�schen die ganze Zeile        �
  �                                                                        �
  �  R�ckgabewert:     Die Funktion hat keinen R�ckgabewert                �
  �                                                                        �
  �  Benutzte globale                                                      �
  �  Variablen (R/W):   - wMausda_g (R)                                    �
  �                     - wVioMode_g (R)                                   �
  �                                                                        �
  ������������������������������������������������������������������������ͼ*/
/*������������������������������������������������������������������������ͻ
  �                        DEKLARATIONS-DATEIEN                            �
  ������������������������������������������������������������������������ͼ*/
#include <eur_tool.h>
#include <stdio.h>
#include <string.h>

/*������������������������������������������������������������������������ͻ
  �                        KONSTANTEN UND MAKROS                           �
  ������������������������������������������������������������������������ͼ*/
#define LINKS   0
#define RECHTS  1
#define HOME    2
#define ENDE    3

/*������������������������������������������������������������������������ͻ
  �             GLOBALE VARIABLEN, DEFINITION UND REFERENZEN               �
  ������������������������������������������������������������������������ͼ*/
IMPORT PWKB pWkbInfo_g;
IMPORT BOOL boTestModus_g;
IMPORT COLORSET aCS_g[];
IMPORT WORD wCSInd_g;
IMPORT WORD wMausda_g;
IMPORT WORD wVioMode_g;
STATIC WORD wInsert_m;

/*������������������������������������������������������������������������ͻ
  �                        MODULGLOBALE VARIABLEN                          �
  ������������������������������������������������������������������������ͼ*/
STATIC	TEXTBOX* pTB_m; 			    /* zeigt auf aktuelle   */
                                                    /* Struktur             */
STATIC	WORD	 awBuffer_m[TB_MAX+1];		    /* enth�lt editierten   */
                                                    /* Text mit Attribut    */
STATIC	PWORD	 pwBufferC_m;			    /* Zeigt auf aktuelle   */
                                                    /* Cursorpos. im Buffer */
STATIC	PWORD	 pwBufferE_m;			    /* zeigt auf das letzte */
                                                    /* Zeichen im Buffer    */
STATIC	WORD	 wNbZeichen_m;			    /* Enth�lt die Anzahl   */
                                                    /* Nichtleerzeichen im  */
                                                    /* Eingabebuffer        */

STATIC	BOOL boFirst_m; 			    /*			    */
STATIC	CHAR acText_m[TB_MAX];

STATIC	VOID i_ZeichenEinfuegen    (WORD);
STATIC	VOID i_BufferAkt	   (VOID);
STATIC	VOID i_StrukturAkt	   (VOID);
STATIC	VOID i_TextboxAkt	   (WORD, PWORD);
STATIC	VOID i_SchiebeTextsegment  (WORD);
STATIC	VOID i_BewegeCursor	   (WORD);
/*������������������������������������������������������������������������ͻ
  �                          FUNKTIONS-DEFINITION                          �
  ������������������������������������������������������������������������ͼ*/
GLOBAL
VOID i_Dl_LiesZK( TEXTBOX* pTextBox, EVENT* pEvent, WORD wInit)
{
REGISTER i;
pTB_m=pTextBox; 				     /* modulglobalen Zeiger */
						     /* initialisieren	     */
if(wInit==AKT_BUFFER)
  {strcpy(acText_m, pTB_m->acText);
  wInsert_m=pTB_m->boInsert;
  boFirst_m=JA;}

if(wInit==AKT_TEXTBOX)				     /* Struktur aktual. ?   */
  {
  i_StrukturAkt();
  return;
  }

if(wInit==AKT_BUFFER || wInit==AKT_INTERN ||
  wInit==AKT_CURSOR)
  {
  REGISTER i;
  WORD wCursorS=pTB_m->wCursorS;
  WORD wFensterS=pTB_m->wFensterS;

  i_BufferAkt();				     /* Buffer neu laden     */
  i_TextboxAkt(wFensterS, awBuffer_m);		     /* Text ausgeben	     */
  i_BewegeCursor(HOME); 			     /* Cursor an Textanfang */

  if(wInit==AKT_CURSOR && wCursorS>wFensterS)	     /* Wenn pTB_m->wCursorS */
    for(i=0; i < (wCursorS-wFensterS); i++)	     /* gr��er als Boxanfang */
      i_BewegeCursor(RECHTS);			     /* Cursor nach rechts   */
  return;
  }

switch(pEvent->wArt)
  {
  case EVENT_TASTE:

  if(pEvent->wTaste==',' && pEvent->wKbflags & SHIFT /* DEL-Taste auf dem    */
    && !(pEvent->wKbflags & NUM_LOCK) ) 	     /* Ziffernblock unter-  */
    pEvent->wTaste=T_DEL;			     /* st�tzen 	     */

  if(pEvent->wTaste==T_C_BACKSPACE)
    {strcpy(pTB_m->acText, acText_m);		     /* alten Text kopieren  */
    i_Dl_LiesZK(pTB_m, NULL, AKT_INTERN);}

  else if((pEvent->wKbflags & ALT) &&		     /* Alt-Taste gedr�ckt   */
    pEvent->wTaste < 256)			     /* f�r ALT+NummernBlock */
    {						     /* f�r ASCII Werte      */
    if(pwBufferC_m < awBuffer_m + pTB_m->wMaxL )     /* steht der Cursor im  */
      i_ZeichenEinfuegen(pEvent->wTaste);	     /* Buffer ?	     */
    else
      Ut_Beep();
    }

        else switch (pEvent->wTaste)
        {
          case T_DEL:
	    boFirst_m=NEIN;
	    if(pEvent->wKbflags & SHIFT)	     /* Shift-Taste gedr�ckt */
	      {
	      pTB_m->acText[0]='\0';		     /* Text l�schen	     */
	      i_Dl_LiesZK(pTB_m, NULL, AKT_INTERN);
	      }
	    else if(pwBufferC_m <= pwBufferE_m &&    /* Cursor im Text ?     */
                     wNbZeichen_m)
	      {
              if (pwBufferE_m == awBuffer_m)
                 wNbZeichen_m = 0;
	      else if (*pwBufferC_m != (' ' | pTB_m->wAttri << 8))
                 --wNbZeichen_m;                    /* erlaubtes Zeichen ?  */
              i_SchiebeTextsegment(LINKS);          /* eine Spalte nach     */
                                                    /* links schieben       */
              i_TextboxAkt(pTB_m->wCursorS,
                           pwBufferC_m);
	      }
            else
              Ut_Beep();
            break;

          case T_BACKSPACE:
	    boFirst_m=NEIN;
            if (pwBufferC_m > awBuffer_m)          /* Cursor im Text ?     */
            {
              i_BewegeCursor(LINKS);
	      if (*pwBufferC_m != (' ' | pTB_m->wAttri << 8))
                 --wNbZeichen_m;                    /* erlaubtes Zeichen ?  */
              i_SchiebeTextsegment(LINKS);
              i_TextboxAkt(pTB_m->wCursorS,
                           pwBufferC_m);
            }
            else
              Ut_Beep();
            break;

          case T_C_A:
          case T_C_F:
          case T_C_X:
	  case T_C_W:
	  case T_C_V:
	    boFirst_m=NEIN;
            if(pEvent->wTaste==T_C_A)                 /* Zum Schreiben der */
               pEvent->wTaste='\x1B';                 /* der Cursor-Tasten */
            else if(pEvent->wTaste==T_C_F)
               pEvent->wTaste='\x1A';
            else if(pEvent->wTaste==T_C_X)
               pEvent->wTaste='\x19';
	    else if(pEvent->wTaste==T_C_W)
               pEvent->wTaste='\x18';
	    else if(pEvent->wTaste==T_C_V)
	       pEvent->wTaste='\x7F';

            if (pwBufferC_m < awBuffer_m +            /* steht der Cursor im  */
                              pTB_m->wMaxL )          /* Buffer ?             */
              i_ZeichenEinfuegen(pEvent->wTaste);
            else
              Ut_Beep();
            break;

	  case T_C_Y:
	    pTB_m->acText[0]='\0';		     /* Text l�schen	     */
	    i_Dl_LiesZK(pTB_m, NULL, AKT_INTERN);
            break;

          case T_RIGHT:
	    boFirst_m=NEIN;
            i_BewegeCursor(RECHTS);                 /* Cursor nach rechts   */
            break;

          case T_C_RIGHT:
	    boFirst_m=NEIN;
            for(i=0; i<8; i++)
              i_BewegeCursor(RECHTS);               /* Tab nach rechts      */
            break;

          case T_LEFT:
	    boFirst_m=NEIN;
            i_BewegeCursor(LINKS);                  /* Cursor nach links    */
            break;

          case T_C_LEFT:
	    boFirst_m=NEIN;
            for(i=0; i<8; i++)
              i_BewegeCursor(LINKS);                /* Tab nach links       */
            break;

          case T_HOME:
	    boFirst_m=NEIN;
            i_BewegeCursor(HOME);                   /* Cursor an Textanfang */
            break;


          case T_END:
	    boFirst_m=NEIN;
            i_BewegeCursor(ENDE);                   /* Cursor an Textende   */
            break;

	  case T_INS:
	    if(pEvent->wKbflags & SHIFT)	     /* Shift-Taste gedr�ckt */
	      {strcpy(pTB_m->acText, acText_m);      /* alten Text kopieren  */
	      i_Dl_LiesZK(pTB_m, NULL, AKT_INTERN);}

	    else if(pTB_m->boInsert)		     /* Einf�ge-Modus ein ?  */
            {
              pTB_m->boInsert = NEIN;

              if (wVioMode_g == MONOCHROM)
                Vi_SetCursorTyp(0,12);              /* Block-Cursor         */
              else
                Vi_SetCursorTyp(0,7);
            }
            else
            {
	      pTB_m->boInsert=wInsert_m;

              if (wVioMode_g == MONOCHROM)
                Vi_SetCursorTyp(11,12);             /* Linien-Cursor        */
              else
                Vi_SetCursorTyp(6,7);
            }
            break;

          case T_RETURN:                            /* Tasten abfangen,     */
          case T_TAB:                               /* die zur Steuerung    */
          case T_SHIFT_TAB:                         /* der Dialogbox be-    */
          case T_ESC:                               /* n�tigt werden        */
            break;

          default:
            if (pEvent->wTaste <= 255 &&            /* erlaubtes Zeichen ?  */
                pEvent->wTaste >= 32  &&
                pwBufferC_m < awBuffer_m +          /* steht der Cursor im  */
                              pTB_m->wMaxL )        /* Buffer ?             */
              i_ZeichenEinfuegen(pEvent->wTaste);
            else
              Ut_Beep();
        }
        break;


      case EVENT_L_PRESS:
        if (pEvent->wZeile  == pTB_m->wFensterZ &&  /* Koordinaten �ber- */
            pEvent->wSpalte >= pTB_m->wFensterS &&  /* pr�fen            */
            pEvent->wSpalte <  pTB_m->wFensterS +
                               pTB_m->wFensterB )
          {
            Vi_SetCursorPos( pEvent->wSpalte,       /* Cursor positionieren */
                             pEvent->wZeile);
            pwBufferC_m += pEvent->wSpalte -        /* Zeiger aktualisieren */
                           pTB_m->wCursorS;
            pTB_m->wCursorS = pEvent->wSpalte;
          }
        break;


      default:
        ;                                           /* andere Events werden */
                                                    /* nicht unterst�tzt    */
    }

    return;                                         /* fertig!              */
}


/*������������������������������������������������������������������������ͻ
  �  Funktionsname:    i_ZeichenEinfuegen             Datum: 24.12.88      �
  ������������������������������������������������������������������������Ķ
  �                                                                        �
  �  Parameter:        WORD     wZeichen    einzuf�gendes Zeichen          �
  �                                                                        �
  �  Beschreibung:     Das Verhalten der Funktion ist von dem aktuellen    �
  �                    Stand der Variablen �pTBakt->boInsert� abh�ngig.    �
  �                    Bei eingeschaltetem Einf�ge-Modus untersucht die    �
  �                    Funktion zun�chst, ob der Buffer ein weiteres       �
  �                    Zeichen aufnehmen kann und f�gt dann das Zeichen    �
  �                    an der Cursorposition in den Buffer ein.            �
  �                    Bei ausgeschaltetem Einf�ge-Modus wird das Zeichen  �
  �                    an der aktuellen Cursorposition �berschrieben.      �
  �                                                                        �
  �  R�ckgabewert:     keinen                                              �
  �                                                                        �
  �  Benutzte globale                                                      �
  �  Variablen (R/W):   - awBuffer_m (W)                                   �
  �                     - pwBufferC_m (W)                                  �
  �                     - pwBufferE_m (W)                                  �
  �                     - pTB_m (R)                                        �
  ������������������������������������������������������������������������ͼ*/
STATIC
VOID i_ZeichenEinfuegen( WORD wZeichen )
{

if(boFirst_m)
  {
  if(pTB_m->boInsert == 1)
    {pTB_m->acText[0]='\0';			     /* Text l�schen	     */
    i_Dl_LiesZK(pTB_m, NULL, AKT_INTERN);}
  boFirst_m=NEIN;
  }

    if (pTB_m->boInsert && pTB_m->wMaxL > 1)        /* Insert-Modus ein oder*/
    {                                               /* nur ein Zeichen breit*/
        if (pwBufferE_m < awBuffer_m +              /* noch Platz ?         */
                          pTB_m->wMaxL -1)
        {
            if (pwBufferC_m > pwBufferE_m)          /* Cursor hinter dem    */
                                                    /* letzten Zeichen ?    */
                pwBufferE_m = pwBufferC_m;          /* Zeiger aktualisieren */
            else if (pwBufferE_m > awBuffer_m ||    /* eine Spalte nach     */
              awBuffer_m[0] != (pTB_m->wAttri << 8 | ' '))
                i_SchiebeTextsegment(RECHTS);       /* rechts schieben      */

            *pwBufferC_m = wZeichen |               /* Zeichen einf�gen     */
                           pTB_m->wAttri << 8;

            i_TextboxAkt(pTB_m->wCursorS,
                         pwBufferC_m);

            if (wZeichen > 32)
              wNbZeichen_m++;

            i_BewegeCursor(RECHTS);
        }
        else                                        /* kein Platz mehr      */
            Ut_Beep();
    }
    else                                            /* Insert-Modus aus ?   */
    {
        if (pwBufferC_m > pwBufferE_m)              /* Cursor hinter dem    */
            pwBufferE_m = pwBufferC_m;              /* letzten Zeichen ?    */
	else if (*pwBufferC_m != (' ' | pTB_m->wAttri << 8))
                --wNbZeichen_m;                     /* erlaubtes Zeichen ?  */

        *pwBufferC_m = wZeichen |                   /* Zeichen einf�gen     */
                      pTB_m->wAttri << 8;

        i_TextboxAkt(pTB_m->wCursorS,
                     pwBufferC_m);

        if (wZeichen > 32)
          wNbZeichen_m++;

        i_BewegeCursor(RECHTS);
    }
}


/*������������������������������������������������������������������������ͻ
  �  Funktionsname:    i_BufferAkt                    Datum: 24.12.88      �
  ������������������������������������������������������������������������Ķ
  �                                                                        �
  �  Parameter:        keine                                               �
  �                                                                        �
  �  Beschreibung:     Die Funktion kopiert den auszugebenden Text in      �
  �                    den Buffer �awBuffer_m�. Dabei wird jedes Zeichen   �
  �                    direkt mit seinem Attribut abgelegt. Wenn n�tig,    �
  �                    wird der Buffer mit Leerzeichen aufgef�llt.         �
  �                                                                        �
  �  R�ckgabewert:     keinen                                              �
  �                                                                        �
  �  Benutzte globale                                                      �
  �  Variablen (R/W):   - awBuffer_m (W)                                   �
  �                     - pwBufferC_m (W)                                  �
  �                     - pwBufferE_m (W)                                  �
  �                     - pTB_m (R)                                        �
  ������������������������������������������������������������������������ͼ*/
STATIC
VOID i_BufferAkt(VOID)
{
    WORD  wAttri   = pTB_m->wAttri << 8;            /* Textattribut         */
    PUSTR pstrText = (PUSTR)pTB_m->acText;	    /* zu editierender Text */
    wAttri=aCS_g[wCSInd_g].wCs_wdlg << 8;


   boTestModus_g=JA;
   Wi_TestPrintf(pWkbInfo_g, "\niBuAkt(%d)=%s.", wAttri, pstrText);
   boTestModus_g=NEIN;

    wNbZeichen_m = 0;
    pwBufferC_m = awBuffer_m;                       /* Zeiger auf Buffer    */

    while ( (*pwBufferC_m++ = *pstrText++ | wAttri) != wAttri )
        if (*(pstrText-1) != ' ')                   /* Text in den Buffer   */
            wNbZeichen_m++;                         /* kopieren             */

    if (pwBufferC_m - 1 > awBuffer_m)
       pwBufferE_m = pwBufferC_m -2;                /* zeigt auf das letzte */
    else pwBufferE_m = awBuffer_m;                  /* Textzeichen          */

    wAttri |= ' ';                                  /* Attribut mit Leer-   */
                                                    /* zeichen verkn�pfen   */

    for ( pwBufferC_m--;                            /* Rest des Buffers mit */
          pwBufferC_m<=awBuffer_m+
          ((pTB_m->wMaxL > pTB_m->wFensterB) ?
          pTB_m->wMaxL : pTB_m->wFensterB);         /* Leerzeichen f�llen   */
          *(pwBufferC_m++) = wAttri)
       ;

    pwBufferC_m = awBuffer_m;                       /* Zeiger auf Buffer-   */
						    /* anfang setzen	    */

   /* Vi_Ss(5, 16, pTB_m->acText); Ut_Warte(); */

}



/*������������������������������������������������������������������������ͻ
  �  Funktionsname:    i_StrukturAkt                  Datum: 24.12.88      �
  ������������������������������������������������������������������������Ķ
  �                                                                        �
  �  Parameter:        keine                                               �
  �                                                                        �
  �  Beschreibung:     Die Funktion �bertr�gt die Zeichen des Buffers      �
  �                    �awBuffer_m� in die TEXTBOX-Struktur des zuletzt    �
  �                    ge�nderten Textes.                                  �
  �                                                                        �
  �  R�ckgabewert:     keinen                                              �
  �                                                                        �
  �  Benutzte globale                                                      �
  �  Variablen (R/W):   - awBuffer_m (R)                                   �
  �                     - pTBold_m (R)                                     �
  ������������������������������������������������������������������������ͼ*/
STATIC
VOID i_StrukturAkt(VOID)
{
    PCHAR pcZiel   = pTB_m->acText;		    /* Hilfszeiger	    */
    PWORD pwQuelle = awBuffer_m;

    if (wNbZeichen_m)
        for (; pwQuelle <= pwBufferE_m;)
	    *pcZiel++ =  (CHAR) *pwQuelle++;	    /* Text in die Struktur */
                                                    /* eintragen            */

    *pcZiel = '\0';                                 /* Zeichenkette mit '\0'*/
                                                    /* abschlie�en          */
    for(pcZiel--;pcZiel >= pTB_m->acText;pcZiel--)
       if (*pcZiel == ' ')
         *pcZiel = '\0';
       else break;
    if (pcZiel < pTB_m->acText)
       wNbZeichen_m = 0;

   /* Vi_Ss(5, 15, pTB_m->acText); Ut_Warte(); */

}



/*������������������������������������������������������������������������ͻ
  �  Funktionsname:    i_TextboxAkt                   Datum: 24.12.88      �
  ������������������������������������������������������������������������Ķ
  �                                                                        �
  �  Parameter:        WORD   wSpalte   Absolute Startspalte               �
  �                    PWORD  pwFirst   Zeiger auf erstes auszugebendes    �
  �                                     Zeichen                            �
  �                                                                        �
  �                                                                        �
  �  Beschreibung:     Die Funktion aktualisiert den Inhalt der Textbox    �
  �                    auf dem Bildschirm. Sie gibt dazu ab der durch      �
  �                    �wSpalte� bestimmten Position Zeichen des Editier-  �
  �                    buffers �awBuffer_m[]� in dem Textfenster aus.      �
  �                    Die Funktion beendet die Ausgabe wenn sie den       �
  �                    rechten Rand der Textbox erreicht hat.              �
  �                    Die aufrufende Funktion mu� sicherstellen, da�      �
  �                    der Buffer nicht �ber sein Ende hinaus ausgegeben   �
  �                    wird.                                               �
  �                                                                        �
  �  R�ckgabewert:     Die Funktion hat keinen R�ckgabewert.               �
  �                                                                        �
  �  Benutzte globale                                                      �
  �  Variablen (R/W):   - awBuffer_m[]  (R)                                �
  �                     - pTB_m (W)                                        �
  ������������������������������������������������������������������������ͼ*/
STATIC
VOID i_TextboxAkt(WORD wSpalte, PWORD pwFirst)
{
WORD wStatus;

wStatus=Ms_CursorOff();

Vi_Sb2w(wSpalte, pTB_m->wFensterZ,
  pTB_m->wFensterB-(wSpalte-pTB_m->wFensterS),
  1, (FPWORD)pwFirst);

/* {REGISTER i; 	    testprint eine Zeile tiefer:
 for(i=0; i<pTB_m->wFensterB-(wSpalte-pTB_m->wFensterS); i++)
   Vi_Sz(wSpalte+i, pTB_m->wFensterZ+1, (PUSTR)(pwFirst+i)); } */

if(wStatus == MSM_WAR_AN && wMausda_g)
  Ms_CursorOn();
}


/*������������������������������������������������������������������������ͻ
  �  Funktionsname:    i_SchiebeTextsegment           Datum: 19.08.88      �
  ������������������������������������������������������������������������Ķ
  �                                                                        �
  �  Parameter:        WORD  wRichtung	Richtung in die geschoben werden  �
  �                                      soll:                             �
  �                                                                        �
  �                                        RECHTS: nach rechts schieben    �
  �                                        LINKS:  nach links schieben     �
  �                                                                        �
  �  Beschreibung:     Die Funktion verschiebt den Textbereich von         �
  �                    der aktuellen Cursorposition bis zum Textende.      �
  �                    Die Bewegungsrichtung wird durch das Vorzeichen     �
  �                    des Parameters �wRichtung� gew�hlt.                 �
  �                    Wenn der Textbereich nach rechts geschoben wird,    �
  �                    l��t die Funktion das Zeichen an der aktuellen      �
  �                    Cursorposition unver�ndert. Der Textbereich kann    �
  �                    das Ende des Buffers nicht �berschreiten.           �
  �                    Beim Linksschieben werden die Zeichen an der ak-    �
  �                    tuellen Cursorposition verschluckt.                 �
  �                                                                        �
  �  R�ckgabewert:     keinen                                              �
  �                                                                        �
  �  Benutzte globale                                                      �
  �  Variablen (R/W):   - awBuffer_m (W)                                   �
  �                     - pwBufferC_m (W)                                  �
  �                     - pwBufferE_m (W)                                  �
  �                     - pTB_m (R)                                        �
  ������������������������������������������������������������������������ͼ*/
STATIC
VOID i_SchiebeTextsegment( WORD wRichtung )
{
    PWORD pwTemp = NULL;                            /* Hilfszeiger          */
    WORD  wAttri   = pTB_m->wAttri << 8;            /* Textattribut         */
    wAttri=aCS_g[wCSInd_g].wCs_wdlg << 8;

   boTestModus_g=JA;
   Wi_TestPrintf(pWkbInfo_g, "\niSchiebe(%d)=%d.", wAttri, wRichtung);
   boTestModus_g=NEIN;


    if ( wRichtung == RECHTS &&                     /* nach rechts schieben */
         pwBufferC_m <= pwBufferE_m &&
	 pwBufferE_m-awBuffer_m < pTB_m->wMaxL &&
         pTB_m->wMaxL != 1)
    {
        pwBufferE_m++;                              /* Zeiger aktualisieren */

        for ( pwTemp = pwBufferE_m;
              pwTemp > pwBufferC_m;
              pwTemp-- )
            *pwTemp = *(pwTemp -1);                 /* Text verschieben     */

    }
    if ( wRichtung == LINKS &&                      /* nach links schieben  */
         pwBufferC_m <= pwBufferE_m &&
         ( pwBufferE_m > awBuffer_m ||
           awBuffer_m[0] != (wAttri | ' ')))
    {
        for ( pwTemp = pwBufferC_m;
              pwTemp < pwBufferE_m;
              pwTemp++)
            *pwTemp = *(pwTemp + 1);                /* Text verschieben     */

        *pwTemp = wAttri |= ' ';                    /* Leerzeichen anh�ngen */

        if (pwBufferE_m > awBuffer_m)
          pwBufferE_m--;                            /* Zeiger aktualisieren */
    }
}



/*������������������������������������������������������������������������ͻ
  �  Funktionsname:    i_BewegeCursor                 Datum: 24.12.88      �
  ������������������������������������������������������������������������Ķ
  �                                                                        �
  �  Parameter:        WORD  wRichtung	Richtung in die der Cursor be-	  �
  �                                      wegt werden soll:                 �
  �                                        RECHTS : nach rechts bewegen    �
  �                                        LINKS  : nach links bewegen     �
  �                                        HOME   : Textanfang             �
  �                                        ENDE   : Textende               �
  �                                                                        �
  �  Beschreibung:     Die Funktion bewegt den Cursor innerhalb der Text-  �
  �                    box. Die Bewegungsrichtung wird durch den Parameter �
  �                    �wRichtung� gew�hlt.                                �
  �                    Wenn sich der Cursor an einem der R�nder der Box    �
  �                    befindet, wird der Text gescrollt.                  �
  �                                                                        �
  �  R�ckgabewert:     keinen                                              �
  �                                                                        �
  �  Benutzte globale                                                      �
  �  Variablen (R/W):   - awBuffer_m (W)                                   �
  �                     - pwBufferC_m (W)                                  �
  �                     - pwBufferE_m (W)                                  �
  �                     - pTB_m (R)                                        �
  ������������������������������������������������������������������������ͼ*/
STATIC
VOID i_BewegeCursor( WORD wRichtung )
{

  if (wRichtung == RECHTS)
  {
    if (pTB_m->wCursorS < pTB_m->wFensterS +        /* kann der Cursor in   */
                          pTB_m->wFensterB - 1 ||   /* der Textbox bewegt   */
       (pTB_m->wMaxL <= pTB_m->wFensterB &&
        pTB_m->wCursorS < pTB_m->wFensterS +
                          pTB_m->wFensterB))        /* werden ?             */
    {
      pwBufferC_m++;
      Vi_SetCursorPos(++pTB_m->wCursorS,            /* Cursor nach rechts   */
                      pTB_m->wFensterZ);            /* bewegen              */
    }
    else if (pwBufferC_m < awBuffer_m +             /* scrollen m�glich?    */
                           pTB_m->wMaxL)
    {
      pwBufferC_m++;
      i_TextboxAkt( pTB_m->wFensterS,
                    pwBufferC_m-pTB_m->wFensterB+1 );
    }
  }

  if (wRichtung == LINKS)
  {
    if (pTB_m->wCursorS > pTB_m->wFensterS)
    {
      pwBufferC_m--;
      Vi_SetCursorPos(--pTB_m->wCursorS,            /* Cursor nach links    */
                      pTB_m->wFensterZ);            /* bewegen              */
    }
    else if (pwBufferC_m >awBuffer_m)               /* scrollen m�glich ?   */
    {
      pwBufferC_m--;
      i_TextboxAkt( pTB_m->wFensterS,
                    pwBufferC_m );
    }
  }

  if (wRichtung == HOME)
  {
    pwBufferC_m = awBuffer_m;                       /* Cursor an Bufferan   */
    pTB_m->wCursorS = pTB_m->wFensterS;             /* fang setzen          */

    Vi_SetCursorPos(pTB_m->wCursorS,                /* und positionieren    */
                    pTB_m->wFensterZ);

    i_TextboxAkt( pTB_m->wFensterS,
                  pwBufferC_m );
  }
  if (wRichtung == ENDE)
  {
    if (!wNbZeichen_m)                              /* keine Zeichen ?      */
      {
       pwBufferE_m = pwBufferC_m = awBuffer_m;
       pTB_m->wCursorS = pTB_m->wFensterS;
       Vi_SetCursorPos(pTB_m->wCursorS,             /* Cursor positionieren */
                       pTB_m->wFensterZ);
       return;
      }
    while ( *pwBufferE_m-- == (pTB_m->wAttri << 8 | ' '))
        ;
    pwBufferC_m = ++pwBufferE_m +1;		     /* Cursor an Bufferende */

    if ( pwBufferE_m-awBuffer_m >	     /* Ist der Text gr��er  */
	 pTB_m->wFensterB-1 )			     /* als das Textfenster? */
    {
      pTB_m->wCursorS = pTB_m->wFensterS +          /* Cursor ans Fenster-  */
                           pTB_m->wFensterB -1;     /* ende setzen          */

      i_TextboxAkt( pTB_m->wFensterS,
                    pwBufferC_m-pTB_m->wFensterB + 1 );

    }
    else
    {
      pTB_m->wCursorS = pTB_m->wFensterS +          /* Cursor ans Textende  */
                        pwBufferC_m - awBuffer_m;   /* setzen               */

      i_TextboxAkt( pTB_m->wFensterS,
                    awBuffer_m );
    }

    Vi_SetCursorPos(pTB_m->wCursorS,                /* Cursor positionieren   */
                    pTB_m->wFensterZ);
  }
}

