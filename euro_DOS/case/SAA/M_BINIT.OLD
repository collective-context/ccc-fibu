/*.ta M_BInit()
ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
บ  M_BInit()                                                                   บ
ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ

berblick:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
#include <eur_tool.h>
WORD M_BInit (pstrApp, apWkbMask[], apstrText[][25], pTextBox[][99],
              pwMasks, pwFirstFieldNumber, awBlocks[][2],
              awScroll[][4], pwNbFile, apstrDatei[], apstrRecord[],
              awInitRecLen[], awRecLen[], pstrFehler)

Parameter:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
PSTR     pstrApp              Zeiger auf das Applikationskennzeichen.
PWKB     apWkbMask[]          Array von Zeigern auf die Maskenattribute.
PSTR     apstrText[][25]      Array von Zeigern auf den Maskentext.
PTEXTBOX pTextBox[][99]       Zeiger auf Array mit den Textboxen.
PWORD    pwMasks,             Zeiger auf Array mit den Maskennummern.
PWORD    pwFirstFieldNumber   Zeiger auf Array mit der ersten Feldnummer
                              jeder Maske.
WORD     awBlocks[][2]        Array mit der Information ber Blocktyp 1.
WORD     awScroll[][4]        Array mit der Scrollinformation fr Blocktyp 1.
PWORD    pwNbFile             Zeiger auf die Anzahl der verwendeten Dateien.
PSTR     apstrDatei[]         Array von Zeigern auf die Dateinamen.
PSTR     apstrRecord[]        Array von Zeigern auf die Dateibuffer.
WORD     awInitRecLen[]       Array mit den min. Datensatzlngen.
WORD     awRecLen[]           Array mit den akt. Datensatzlngen.
PSTR     pstrFehler           Zeiger auf die Fehlerinformation.


Beschreibung:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
Meldet alle angegebenen Maskennummern aus der Bibliothek , die durch
das in ฏpstrAppฎ bergebene Applikationskennzeichen festgelegt ist, an.
Die Masken knnen erst danach aufgerufen werden.
M_BInit () speichert in der ฏTextboxฎ-Struktur alle fr den Interpreter
wichtigen Informationen ab, damit dieser Sie nicht mehr aus der Bibliothek
lesen muแ.
Aus diesem Grund mssen alle Masken, die im Programm(teil) verwendet werden
sollen, zuvor einmal angemeldet werden. Es ist ein wiederholten Aufruf
von M_BInit () im gleichen Programm(teil) mglich.
Es ist mglich, die Masken bereits vor Start des nutzenden Programmes von
einem Initialisierungs- oder Menu-Programm anzumelden.
Ferner werden durch M_BInit () auch allgemeine Initialisierungen vorgenommen
die direkt mit den Masken nichts zu tun haben. Durch einen Aufruf von
M_BInit wird den zu den Masken gehrigen Dateibuffern Speicherplatz
zugewiesen und die Grแe der aufrufenden Funktion mitgeteilt.
Da diese Variablen in fast allen Tool-Routinen bentigt wird, ist es ratsam
M_BInit () als eine der ersten Routinen berhaupt aufzurufen.


Versorgung:

   Eingang:
      pstrApp:      Ein im allg. zweistelliges Applikationskennzeichen, das
                    zur Identifikation der Maskenbibliothek dient.
      pwMasks:      Ein Zeiger auf ein Array mit den zu initialisierenden
                    Maskennummern aus der Bibliothek.
      pstrFehler:   Zeiger auf die Fehlerinformation, die beim Auftreten
                    eines Fehlers oder beim Programmablauf im Testmodus
                    im Fehlerfenster zustzlich angezeigt werden soll.
                    Sie dient zur eindeutigen Feststellung des Ortes
                    im Programm, an dem der Fehler aufgetreten ist.

   Ausgang:
      apWkbMask:    Ein Array von Zeigern auf sog. ฏWindowkontrollblckeฎ.
                    Diese werden vom internen Windowmanager bentigt.
      apstrText:    Ein Array von Zeigern auf den auszugebenden Maskentext.
      pTextBox:     Ein Array von Zeigern auf die ฏTextboxฎ-Struktur,die
                    alle fr den Interpreter wichtigen Informationen enthlt.
      pwFirstFieldNumber : Ein Zeiger auf ein Array mit der ersten
                    anzuspringenden Feldnummer jeder Maske.
      awBlocks:     Ein Array mit den Blockinformationen zum Blocktyp 1.
      awScroll:     Ein Array mit der Scrollinformation zum Blocktyp 1.
      pwNbFile:     Ein Zeiger auf die Anzahl der initialisierten Dateibuffer.
      apstrDatei:   Ein Array von Zeigern auf die zu ffnenden Dateinamen.
      apstrRecord:  Ein Array von Zeigern auf die fr die internen Dateibuffer
                    reservierten Speicherbereiche.
      awInitRecLen: Ein Array mit den minimalen Grแen der Dateibuffer.
      awRecLen:     Ein Array mit den aktuellen Grแen der Dateibuffer.
                    Diese Werte sind naturgemแ beim Verlassen der Funktion
                    M_BInit () gleich der im Array awInitRecLen.


Rckgabewert:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
WORD  Fehlerinformation OK/ERROR


Benutzte globale Variablen (R/W):
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
Variablen (R/W):  - aCS_g[]    (R)           - boTestModus_g (R)
                  - wCSInd_g   (R)           - strExe_g      (R)
                  - strDat_g   (R)           - strExt_g      (R)
                  - strMan_g   (R)
.ff
REM .de \euro\demo\dmohilf1.c
.te*/

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                         DEKLARATIONS-DATEIEN                             บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
#define NDEBUG 1
#include <stdio.h>
#include <string.h>
#include <process.h>                                   /*  fuer execl()       */
#include <eur_tool.h>

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ              GLOBALE VARIABLEN, DEFINITION UND REFERENZEN                บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
IMPORT COLORSET aCS_g[];
IMPORT WORD     wCSInd_g;
IMPORT BOOL     boTestModus_g;
IMPORT WORD     wVioMode_g;
IMPORT CHAR     strExe_g[];                            /* ฏEXEฎ Verzeichnis   */
IMPORT CHAR     strExt_g[];                            /* Lnderextension     */
IMPORT CHAR     strTxt_g[];                            /* Lnderextension     */
IMPORT CHAR     strDat_g[];                            /* Datenverzeichnis    */
IMPORT CHAR     strTeiln_g[];                          /* Teilnehmerverzeichn.*/
IMPORT CHAR     strMan_g[];                            /* Mandantennummer     */
IMPORT PSTR     pstrDataBuffer_g;
IMPORT CHAR	acHlpFile_g[];		    /* Name der Hilfedatei / _MSK 0 */
IMPORT CHAR	acHlpKey_g[];		    /* Hilfstext-Schlssel / 2x[F1] */
IMPORT	ERRINFO errInfo_g;

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        MODULGLOBALE FUNKTIONEN                           บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC	  PTEXTBOXINIT	  i_InsertTextBox    (PMASKS, PTEXTBOXINIT);
STATIC	  PTEXTBOXINIT	  i_CheckRef	     (PMASKS, PTEXTBOXINIT);
STATIC	  PTEXTBOXINIT	  i_DeleteTextBox    (PTEXTBOXINIT);
STATIC	  VOID		  i_SetFirstField    (PMASKS, WORD);
STATIC	  PTEXTBOXINIT	  GetTextBox	     (PMASKS, WORD);
STATIC	  PTEXTBOXINIT	  SetTextBox	     (PTEXTBOXINIT, WORD, WORD, WORD,
			  WORD, WORD, WORD,  BOOL, WORD, WORD, WORD, WORD);


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        MODULGLOBALE VARIABLEN                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
#define RECMATCH  1
#define REFMATCH  2
#define ADDMATCH  4
#define RECKEY    8
#define REFFIELD 16

typedef struct tagFLAG
  {
   WORD wFeldNr;
   WORD wArt;
   PSTR pstrTxt;
   WORD wDatei;
   CHAR strDatenfeld[11];
   struct tagFLAG *pNext;
  } REC_INFO_MC;

REC_INFO_MC *(pRecInfo_m[20]), *pInfoLauf_m;   /* Max. 20 Masken gleichzeitig */

CHAR strFileBlock_m[128];                            /* Fileblock fr Btrieve */
PSTR pstrMaskKey_m;

STATIC CHAR acBlockName_m [21];

STATIC WORD wBlockX_m, wBlockY_m, wBlockH_m,
	     wBlockB_m, wBlockO_m, wBlockL_m;

MGLOBAL PTEXTBOXINIT pTBLHelp_m, pTBL1Help_m;

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                          FUNKTIONS-DEFINITION                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD M_BInit (PSTR pstrApp,  PWKB apWkbMask[], PSTR apstrText[][25],
              PMASKS *ppMasks, PWORD pwMasks, BFILEINFO **aFiles,
              PWORD pwNbFile, PSTR apstrDatei[],
              PSTR apstrRecord[], WORD awFixRecLen[], WORD awRecLen[],
              PSTR apstrPosition[], WORD awPosLen[],
              WORD awFileMode[], PPSTR ppstrIndexKey, PSTR pstrFehler)
{
WORD i, j, k, l;
PMASKS pMHelp=NULL, pMLauf, pMStart;
PINITBLOCKS pBlHelp=NULL;
FELDINFO *ptempinfo;
CHOICES  *ptempchoice;
SWORD wRetCode, wBufferLength;
WORD wAttri, wFensterS, wFensterZ, wFensterB, wCursorS, wMaxL,
     wSequenz, wModus, wRecord, wOffset, wMaxMask;
BOOL boInsert;
WORD wSpalte, wZeile, wBreite, wHoehe, wNull;
PSTR pstrMaskenDatei=NULL;
CHAR strTitel[80], strNull[TB_MAX];
CHAR strBuffer[200];
WORD wTitelPos;
WORD wTitelAttr, wRahmenAttr, wInnenAttr;
CHAR strError[TB_MAX];
CHAR acVerzeichnisName[20];
BOOL aboFixLength[50];
PSTR pstrDateiName;
PSTR pstrPos;
PSTR pstrTemp;
WORD awDateiNummer[20][20];    /* Die Indices der Arrays gelten unter der An- */
                               /* nahme, daแ max. 20 Masken und 20 Dateien    */
                               /* gleichen Zeit bentigt werden. Der erste    */
                               /* Index steht fr die Anzahl der Masken, der  */
                               /* zweite fr die Anzahl der Dateien.          */

WORD awNbRecKeys[20];
WORD awNbRefFields[20];
WORD awNbRefCopies[20];
WORD awNbMatchFields[20];

BMATCH *pLastMatch;
BFILEINFO *aFileInfo=NULL;
PSTR  apstrMessage[25];

/*PWKB pWkbInfo=NULL;				     /* Fr Wi_TestPrintf() */
/*pWkbInfo = Wi_Einrichten (3,11,72,11);	     /* WindowKontollBlock   */
/*Wi_SchattenEin (pWkbInfo);			     /* fr Wi_TestPrintf()  */

*ppstrIndexKey = NULL;
Ut_Calloc(pstrMaskKey_m, 20, CHAR);	   /* Reservieren von 20 Zeichen    */
                                             /* fr den Schlssel der Maske   */
                                             /* in der Bibliothek .           */

Ut_Calloc(pstrMaskenDatei, TB_MAX, CHAR);   /* Maskendateiname, max. 128     */
					     /* Zeichen.		      */

memcpy(acHlpFile_g, "SYHLP10", HLPFL); /* Default-Name der Hilfedatei 2x[F1] */
memcpy(acHlpKey_g, "blank", HLPKEY);   /* Default-Schlssel bei 2x[F1]	     */

sprintf(pstrMaskenDatei, "%s%s%s%s", strExe_g,	    /* Maskendatei aus glo-  */
		   pstrApp, "MASK.", strExt_g);     /* balen Variablen bilden*/

for (j=0; j<50; j++)
   aboFixLength[j] = NEIN;

for (j=0; *(pwMasks+j); j++)                        /* Anzahl Masken ermitteln*/
   wMaxMask = j;

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                         FFNEN-BIBLIOTHEK                                บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
    sprintf(pstrDataBuffer_g, "(c)Mayer", pstrApp);
    wBufferLength = strlen(pstrDataBuffer_g)+1;
    wRetCode = BTRV (B_OPEN, strFileBlock_m, pstrDataBuffer_g,
               &wBufferLength, pstrMaskenDatei, O_NORMAL);  /* -(i03)- */

    if (wRetCode == 20)
      {
       Dl_Nachricht ( NULL, 0, 0);
       Ut_SchreibArray (apstrMessage, "Fehler:",
                                      "        Vor dem Programmstart ",
                                      "        bitte Btrieve laden!",
                                      NULL);
       Dl_Info ( apstrMessage, DLG_KRITISCH);
       Ut_LoeschArray (apstrMessage);
       E(); exit (-1);
      }

    sprintf(strError,"M_BInit(B_OPEN/%s), - "        /*                      */
      "Datei: %s", pstrFehler, pstrMaskenDatei, 0);  /*                      */

    Dl_ErrorHandler (wRetCode, strError,             /*                      */
      __FILE__, __LINE__, 0);                        /*                      */


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ ฏฏฏ Start der Informationszuordnung fr alle Bildschirmmasken !!!	     บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
for (j=0; *(pwMasks+j); j++)
   {
    Ut_Calloc(pMHelp, 1, MASKS);

    pMHelp->wMaskSignatur = MASKSIGNATUR;
    pMHelp->boWriteBlocks = NEIN;
    pMHelp->wMaskNumber = j;

    if (*(pwMasks+j) > 999)
      sprintf (strBuffer, "%2s%#04d", pstrApp, *(pwMasks+j) );
    else
      sprintf (strBuffer, "%2s%#03d", pstrApp, *(pwMasks+j) );

    Ut_Calloc(pMHelp->pstrMaskName, strlen(strBuffer)+1, CHAR);
    strcpy (pMHelp->pstrMaskName, strBuffer);

    memset (pstrMaskKey_m, '\0', 20);

    Ut_Calloc(pBlHelp, 1, INITBLOCKS);

    pBlHelp->wBlSignatur = BLOCKSIGNATUR;
    pBlHelp->pTBLWurzel = NULL;
    pBlHelp->pTBLEnd = NULL;
    Ut_Calloc(pBlHelp->pstrBlockName, 7, CHAR);
    strcpy (pBlHelp->pstrBlockName, "(null)");
    pBlHelp->wBlockOffset = 0;
    pBlHelp->wBlockLength = 0;
    pBlHelp->wBlockHoehe = 0;
    pBlHelp->wBlockBreite = 0;
    pBlHelp->pNext = NULL;

    pMHelp->pBlInitWurzel = pBlHelp;
    pMHelp->pNext = NULL;
    pBlHelp=NULL;  /* ~ */

    if (j)
      {
       pMLauf->pNext = pMHelp;
       pMHelp->pLast = pMLauf;
       pMLauf = pMHelp;
      }
    else
      {
       pMHelp->pLast = NULL;
       pMStart = pMLauf = pMHelp;
      }
    pMHelp=NULL;    /* ~ */

    if ( *(pwMasks+j) > 999)
      sprintf (pstrMaskKey_m, "%#04d", *(pwMasks+j));
    else
      sprintf (pstrMaskKey_m, "%#03d", *(pwMasks+j));

    wBufferLength = MAX_RECORD_SIZE;

    wRetCode = BTRV (B_GET_EQ, strFileBlock_m, pstrDataBuffer_g, &wBufferLength,
                      pstrMaskKey_m, 0);  /* -(i12)- */

      sprintf(strError,"M_BInit(B_GET_EQ/%s), - "    /*                      */
        "Schlssel: %s",pstrFehler,pstrMaskKey_m,0); /*                      */

      Dl_ErrorHandler (wRetCode, strError,           /*                      */
        __FILE__, __LINE__, 0);                      /*                      */

    pstrPos = pstrDataBuffer_g + 85;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        MASKENTEXT-ZUORDNUNG                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
    for (i=0; *pstrPos; i++)
       {
        if (i < 25)
          {
	   Ut_Calloc(apstrText[j][i], 121, CHAR);
           strcpy (apstrText[j][i], pstrPos);
          }
        pstrPos = strchr(pstrPos, '\0') + 1;
       }
    apstrText[j][i] = NULL;                    /* Null-Pointer */
    pstrPos++;

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                    WINDOWEINRICHTEN-ZUORDNUNG                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/

    {
    PSTR pstrTmp;

    strcpy (strBuffer, pstrPos);
    pstrPos = strchr(pstrPos, '\0') + 1;

    pstrTmp = strBuffer;

    sscanf(pstrTmp, "%3d", &wSpalte);	  pstrTmp += 4;
    sscanf(pstrTmp, "%3d", &wZeile);	  pstrTmp += 4;
    sscanf(pstrTmp, "%3d", &wBreite);	  pstrTmp += 4;
    sscanf(pstrTmp, "%3d", &wHoehe);	  pstrTmp += 4;
    sscanf(pstrTmp, "%3d", &wTitelAttr);  pstrTmp += 4;
    sscanf(pstrTmp, "%3d", &wRahmenAttr); pstrTmp += 4;
    sscanf(pstrTmp, "%3d", &wInnenAttr);  pstrTmp += 4;
    sscanf(pstrTmp, "%3d", &wTitelPos);   pstrTmp += 4;
    sscanf(pstrTmp, "%s",  strTitel);
    }

    if (*strTitel != 'ฤ')
      sprintf (&strTitel[strlen(strTitel)], " - %1d/%1d", j+1, wMaxMask+1);

    if (j % 2 && wBreite < 80)
      {
       wTitelAttr = aCS_g[wCSInd_g].wCs_m_r2;	     /* Masken-Rahmen 2      */
       wRahmenAttr = aCS_g[wCSInd_g].wCs_m_r2;	     /* Masken-Rahmen 2      */
       wInnenAttr = aCS_g[wCSInd_g].wCs_m_i2;	     /* Maske-Innen 2	     */
      }
    else
      {
       wTitelAttr = aCS_g[wCSInd_g].wCs_m_r1;	     /* Masken-Rahmen 1      */
       wRahmenAttr = aCS_g[wCSInd_g].wCs_m_r1;	     /* Masken-Rahmen 1      */
       wInnenAttr = aCS_g[wCSInd_g].wCs_m_i1;	     /* Maske-Innen 1	     */
      }

    apWkbMask[j] = Wi_Einrichten(wSpalte, wZeile, wBreite, wHoehe);

    if (*(strTitel+1) != 'ฤ' ||
         *strTitel    != 'ฤ')
      Wi_SetTitel(apWkbMask[j], strTitel, wTitelPos);

    Wi_SetAttri(apWkbMask[j], wTitelAttr, wRahmenAttr, wInnenAttr);

    if (wBreite < 78 && wHoehe < 22)
      Wi_SchattenEin(apWkbMask[j]);

    for (i=0;apstrText[j][i];i++)
      strpad (apstrText[j][i], wBreite-2);

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                       TEXTBOX-ZUORDNUNG                                  บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
    for (i=0; *pstrPos; i++)
       {
        PSTR pstrTmp;
        SWORD swRefCode;

        strcpy (strBuffer, pstrPos);
        pstrPos = strchr(pstrPos, '\0') + 1;

        pstrTmp = strBuffer;

	if(i <= 99)
	  {
	   sscanf(pstrTmp,"%20s", acBlockName_m); pstrTmp += 21;
	   sscanf(pstrTmp, "%3d", &wBlockX_m);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wBlockY_m);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wBlockH_m);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wBlockB_m);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%5d", &wBlockO_m);	  pstrTmp += 6;
	   sscanf(pstrTmp, "%5d", &wBlockL_m);	  pstrTmp += 6;
	   sscanf(pstrTmp, "%3d", &wAttri);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wFensterS);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wFensterZ);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wFensterB);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wCursorS);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wMaxL);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &boInsert);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wSequenz);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%3d", &wModus);	  pstrTmp += 4;
	   sscanf(pstrTmp, "%2d", &wRecord);	  pstrTmp += 3;
	   sscanf(pstrTmp, "%5d", &wOffset);	  pstrTmp += 6;

           if (j % 2 && wBreite < 80)
	       wAttri = aCS_g[wCSInd_g].wCs_m_itb2;  /* Inaktive TextBox 2   */
           else
	       wAttri = aCS_g[wCSInd_g].wCs_m_itb1;  /* Inaktive TextBox 1   */

	   pTBLHelp_m=SetTextBox(pTBLHelp_m, wAttri,
                 wFensterS, wFensterZ, wFensterB, wCursorS, wMaxL,   boInsert,
				       wSequenz,  wModus,  wRecord, wOffset);

	   sscanf(pstrTmp, "%8s", pTBLHelp_m->acHelpFile);   pstrTmp+= 9;
	   sscanf(pstrTmp, "%6s", pTBLHelp_m->acHelpKey);    pstrTmp+= 7;
	   sscanf(pstrTmp, "%5d", &swRefCode);		     pstrTmp+= 6;
	   sscanf(pstrTmp, "%3d", &pTBLHelp_m->bTyp);	     pstrTmp+= 4;
	   sscanf(pstrTmp, "%3d", &pTBLHelp_m->sbKomma);     pstrTmp+= 4;
	   sscanf(pstrTmp,"%11s", pTBLHelp_m->strDatenfeld); pstrTmp+= 12;
	   sscanf(pstrTmp, "%3d", &pTBLHelp_m->bVKS);	     pstrTmp+= 4;
	   sscanf(pstrTmp, "%3d", &pTBLHelp_m->bNKS);	     pstrTmp+= 4;
	   sscanf(pstrTmp, "%3d", &pTBLHelp_m->wHide);	     pstrTmp+= 4;

	   pTBLHelp_m->swRefCode = swRefCode;
	   pTBLHelp_m->pRefField = NULL;

	   Ut_Calloc(pTBLHelp_m->pFeld, 1, FELDINFO);
	   ptempinfo = pTBLHelp_m->pFeld;

           for (;*pstrPos;)
             {
              REGISTER k;

              strcpy (strBuffer, pstrPos);
              pstrPos = strchr (pstrPos, '\0') + 1;

              pstrTmp = strBuffer;

	      sscanf(pstrTmp, "%3d", &ptempinfo->bArt);     pstrTmp+= 4;
	      sscanf(pstrTmp, "%3d", &ptempinfo->sbLaenge); pstrTmp+= 4;

	      for (k=0; k < 20; k++)
		{
		 if (*pstrTmp != '')
		   {
		   sscanf(pstrTmp, "%3d", &ptempinfo->abFormat[k]);
		   pstrTmp += 4;
		   }
		 else
		   ptempinfo->abFormat[k] = 0;
		}

              if (*pstrPos)
               {
		Ut_Calloc(ptempinfo->pNext, 1, FELDINFO);
		ptempinfo=ptempinfo->pNext;
               }
             }

           pstrPos++;

           if (*pstrPos)                                  /* Choicefeld !!! */
             {
	      pTBLHelp_m->pSelect = NULL;
	      Ut_Calloc(pTBLHelp_m->pstrChoiceTitel,
		strlen (pstrPos), CHAR);
	      strcpy ( pTBLHelp_m->pstrChoiceTitel, pstrPos+1);

              pstrPos = strchr (pstrPos, '\0') + 1;

	      Ut_Calloc(pTBLHelp_m->pChoice, 1, CHOICES);
	      ptempchoice = pTBLHelp_m->pChoice;

              while (*pstrPos)
                {
		 Ut_Calloc(ptempchoice->pstrWert,
		   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrWert, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

		 Ut_Calloc(ptempchoice->pstrFormat,
		   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrFormat, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

                 if (*pstrPos)
                   {
		    Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
                    ptempchoice = ptempchoice->pNext;
                   }
                 else
                   ptempchoice->pNext = NULL;
                }
             }
           else
             {
	      pTBLHelp_m->pstrChoiceTitel = NULL;
	      pTBLHelp_m->pChoice = NULL;
             }

           pstrPos++;

           if (*pstrPos)                                   /* Selectfeld !!! */
             {
	      pTBLHelp_m->pChoice = NULL;
	      Ut_Calloc(pTBLHelp_m->pstrChoiceTitel,
		strlen (pstrPos), CHAR);
	      strcpy ( pTBLHelp_m->pstrChoiceTitel, pstrPos+1);

              pstrPos = strchr (pstrPos, '\0') + 1;

	      Ut_Calloc(pTBLHelp_m->pSelect, 1, CHOICES);
	      ptempchoice=pTBLHelp_m->pSelect;

              while (*pstrPos)
                {

		 Ut_Calloc(ptempchoice->pstrWert,
		   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrWert, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

		 Ut_Calloc(ptempchoice->pstrFormat,
		   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrFormat, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

                 if (*pstrPos)
                   {
		    Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
                    ptempchoice = ptempchoice->pNext;
                   }
                 else
                   ptempchoice->pNext = NULL;

                }
             }
           else                            /* kein Choicefeld */
	      pTBLHelp_m->pSelect = NULL;

	  }

       pstrPos++;

       if(*pstrPos)			     /* es gibt noch TextBoxFelder */
	 pTBLHelp_m=i_InsertTextBox(pMLauf, pTBLHelp_m);
       else
	 {i_SetFirstField(pMLauf, wSequenz);	     /* aus letzter Textbox */
	 pTBLHelp_m=i_DeleteTextBox(pTBLHelp_m);}
       } /* end for */

    pstrPos++;

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                       REF_BOX-ZUORDNUNG                                  บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
    for (i=0; *pstrPos; i++)
       {
        PSTR pstrTmp;
        SWORD swRefCode;

        strcpy (strBuffer, pstrPos);
        pstrPos = strchr(pstrPos, '\0') + 1;

        pstrTmp = strBuffer;

        if (i <= 99)
         {
           sscanf (pstrTmp, "%20s", acBlockName_m);
           pstrTmp += 21;
           sscanf (pstrTmp, "%3d", &wAttri);
           pstrTmp += 4;
           sscanf (pstrTmp, "%3d", &wFensterS);
           pstrTmp += 4;
           sscanf (pstrTmp, "%3d", &wFensterZ);
           pstrTmp += 4;
           sscanf (pstrTmp, "%3d", &wFensterB);
           pstrTmp += 4;
           sscanf (pstrTmp, "%3d", &wCursorS);
           pstrTmp += 4;
           sscanf (pstrTmp, "%3d", &wMaxL);
           pstrTmp += 4;
           sscanf (pstrTmp, "%3d", &boInsert);
           pstrTmp += 4;
           sscanf (pstrTmp, "%3d", &wSequenz);
           pstrTmp += 4;
	   sscanf (pstrTmp, "%3d", &wModus);
           pstrTmp += 4;
           sscanf (pstrTmp, "%2d", &wRecord);
           pstrTmp += 3;
           sscanf (pstrTmp, "%5d", &wOffset);
           pstrTmp += 6;

           if (j % 2 && wBreite < 80)
	       wAttri = aCS_g[wCSInd_g].wCs_m_itb2;  /* Inaktive TextBox 2   */
           else
	       wAttri = aCS_g[wCSInd_g].wCs_m_itb1;  /* Inaktive TextBox 1   */

	   pTBL1Help_m=SetTextBox(pTBL1Help_m, wAttri,
                 wFensterS, wFensterZ, wFensterB, wCursorS, wMaxL,   boInsert,
				       wSequenz,  wModus,  wRecord, wOffset);

	   sscanf (pstrTmp, "%8s", pTBL1Help_m->acHelpFile);
           pstrTmp += 9;
	   sscanf (pstrTmp, "%6s", pTBL1Help_m->acHelpKey);
           pstrTmp += 7;
           sscanf (pstrTmp, "%5d", &swRefCode);
           pstrTmp += 6;
	   sscanf (pstrTmp, "%3d", &pTBL1Help_m->bTyp);
           pstrTmp += 4;
	   sscanf (pstrTmp, "%3d", &pTBL1Help_m->sbKomma);
           pstrTmp += 4;
	   sscanf (pstrTmp, "%11s",pTBL1Help_m->strDatenfeld);
           pstrTmp += 12;
	   sscanf (pstrTmp, "%3d", &pTBL1Help_m->bVKS);
           pstrTmp += 4;
	   sscanf (pstrTmp, "%3d", &pTBL1Help_m->bNKS);
           pstrTmp += 4;
	   sscanf (pstrTmp, "%3d", &pTBL1Help_m->wHide);
           pstrTmp += 4;

	   pTBL1Help_m->swRefCode = swRefCode;
	   pTBL1Help_m->pRefField = NULL;

	   Ut_Calloc(pTBL1Help_m->pFeld, 1, FELDINFO);
	   ptempinfo = pTBL1Help_m->pFeld;

           for (;*pstrPos;)
             {
              REGISTER k;

              strcpy (strBuffer, pstrPos);
              pstrPos = strchr (pstrPos, '\0') + 1;

              pstrTmp = strBuffer;

              sscanf (pstrTmp, "%3d", &ptempinfo->bArt);
              pstrTmp += 4;
              sscanf (pstrTmp, "%3d", &ptempinfo->sbLaenge);
	      pstrTmp += 4;

	      for (k=0; k < 20; k++)
		{
		 if (*pstrTmp != '')
		   {
		   sscanf (pstrTmp, "%3d", &ptempinfo->abFormat[k]);
		   pstrTmp += 4;
		   }
		 else
		   ptempinfo->abFormat[k] = 0;
		}

              if (*pstrPos)
               {
		Ut_Calloc(ptempinfo->pNext, 1, FELDINFO);
                ptempinfo = ptempinfo->pNext;
               }
             }

           pstrPos++;

           if (*pstrPos)                                  /* Choicefeld !!! */
             {
	      pTBL1Help_m->pSelect = NULL;
	      Ut_Calloc(pTBL1Help_m->pstrChoiceTitel,
		 strlen (pstrPos), CHAR);
	      strcpy ( pTBL1Help_m->pstrChoiceTitel, pstrPos+1);

              pstrPos = strchr (pstrPos, '\0') + 1;

	      Ut_Calloc(pTBL1Help_m->pChoice, 1, CHOICES);
	      ptempchoice = pTBL1Help_m->pChoice;

              while (*pstrPos)
                {
		 Ut_Calloc(ptempchoice->pstrWert,
		   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrWert, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

		 Ut_Calloc(ptempchoice->pstrFormat,
		   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrFormat, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

                 if (*pstrPos)
                   {
		    Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
                    ptempchoice = ptempchoice->pNext;
                   }
                 else
                   ptempchoice->pNext = NULL;
                }
             }
           else
             {
	      pTBL1Help_m->pstrChoiceTitel = NULL;
	      pTBL1Help_m->pChoice = NULL;
             }

           pstrPos++;

           if (*pstrPos)                                   /* Selectfeld !!! */
             {
	      pTBL1Help_m->pChoice = NULL;
	      Ut_Calloc(pTBL1Help_m->pstrChoiceTitel,
		strlen (pstrPos), CHAR);
	      strcpy ( pTBL1Help_m->pstrChoiceTitel, pstrPos+1);

              pstrPos = strchr (pstrPos, '\0') + 1;

	      Ut_Calloc(pTBL1Help_m->pSelect, 1, CHOICES);
	      ptempchoice = pTBL1Help_m->pSelect;

              while (*pstrPos)
                {
		 Ut_Calloc(ptempchoice->pstrWert,
		   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrWert, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

		 Ut_Calloc(ptempchoice->pstrFormat,
		   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrFormat, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

                 if (*pstrPos)
                   {
		    Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
                    ptempchoice = ptempchoice->pNext;
                   }
                 else
                   ptempchoice->pNext = NULL;

                }
             }
           else                            /* kein Choicefeld */
	      pTBL1Help_m->pSelect = NULL;

         }

        pstrPos++;

       pTBL1Help_m=i_CheckRef(pMLauf, pTBL1Help_m);
       }  /* end for */

    pstrPos++;



/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        MATCHCODE ZUORDNEN                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/

    Ut_Calloc(pRecInfo_m[j], 1, REC_INFO_MC);

    for (i=0,
         pInfoLauf_m = pRecInfo_m[j];
         *pstrPos; i++)
      {
       sscanf (pstrPos, "%3d %3d",
               &pInfoLauf_m->wFeldNr, &pInfoLauf_m->wArt);

       pstrPos = strchr (pstrPos, '\0') + 1;

       if (pInfoLauf_m->wArt == RECMATCH ||
           pInfoLauf_m->wArt == REFMATCH ||
           pInfoLauf_m->wArt == ADDMATCH)
         {
          pInfoLauf_m->pstrTxt = strdup(pstrPos);

          pstrPos = strchr (pstrPos, '\0') + 1;

          sscanf (pstrPos, "%3d %11s",
                  &pInfoLauf_m->wDatei, pInfoLauf_m->strDatenfeld);

          pstrPos = strchr (pstrPos, '\0') + 1;
         }
       else
         {
          pInfoLauf_m->pstrTxt = NULL;
          pInfoLauf_m->wDatei = 0;
          *pInfoLauf_m->strDatenfeld = '\0';
         }

       if (*pstrPos)
         {
	  Ut_Calloc(pInfoLauf_m->pNext, 1, REC_INFO_MC);
          pInfoLauf_m = pInfoLauf_m->pNext;
         }
       else
	 pInfoLauf_m->pNext=NULL;
      }

    pstrPos++;



/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                           DATEIEN-ZUORDNUNG                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/

    for (i=0; *pstrPos; i++)
      {
       if (apstrDatei)
         {
          WORD wRecLen;
          CHAR strVerzName[50];

          sscanf (pstrPos + 11, "%10s", strVerzName);

          pstrDateiName=strVerzName;
          while (*pstrDateiName!='.' && *pstrDateiName!='\0')
             pstrDateiName++;

          if (*pstrDateiName=='\0')
             {
              pstrDateiName=strVerzName;
              *strVerzName = '\0';
             }
          else
             {
              *pstrDateiName='\0';
              pstrDateiName++;
             }

          for (k=0; apstrDatei[k]; k++)
             if (!strncmp (apstrDatei[k], pstrDateiName,
                 strlen(pstrDateiName) ) )
             break;

          awDateiNummer[j][i] = k;

          sscanf (pstrPos+22, "%5d", &wRecLen);
          sscanf (pstrPos+28, "%1d", &awFileMode[k]);

          if (!apstrDatei[k])
            {
             acVerzeichnisName[k] = strVerzName[0];
	     Ut_Calloc(apstrDatei[k], TB_MAX, CHAR);
             strcpy (apstrDatei[k], pstrDateiName);
             awRecLen[k] = 0;
             apstrDatei[k+1] = NULL;
            }

          if (awRecLen[k] < wRecLen)
            awRecLen[k] = wRecLen;
         }
       pstrPos = strchr (pstrPos, '\0') + 1;
      }

    pstrPos++;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                      INDEXBEFEHLE-ZUORDNUNG                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/

if (!*ppstrIndexKey)
  {
   Ut_Calloc(*ppstrIndexKey, strlen(pstrPos)+1, CHAR);
   strcpy (*ppstrIndexKey, pstrPos);
  }

pstrPos = strchr(pstrPos, '\0') + 1;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                      BLOCKBEFEHLE-ZUORDNUNG                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/

    pstrTemp = pstrPos;

    sscanf (pstrTemp, "%3d", &pMLauf->wScrollZeile);
    pstrTemp += 4;
    sscanf (pstrTemp, "%3d", &pMLauf->wScrollSpalte);
    pstrTemp += 4;
    sscanf (pstrTemp, "%3d", &pMLauf->wScrollHoehe);
    pstrTemp += 4;
    sscanf (pstrTemp, "%3d", &pMLauf->wScrollBreite);

    pMLauf->pBlAktZeile      =
    pMLauf->pBlAlteZeile     =
    pMLauf->pBlLastZeile     =
    pMLauf->pBlOldLastZeile  = NULL;

    pMLauf->pBlAktSpalte     =
    pMLauf->pBlAlteSpalte    =
    pMLauf->pBlLastSpalte    =
    pMLauf->pBlOldLastSpalte = NULL;

pstrPos = strchr(pstrPos, '\0') + 1;

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ			 MASK-HILFE-ZUORDNUNG				     บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
pstrTemp=strstr(pstrPos, "~SMH");
/*Wi_TestPrintf(pWkbInfo, "\npstrSMH=%s/%s.", pstrTemp, acHlpFile_g);*/

if(pstrTemp)
  {
  pstrPos=pstrTemp+4;
  if(!memcmp(pstrPos, "XX", 2))
    memcpy(pstrPos, pstrApp, 2);

  memcpy(acHlpFile_g, pstrPos, HLPFL); /* Default-Name der Hilfedatei 2x[F1] */
  pstrPos = strchr(pstrPos, '\0') + 1;
  memcpy(acHlpKey_g, pstrPos, HLPKEY); /* Default-Schlssel bei 2x[F1]	       */
  pstrPos = strchr(pstrPos, '\0') + 1;
  }

/*Wi_TestPrintf(pWkbInfo, "\n%s/%s.", acHlpFile_g,acHlpKey_g);*/

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ ฏฏฏ Ende der Informationszuordnung fr alle Bildschirmmasken !!!	     บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
   } /* end for (pwMasks[j]) */

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        SCHLIESSEN-BIBLIOTHEK                             บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
  wRetCode = BTRV (B_CLOSE, strFileBlock_m, strNull, &wNull, strNull, wNull);  /* -(i04)- */

  sprintf(strError,"M_BInit(B_CLOSE/%s), - "         /*                      */
    "Datei: %s", pstrFehler, pstrMaskenDatei, 0);    /*                      */

  Dl_ErrorHandler (wRetCode, strError,               /*                      */
    __FILE__, __LINE__, 0);                          /*                      */



*apstrText[j]=NULL;
apWkbMask[j]=NULL;
Ut_Free(pstrMaskKey_m);
Ut_Free(pstrMaskenDatei);

for (pMHelp = pMStart, j=0;                        /* Alle Masken der Reihe  */
     pMHelp; pMHelp = pMHelp->pNext, j++)          /* nach durchgehen, dort  */

  for (pBlHelp = pMHelp->pBlInitWurzel;            /* alle Bloecke durch-    */
       pBlHelp; pBlHelp = pBlHelp->pNext)          /* gehen und dann dort    */
    {
     for (pTBLHelp_m = pBlHelp->pTBLWurzel;	     /* alle TextBoxen durch-  */
	  pTBLHelp_m; pTBLHelp_m = pTBLHelp_m->pNext)	 /* gehen und dort berall */

       pTBLHelp_m->wRecord =			     /* die RecordNummer       */
	      awDateiNummer[j][pTBLHelp_m->wRecord]; /* aktualisieren.	       */

     if(pBlHelp->pTBLWurzel)			   /* ??? pm 19.3.91	     */
       pBlHelp->wBlockRecord =
                   pBlHelp->pTBLWurzel->wRecord;
     else  pBlHelp->wBlockRecord = 0;		   /* ??? pm 19.3.91	     */

     if (strcmp(pBlHelp->pstrBlockName, "(null)"))
       aboFixLength
            [pBlHelp->wBlockRecord] = JA;
    }

if (apstrDatei && awFixRecLen && awRecLen)
  for (j=0; apstrDatei[j]; j++)
    if (!aboFixLength[j])
      awFixRecLen[j] = awRecLen[j];

for(pMHelp=pMStart; pMHelp; pMHelp=pMHelp->pNext)  /* Alle Masken der Reihe  */
  if(!strcmp(pMHelp->pBlInitWurzel->pstrBlockName,"(null)"))  /* nach durch- */
    M_InsertFixBlock(pMHelp,"(null)",awFixRecLen); /* gehen und fixen Masken-*/
						   /* teil einfgen.	     */
wRetCode = 0;
if (apstrDatei)
 {
  for (i=0; apstrDatei[i]; i++)
     {
      CHAR strHelp[50];
      strcpy (strHelp, apstrDatei[i]);

      switch (acVerzeichnisName[i])
      {
      case 'D':                                      /* Daten-Verzeichnis    */
         stradd (apstrDatei[i], strDat_g, "D",
            strMan_g, "\\", strHelp, ".BTR", NULL);
         break;

      case 'L':                                      /* Daten-Lexikon        */
         stradd (apstrDatei[i], strDat_g,
            strHelp, ".BTR", NULL);
         break;

      case 'T':                                      /*Teilnehmer-Verzeichnis*/
         stradd (apstrDatei[i], strTeiln_g,
            strHelp, ".BTR", NULL);
         break;

      case 'X':                                      /* TXT-Verzeichnis       */
         stradd (apstrDatei[i], strTxt_g,
            strHelp, ".TXT", NULL);
         break;

      case 'E':                                      /* Exe-Verzeichnis      */
         stradd (apstrDatei[i], strExe_g,
            strHelp, ".", strExt_g, NULL);
         break;

      case 'S':
         stradd (apstrDatei[i], strExe_g,
            strHelp, ".BTR", NULL);
         break;

      default:                                      /*Fehler-Meldung bringen */
         sprintf (apstrDatei[i], "%c.%s",
            acVerzeichnisName[i], strHelp);
         wRetCode = 710;                             /* Falsche Verzeichnis- */
         break;                                      /* angabe (D,L,T etc.)  */
      } /* end switch */

      sprintf(strError,"M_BInit(%s), - Verzeichnis:" /*                      */
        " %s", pstrFehler, apstrDatei[i], 0);        /*                      */

      Dl_ErrorHandler (wRetCode, strError,           /*                      */
        __FILE__, __LINE__, 0);                      /*                      */


      if (apstrRecord)
        if (aboFixLength[i])
          {
	   Ut_Calloc(apstrRecord[i], MAX_RECORD_SIZE, CHAR);

	   if(apstrPosition)
	     Ut_Calloc(apstrPosition[i], INIT_POSITION_LENGTH, CHAR);
          }
        else
          {
	   Ut_Calloc(apstrRecord[i], awFixRecLen[i]+1, CHAR);
           apstrPosition[i] = NULL;
          }

      if (awPosLen)
        awPosLen[i] = 0;
     } /* end for */
} /* end if */


if (pwNbFile)
  *pwNbFile = i;

for (j=0; j<*pwNbFile; j++)
  awNbRecKeys[j] =
  awNbRefFields[j] =
  awNbRefCopies[j] =
  awNbMatchFields[j] = 0;


for (j=0, pMLauf=pMStart; pMLauf; j++, pMLauf=pMLauf->pNext)
  for (pInfoLauf_m=pRecInfo_m[j];
       pInfoLauf_m;
       pInfoLauf_m=pInfoLauf_m->pNext)
    {
     WORD wDatei=GetTextBox(pMLauf, pInfoLauf_m->wFeldNr)->wRecord;

     if (pInfoLauf_m->wArt == RECMATCH ||
         pInfoLauf_m->wArt == REFMATCH)
       {
        pInfoLauf_m->wDatei = awDateiNummer[j][pInfoLauf_m->wDatei];
        awNbMatchFields[wDatei]++;
       }
     else if (pInfoLauf_m->wArt == ADDMATCH)
       pInfoLauf_m->wDatei = awDateiNummer[j][pInfoLauf_m->wDatei];
     else if (pInfoLauf_m->wArt == RECKEY)
       awNbRecKeys[wDatei]++;
     else if (pInfoLauf_m->wArt == REFFIELD)
       if (GetTextBox (pMLauf, pInfoLauf_m->wFeldNr)->pRefField)
         awNbRefCopies[wDatei]++;            /* Copy */
       else
         awNbRefFields[wDatei]++;            /* No Copy */
    }

Ut_Calloc(aFileInfo, (*pwNbFile)+1, BFILEINFO);

for (i=0; i < *pwNbFile; i++)
  {
   if(awNbRefCopies[i])
     Ut_Calloc(aFileInfo[i].apRefFields, awNbRefCopies[i], PTEXTBOXINIT);
   else
     aFileInfo[i].apRefFields=NULL;

   if(awNbMatchFields[i])
     Ut_Calloc(aFileInfo[i].aMatch, awNbMatchFields[i], BMATCH);
   else
     aFileInfo[i].aMatch=NULL;

   if (awNbRecKeys[i])
     {
     Ut_Calloc(aFileInfo[i].apKeys, awNbRecKeys[i], PTEXTBOXINIT);
     Ut_Calloc(aFileInfo[i].awKeyOffset, awNbRecKeys[i], WORD);
     Ut_Calloc(aFileInfo[i].awKeyLength, awNbRecKeys[i], WORD);
     }
   else
     {
     aFileInfo[i].apKeys      = NULL;
     aFileInfo[i].awKeyOffset = NULL;
     aFileInfo[i].awKeyLength = NULL;
     }

   aFileInfo[i].wNbRefFields   = awNbRefCopies[i];
   aFileInfo[i].wNbRefLooks    = awNbRefFields[i];
   aFileInfo[i].wNbMatchFields = awNbMatchFields[i];
   aFileInfo[i].wNbKeyFields   = awNbRecKeys[i];

   awNbRefCopies[i]   = 0;
   awNbMatchFields[i] = 0;
   awNbRecKeys[i]     = 0;
  }

for (j=0, pMLauf=pMStart; pMLauf; j++, pMLauf=pMLauf->pNext)
  for (pInfoLauf_m=pRecInfo_m[j],
       pLastMatch=NULL;
       pInfoLauf_m;
       pInfoLauf_m=pInfoLauf_m->pNext)
    {
     WORD wRec=GetTextBox (pMLauf, pInfoLauf_m->wFeldNr)->wRecord;

     switch (pInfoLauf_m->wArt)
       {
        case RECMATCH:
        case REFMATCH:
          {
           WORD wDatei = pInfoLauf_m->wDatei, wI2, wLaufNb;
           REC_INFO_MC *pLauf;

           aFileInfo[wRec].aMatch
               [awNbMatchFields[wRec]].pMatchField =
                 GetTextBox(pMLauf, pInfoLauf_m->wFeldNr);

           aFileInfo[wRec].aMatch
               [awNbMatchFields[wRec]].pstrFieldName =
                 pInfoLauf_m->pstrTxt;

           aFileInfo[wRec].aMatch
               [awNbMatchFields[wRec]].wNbAddFields = 0;

           for (pMHelp = pMStart;
                pMHelp; pMHelp=pMHelp->pNext)
             for (wI2=0; GetTextBox (pMHelp, wI2); wI2++)
               if (GetTextBox(pMHelp, wI2)->wRecord == wDatei &&
                   !strcmp(GetTextBox(pMHelp, wI2)->strDatenfeld,
                           pInfoLauf_m->strDatenfeld))
                 goto ENDE_MATCH;

       ENDE_MATCH:
           for (pLauf=pInfoLauf_m, wLaufNb=0;
                pLauf; pLauf=pLauf->pNext)
             if (pLauf->wArt == ADDMATCH &&
                 pLauf->wFeldNr == pInfoLauf_m->wFeldNr)
               wLaufNb++;

           pLastMatch = &aFileInfo[wRec].
                aMatch[awNbMatchFields[wRec]];

           pLastMatch->wNbAddFields = 0;

           if (wLaufNb)
             {
	      Ut_Calloc(pLastMatch->apAddField, wLaufNb, PTEXTBOXINIT);
	      Ut_Calloc(pLastMatch->apstrAddName, wLaufNb, PSTR);
             }
           else
             {
              pLastMatch->apAddField = NULL;
              pLastMatch->apstrAddName = NULL;
             }

           aFileInfo[wRec].aMatch
               [awNbMatchFields[wRec]].ppKey =
                        (VOID*) GetTextBox(pMHelp, wI2);

           awNbMatchFields[wRec]++;
          }
          break;

        case ADDMATCH:
          if (!pLastMatch)
            break;
          else
            {
             PSTR pstrFeld = pInfoLauf_m->strDatenfeld;
             WORD wDatei = pInfoLauf_m->wDatei,
                  wNb = pLastMatch->wNbAddFields,
                  wI2;

             pLastMatch->apstrAddName[wNb] = pInfoLauf_m->pstrTxt;

             for (pMHelp=pMStart;
                  pMHelp; pMHelp=pMHelp->pNext)
               for (wI2=0; GetTextBox(pMHelp, wI2); wI2++)
                 if (GetTextBox(pMHelp, wI2)->wRecord == wDatei &&
                     !strcmp(GetTextBox(pMHelp, wI2)->strDatenfeld,
                             pstrFeld))
                   goto ENDE_ADD;

         ENDE_ADD:
             pLastMatch->apAddField[wNb] = GetTextBox(pMHelp, wI2);

             pLastMatch->wNbAddFields++;
            }
          break;

        case RECKEY:
          {
           WORD wNb = awNbRecKeys[wRec];

           aFileInfo[wRec].apKeys[wNb] =
                  GetTextBox (pMLauf, pInfoLauf_m->wFeldNr);

           aFileInfo[wRec].awKeyOffset[wNb] =
                  GetTextBox (pMLauf, pInfoLauf_m->wFeldNr)->wOffset;

           aFileInfo[wRec].awKeyLength[wNb] =
                  GetTextBox (pMLauf, pInfoLauf_m->wFeldNr)->wMaxL;

           awNbRecKeys[wRec]++;
          }
          break;

        case REFFIELD:
          if (GetTextBox (pMLauf, pInfoLauf_m->wFeldNr)->pRefField)
            {
             WORD wNb = awNbRefCopies[wRec];

             aFileInfo[wRec].apRefFields[wNb] =
                    GetTextBox(pMLauf, pInfoLauf_m->wFeldNr);

             awNbRefCopies[wRec]++;
            }
          break;

        default:
          break;
       }
    }

for(j=0, pMLauf=pMStart; pMLauf; j++, pMLauf=pMLauf->pNext)
  for(pInfoLauf_m=pRecInfo_m[j]; pInfoLauf_m;
    pInfoLauf_m=pInfoLauf_m->pNext)
    {
    REC_INFO_MC *p=pInfoLauf_m;
    Ut_Free(p);
    }

for(i=0; i < *pwNbFile; i++)
  for(j=0; j<aFileInfo[i].wNbMatchFields; j++)
    for(l=0; l < *pwNbFile; l++)
      for(k=0; k<aFileInfo[l].wNbKeyFields; k++)
        if ((VOID*)aFileInfo[l].apKeys[k] ==
            (VOID*)aFileInfo[i].aMatch[j].ppKey)
          {
	  aFileInfo[i].aMatch[j].ppKey = &aFileInfo[l].apKeys[k];
	  l=*pwNbFile;
	  if(aFileInfo+l)			    /* ??? pm 19.3.91 neu */
	    k=aFileInfo[l].wNbKeyFields;  /* org. Zeile */
          }

*aFiles = aFileInfo;
*ppMasks = pMStart;

Dl_Nachricht( NULL, 32, 12);                         /* Nachricht lschen    */

/*Wi_Entfernen (pWkbInfo);			       /* WindowKontollBlock   */
/*pWkbInfo=NULL;*/
return (wRetCode);
}  /* end M_BInit */


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    GetTextBox                                            บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
PTEXTBOXINIT GetTextBox (PMASKS pMask, WORD wNb)
{
STATIC PMASKS pMaskAlt;
STATIC WORD   wNbAlt;
STATIC PTEXTBOXINIT pTBLHelpAlt;

PINITBLOCKS pBlHelp;
PTEXTBOXINIT pTBLHelp;


if (pMask==pMaskAlt &&
    wNb==wNbAlt)
  pTBLHelp = pTBLHelpAlt;
else
  for (pBlHelp = pMask->pBlInitWurzel;            /* alle Bloecke durch-    */
       pBlHelp; pBlHelp = pBlHelp->pNext)          /* gehen und dann dort    */
    {
    for (pTBLHelp = pBlHelp->pTBLWurzel;          /* alle TextBoxen durch-  */
         pTBLHelp; pTBLHelp = pTBLHelp->pNext)    /* gehen und dort berall */
       {
       if (pTBLHelp->wModus == wNb)
         goto ENDE_GETTEXTBOX;
       }
    }

ENDE_GETTEXTBOX:

pTBLHelpAlt = pTBLHelp;
wNbAlt = wNb;
pMaskAlt = pMask;

return (pTBLHelp);
}

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    SetTextBox                                            บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
PTEXTBOXINIT SetTextBox(PTEXTBOXINIT pT, WORD wAttri, WORD wFensterS,
   WORD wFensterZ, WORD wFensterB, WORD wCursorS, WORD wMaxL, BOOL boInsert,
   WORD wSequenz, WORD wModus, WORD wRecord, WORD wOffset)
{
Ut_Calloc(pT, 1, TEXTBOXINIT);

pT->wTBLSignatur = TBLSIGNATUR;
pT->wAttri    = wAttri; 		    /* Initialisieren		*/
pT->wFensterS = wFensterS;
pT->wFensterZ = wFensterZ;
pT->wFensterB = wFensterB;
pT->wCursorS  = wCursorS;
pT->wMaxL     = wMaxL;
pT->boInsert  = boInsert;
pT->wSequenz  = wSequenz;
pT->wModus    = wModus;
pT->wRecord   = wRecord;
pT->wOffset   = wOffset;

return (pT);
}



/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_BCloseInit()                                        บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD M_BCloseInit(PWKB   apWkbMask[],   PSTR apstrMaskText[][25],
                  PMASKS pMasks,        PSTR apstrFileName[],
                  PSTR   apstrRecord[], PSTR apstrPosition[])
{
REGISTER i, j;
PBLOCKCOLUMN pC1;
PBLOCKLINE   pL1;
PBLOCKS      pB1;
PINITBLOCKS  pB2;
PTEXTBOXINIT pF2;
WORD  wMaxMask;
PMASKS pM1;
PTEXTBOXLIST pF1;


for (i=0; apWkbMask[i]; i++)                         /* jetzt noch die ver-  */
    {                                                /* steckten Windows ent-*/
    Wi_Entfernen(apWkbMask[i]);                      /* fernen               */
    apWkbMask[i]=NULL;
    wMaxMask = i+1;
    }

for(i=0; i < wMaxMask; i++)
  for(j=0; apstrMaskText[i][j] != NULL; j++)
    Ut_Free(apstrMaskText[i][j]);

for(pM1=pMasks; pM1; pM1=pM1->pNext)
 {
 for (pC1 = pM1->pBlColumnWurzel; pC1; pC1=pC1->pNext)
   {
    for (pB1 = pC1->pBlWurzel; pB1; pB1=pB1->pNextLine)
     {
      for(pF1 = pB1->pTBLWurzel; pF1; pF1=pF1->pNext)
       {
       if (pF1->pRefField)
         {
	 free (pF1->pRefField->pstrText);  /*	  ~~ ??? Fehler ~~ */
	 free (pF1->pRefField);
         }

       free(pF1->pstrText);
       free(pF1);
       }

     free(pB1);       /*			 ~~ ??? Fehler ~~ */
     }

    free(pC1);
   }


  for (pL1 = pM1->pBlLineWurzel; pL1; pL1=pL1->pNext)	/*  ~~ ??? Fehler ~~ */
   free (pL1);

  for (pB2 = pM1->pBlInitWurzel; pB2; pB2=pB2->pNext)
   {
    for (pF2 = pB2->pTBLWurzel; pF2; pF2=pF2->pNext)
     {
     if(pF2->pRefField)
       i_DeleteTextBox(pF2->pRefField);

     i_DeleteTextBox(pF2);
     }

    free(pB2->pstrBlockName);
    free(pB2);
   }

  free(pM1);
 }


for(i=0; apstrFileName[i]; i++)
    Ut_Free(apstrFileName[i]);

for(i=0; apstrRecord[i]; i++)
    Ut_Free(apstrRecord[i]);

for(i=0; apstrPosition[i]; i++)
    Ut_Free(apstrPosition[i]);

if (wVioMode_g == MONOCHROM)
   Wi_SetCursorTyp(11,12);                           /* Linien-Cursor         */
else
   Wi_SetCursorTyp(6,7);
Wi_Cursor(EIN);

return (OK);
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_CheckRef                          Datum: 2.3.1990   บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  บ                                                                          บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
PTEXTBOXINIT i_CheckRef (PMASKS pM, PTEXTBOXINIT pTBL)
{
 PTEXTBOXINIT pTBLHelp;
 PINITBLOCKS  pBlLauf;

 for (pBlLauf = pM->pBlInitWurzel;
      pBlLauf &&
      strcmp (pBlLauf->pstrBlockName, acBlockName_m);
      pBlLauf = pBlLauf->pNext)
    ;

 if (!pBlLauf)
   {
    printf ("\n\n\nFalscher Blockname in Ref-Feld !!!\n\n\n\a\a");
    E(); exit (-1);
   }

 for (pTBLHelp=pBlLauf->pTBLWurzel;
      pTBLHelp &&
      pTBLHelp->wModus != pTBL->swRefCode;
      pTBLHelp=pTBLHelp->pNext)
    ;

 if (!pTBLHelp ||
     pTBLHelp->swRefCode != pTBL->wModus)
   {
    printf ("\n\n\nFalscher Ref-Code in Ref-Feld !!!\n\n\n\a\a");
    printf ("\npTBLHelp = %p,\npTBL : wModus=%d, swRefCode=%d,\n"
			      "pTBLHelp : wModus=%d, swRefCode=%d\n"
                              "pTBLHelp=%s, pTBL=%s\n\n",
	       pTBLHelp, pTBL->wModus, pTBL->swRefCode,
	       pTBLHelp->wModus, pTBLHelp->swRefCode,
               pTBLHelp->strDatenfeld, pTBL->strDatenfeld);

    E(); exit (-1);
   }

 pTBLHelp->pRefField = pTBL;
 pTBL->pRefField = pTBLHelp;
 pTBL->pNext = NULL;

return(NULL);
}



/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_InsertTextBox                Datum: 17.11.1989      บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
PTEXTBOXINIT i_InsertTextBox (PMASKS pM, PTEXTBOXINIT pTBL)
{
PTEXTBOXINIT pTBLHelp;
PINITBLOCKS  pBlLauf;
PINITBLOCKS  pBlHelp=NULL;

for(pBlLauf = pM->pBlInitWurzel; pBlLauf &&
  strcmp (pBlLauf->pstrBlockName, acBlockName_m) < 0;
  pBlLauf = pBlLauf->pNext)
  ;

 if (!pBlLauf || strcmp(pBlLauf->pstrBlockName, acBlockName_m))
   {
    if (!pBlLauf)
      for (pBlLauf = pM->pBlInitWurzel; pBlLauf->pNext;
          pBlLauf = pBlLauf->pNext)
         ;
    else
      for (pBlLauf = pM->pBlInitWurzel;
           strcmp(pBlLauf->pNext->pstrBlockName, acBlockName_m) < 0;
           pBlLauf = pBlLauf->pNext)
         ;

    Ut_Calloc(pBlHelp, 1, INITBLOCKS);
    pBlHelp->wBlSignatur = BLOCKSIGNATUR;

    Ut_Calloc(pBlHelp->pstrBlockName, strlen(acBlockName_m)+1, CHAR);
    strcpy (pBlHelp->pstrBlockName, acBlockName_m);
    pBlHelp->wBlockHoehe = wBlockH_m;
    pBlHelp->wBlockBreite = wBlockB_m;
    pBlHelp->wBlockOffset = wBlockO_m;
    pBlHelp->wBlockLength = wBlockL_m;

    pBlHelp->pTBLWurzel = NULL;

    pBlHelp->pNext = pBlLauf->pNext;
    pBlLauf->pNext = pBlHelp;

    pBlLauf = pBlHelp;
   }

 if (pBlLauf->pTBLWurzel)
   {
    for (pTBLHelp = pBlLauf->pTBLWurzel;
         pTBLHelp->pNext; pTBLHelp = pTBLHelp->pNext)
       ;

    pTBL->pNext = NULL;
    pTBLHelp->pNext = pTBL;
   }
 else
   {
    pTBL->pNext = NULL;
    pBlLauf->pTBLWurzel = pTBL;
   }

return(NULL);
}



/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_DeleteTextBox                Datum: 17.11.1989      บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
PTEXTBOXINIT i_DeleteTextBox(PTEXTBOXINIT pTBL)
{
CHOICES *pSelect;
CHOICES *pChoice;
FELDINFO *pInfo;

if(pTBL==NULL) return(pTBL);	 /* ~ */

for(pInfo=pTBL->pFeld;	 pInfo; pInfo=pInfo->pNext)
  free(pInfo);

for(pChoice=pTBL->pChoice; pChoice; pChoice=pChoice->pNext)
  free(pChoice);

for(pSelect=pTBL->pSelect; pSelect; pSelect=pSelect->pNext)
  free(pSelect);

return(Ut_Free(pTBL));
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_SetFirstField                Datum: 18.12.1989      บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_SetFirstField (PMASKS pMask, WORD wFieldNb)
{

 /* Fr spteren Ausbau bestimmt !!! */
 pMask;
 wFieldNb;

 return;
}


/*
sprintf (pstrDataBuffer_g, "%sMASK", pstrApp);
strupr (strrev (pstrDataBuffer_g));
for (j=0; j < strlen(pstrDataBuffer_g); j++)
  if (j%2)
    pstrDataBuffer_g[j] = (CHAR) tolower(pstrDataBuffer_g[j]);
*/
