/*.ta M_Init()
ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
บ  M_Init()                                                                    บ
ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ

berblick:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
#include <eur_tool.h>
WORD M_Init (pstrApp, apWkbMask[], apstrText[][25], pTextBox[][99],
             pwMasks, pwFirstFieldNumber, awBlocks[][2],
	     awScroll[][4], pwNbFile, ppstrDatei, ppstrRecord,
             awInitRecLen[], awRecLen[], pstrFehler)

Parameter:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
PSTR     pstrApp              Zeiger auf das Applikationskennzeichen.
PWKB     apWkbMask[]          Array von Zeigern auf die Maskenattribute.
PSTR     apstrText[][25]      Array von Zeigern auf den Maskentext.
PTEXTBOX pTextBox[][99]       Zeiger auf Array mit den Textboxen.
PWORD    pwMasks,             Zeiger auf Array mit den Maskennummern.
PWORD    pwFirstFieldNumber   Zeiger auf Array mit der ersten Feldnummer
                              jeder Maske.
WORD     awBlocks[][2]        Array mit der Information ber Blocktyp 1.
WORD     awScroll[][4]        Array mit der Scrollinformation fr Blocktyp 1.
PWORD    pwNbFile             Zeiger auf die Anzahl der verwendeten Dateien.
PPSTR	 ppstrDatei	      Array von Zeigern auf die Dateinamen.
PPSTR	 ppstrRecord	      Array von Zeigern auf die Dateibuffer.
WORD     awInitRecLen[]       Array mit den min. Datensatzlngen.
WORD     awRecLen[]           Array mit den akt. Datensatzlngen.
PSTR     pstrFehler           Zeiger auf die Fehlerinformation.


Beschreibung:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
Meldet alle angegebenen Maskennummern aus der Bibliothek , die durch
das in ฏpstrAppฎ bergebene Applikationskennzeichen festgelegt ist, an.
Die Masken knnen erst danach aufgerufen werden.
M_Init () speichert in der ฏTextboxฎ-Struktur alle fr den Interpreter
wichtigen Informationen ab, damit dieser Sie nicht mehr aus der Bibliothek
lesen muแ.
Aus diesem Grund mssen alle Masken, die im Programm(teil) verwendet werden
sollen, zuvor einmal angemeldet werden. Es ist ein wiederholten Aufruf
von M_Init () im gleichen Programm(teil) mglich.
Es ist mglich, die Masken bereits vor Start des nutzenden Programmes von
einem Initialisierungs- oder Menu-Programm anzumelden.
Ferner werden durch M_Init () auch allgemeine Initialisierungen vorgenommen
die direkt mit den Masken nichts zu tun haben. Durch einen Aufruf von
M_Init wird den zu den Masken gehrigen Dateibuffern Speicherplatz
zugewiesen und die Grแe der aufrufenden Funktion mitgeteilt.
Da diese Variablen in fast allen Tool-Routinen bentigt wird, ist es ratsam
M_Init () als eine der ersten Routinen berhaupt aufzurufen.


Versorgung:

   Eingang:
      pstrApp:      Ein im allg. zweistelliges Applikationskennzeichen, das
                    zur Identifikation der Maskenbibliothek dient.
      pwMasks:      Ein Zeiger auf ein Array mit den zu initialisierenden
                    Maskennummern aus der Bibliothek.
      pstrFehler:   Zeiger auf die Fehlerinformation, die beim Auftreten
                    eines Fehlers oder beim Programmablauf im Testmodus
                    im Fehlerfenster zustzlich angezeigt werden soll.
                    Sie dient zur eindeutigen Feststellung des Ortes
                    im Programm, an dem der Fehler aufgetreten ist.

   Ausgang:
      apWkbMask:    Ein Array von Zeigern auf sog. ฏWindowkontrollblckeฎ.
                    Diese werden vom internen Windowmanager bentigt.
      apstrText:    Ein Array von Zeigern auf den auszugebenden Maskentext.
      pTextBox:     Ein Array von Zeigern auf die ฏTextboxฎ-Struktur,die
                    alle fr den Interpreter wichtigen Informationen enthlt.
      pwFirstFieldNumber : Ein Zeiger auf ein Array mit der ersten
                    anzuspringenden Feldnummer jeder Maske.
      awBlocks:     Ein Array mit den Blockinformationen zum Blocktyp 1.
      awScroll:     Ein Array mit der Scrollinformation zum Blocktyp 1.
      pwNbFile:     Ein Zeiger auf die Anzahl der initialisierten Dateibuffer.
      ppstrDatei:   Ein Array von Zeigern auf die zu ffnenden Dateinamen.
      ppstrRecord:  Ein Array von Zeigern auf die fr die internen Dateibuffer
                    reservierten Speicherbereiche.
      awInitRecLen: Ein Array mit den minimalen Grแen der Dateibuffer.
      awRecLen:     Ein Array mit den aktuellen Grแen der Dateibuffer.
                    Diese Werte sind naturgemแ beim Verlassen der Funktion
                    M_Init () gleich der im Array awInitRecLen.


Rckgabewert:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
WORD  Fehlerinformation OK/ERROR


Benutzte globale Variablen (R/W):
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
Variablen (R/W):  - aCS_g[]    (R)           - boTestModus_g (R)
                  - wCSInd_g   (R)           - strExe_g      (R)
                  - strDat_g   (R)           - strExt_g      (R)
                  - strMan_g   (R)
.ff
REM .de \euro\demo\dmohilf1.c
.te*/

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                         DEKLARATIONS-DATEIEN                             บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
#define NDEBUG 1                                       /* Checks ausschalten  */
#include <stdio.h>
#include <string.h>
#include <process.h>                                   /*  fuer execl()       */
#include <eur_tool.h>

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ              GLOBALE VARIABLEN, DEFINITION UND REFERENZEN                บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
IMPORT PSTR  apstrRecord_g[];          /* Inhalt des Datei-Records           */

IMPORT COLORSET aCS_g[];
IMPORT WORD     wCSInd_g;
IMPORT WORD     wVioMode_g;
IMPORT CHAR     strExe_g[];                          /* ฏEXEฎ Verzeichnis    */
IMPORT CHAR     strHlp_g[];                          /* ฏHLPฎ Verzeichnis    */
IMPORT CHAR     strExt_g[];                          /* Lnderextension      */
IMPORT CHAR     strApp_g[];                          /* Fr Create / Db_Open */
IMPORT CHAR     strTxt_g[];                          /* TextVerzeichnis      */
IMPORT CHAR     strDat_g[];                          /* Datenverzeichnis     */
IMPORT CHAR     strZug_g[];                          /* ฏKHKฎ Verzeichnis    */
IMPORT CHAR     strTeiln_g[];                        /* Teilnehmerverzeichn. */
IMPORT CHAR     strMan_g[];                          /* Mandantennummer      */
IMPORT PSTR     pstrDataBuffer_g;
IMPORT CHAR     acHlpFile_g[];              /* Name der Hilfedatei / _MSK 0 */
IMPORT CHAR     acHlpKey_g[];               /* Hilfstext-Schlssel / 2x[F1] */
IMPORT PEVENT   pEvent_g;                   /* Fr Menu_Handler()           */
IMPORT BOOL     boTestModus_g;              /* -"-                          */
IMPORT PWKB	pWkbInfo_g;
IMPORT	ERRINFO errInfo_g;
IMPORT WORD	wEcoYear_g;
IMPORT LONG	lBlockVer_g;			     /* 0==Kein Block	     */
						     /* BLOCK	 1==&BLOCK   */
						     /* BROWSE	 2==&BROWSE  */
						     /* BLK_TYP2 4==mbc.exe  */

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        MODULGLOBALE FUNKTIONEN                           บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC VOID iM_Init(WORD, WORD[][20], CHAR[], PSTR, PWKB[],
	      PSTR[][25], PSTR[][25], PTEXTBOX[][99], PWORD,
	      PWORD, WORD[][2], WORD[][4], PPSTR[],
	      PWORD, WORD[], PPSTR, PSTR);

STATIC PTEXTBOX SetTextBox(PTEXTBOX, WORD, WORD, WORD, WORD,
                       WORD, WORD, BOOL, WORD, WORD, WORD, WORD);


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        MODULGLOBALE VARIABLEN                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
#define RECMATCH   1
#define REFMATCH   2
#define ADDMATCH   4
#define RECKEY     8
#define REFFIELD  16
#define COPYFIELD 32

typedef struct tagFLAG
  {
   WORD wFeldNr;
   WORD wArt;
   PSTR pstrTxt;
   WORD wDatei;
   CHAR strDatenfeld[11];
   struct tagFLAG *pNext;
  } REC_INFO_MC;

REC_INFO_MC *apRecInfo_m[20], *pInfoLauf_m, *pRecInfo;

STATIC CHAR strFileBlock_m[128];                            /* Fileblock fr Btrieve */
STATIC PSTR pstrMaskKey_m;

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                          FUNKTIONS-DEFINITION                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
WORD M_Init  (PSTR pstrApp,  PWKB apWkbMask[], PSTR apstrText[][25],
  PSTR apstrBrowseText[][25], PTEXTBOX pTextBox[][99], PWORD pwMasks,
  PFILEINFO pFiles, PWORD pwFirstFieldNumber, WORD awBlocks[][2],
  WORD awScroll[][4], PWORD pwNbFile, PPSTR ppstrDatei,
  PPSTR appstrRecord[], WORD awInitRecLen[], WORD awRecLen[],
  WORD awFileMode[], PPSTR ppstrIndexKey, PSTR pstrFehler)
{
WORD i, j, k, l, wNull=0;
WORD wRetCode, wBufferLength;
PSTR pstrMaskenDatei=NULL;
CHAR strError[TB_MAX], strNull[TB_MAX];
CHAR acVerzeichnisName[20];
WORD awDateiNummer[20][20];    /* Die Indices der Arrays gelten unter der An- */
                               /* nahme, daแ max. 20 Masken und 20 Dateien    */
                               /* gleichen Zeit bentigt werden. Der erste    */
                               /* Index steht fr die Anzahl der Masken, der  */
                               /* zweite fr die Anzahl der Dateien.          */

WORD awNbRecKeys[20];
WORD awNbRefFields[20];
WORD awNbRefCopies[20];
WORD awNbMatchFields[20];

MATCH *pLastMatch=NULL;
strncpy(strApp_g, pstrApp, 3);                       /* Fr Create / Db_Open */

*ppstrIndexKey=NULL;
Ut_Calloc(pstrMaskKey_m, 20, CHAR);	     /* Reservieren von 20 Zeichen    */
                                             /* fr den Schlssel der Maske   */
                                             /* in der Bibliothek .           */

Ut_Calloc(pstrMaskenDatei, TB_MAX, CHAR);    /* Maskendateiname, max. 128     */
                                             /* Zeichen.                      */

/*printf("\n\nIn M_Init_2 / _msize(%u), pstr(%u).",
  _msize(pstrMaskenDatei), pstrMaskenDatei);*/

memcpy(acHlpFile_g, "SYHLP10", HLPFL); /* Default-Name der Hilfedatei 2x[F1] */
memcpy(acHlpKey_g, "blank", HLPKEY);   /* Default-Schlssel bei 2x[F1]       */

sprintf(pstrMaskenDatei, "%s%s%s%s", strExe_g,      /* Maskendatei aus glo-  */
  pstrApp, "MASK.", strExt_g);                      /* balen Variablen bilden*/

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                         FFNEN-BIBLIOTHEK                                บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
    strcpy(pstrDataBuffer_g, "(c)Mayer");
    wBufferLength=strlen(pstrDataBuffer_g)+1;
    wRetCode=BTRV (B_OPEN, strFileBlock_m, pstrDataBuffer_g,
      &wBufferLength, pstrMaskenDatei, O_NORMAL);

    sprintf(strError,"M_Init(B_OPEN/%s), - "         /*                      */
      "Datei: %s", pstrFehler, pstrMaskenDatei);

    Dl_ErrorHandler(wRetCode, strError, _F, _L, 0);  /* 		     */

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ ฏฏฏ Start der Informationszuordnung fr alle Bildschirmmasken !!!        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
for(j=0; *(pwMasks+j); j++)
  iM_Init(j, awDateiNummer, acVerzeichnisName,
    pstrApp, apWkbMask, apstrText, apstrBrowseText,
    pTextBox, pwMasks, pwFirstFieldNumber,
    awBlocks, awScroll, &ppstrDatei,
    awRecLen, awFileMode, ppstrIndexKey, pstrFehler);

    {BOOL boTest=boTestModus_g; boTestModus_g=JA;
    Wi_TestPrintf(pWkbInfo_g, "\n<0>(%d) <1>(%d)", awRecLen[0], awRecLen[1]);
    boTestModus_g=boTest;}

*apstrText[j]=NULL; *apstrBrowseText[j]=NULL;
*pTextBox[j]=NULL;  apWkbMask[j]=NULL;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        SCHLIESSEN-BIBLIOTHEK                             บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
wRetCode=BTRV(B_CLOSE, strFileBlock_m, strNull,
  &wNull, strNull, wNull);                           /* -(i04)- */
  sprintf(strError,"M_Init(B_CLOSE/%s), - "          /*                      */
    "Datei: %s", pstrFehler, pstrMaskenDatei);	     /* 		     */

  Dl_ErrorHandler(wRetCode, strError, _F, _L, 0);    /* 		     */

Ut_Free(pstrMaskKey_m);
Ut_Free(pstrMaskenDatei);

wRetCode = 0;
if(ppstrDatei)
  {
  WORD wYear, wY;					  /* Wirtschaftsjahr */
  D_DATE *pD=NULL;
  pD=D_get_date(pD);
  wYear=atoi(str("%d%#02d", pD->cMonat, pD->cTag));
  wY=(wYear<wEcoYear_g) ? 1 : 0;

  for(i=0; *(ppstrDatei+i); i++)
    {
    CHAR strHelp[TB_MAX];
    strcpy(strHelp, *(ppstrDatei+i) );

    switch(acVerzeichnisName[i])
      {
      case '5': 				     /* Daten vor 5 Jahren   */
	 sprintf(*(ppstrDatei+i), "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-5-wY, strHelp);
         break;

      case '4': 				     /* Daten vor 4 Jahren   */
	 sprintf(*(ppstrDatei+i), "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-4-wY, strHelp);
         break;

      case '3': 				     /* Daten vor 3 Jahren   */
	 sprintf(*(ppstrDatei+i), "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-3-wY, strHelp);
         break;

      case '2': 				     /* Daten vor 2 Jahren   */
	 sprintf(*(ppstrDatei+i), "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-2-wY, strHelp);
         break;

      case 'V': 				     /* Daten-Vohrjahr	     */
	 sprintf(*(ppstrDatei+i), "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-1-wY, strHelp);
         break;

      case 'D':                                      /* Daten-Verzeichnis    */
	 sprintf(*(ppstrDatei+i), "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-wY, strHelp);
	 break;

      case 'N': 				     /* Daten-Verzeichnis    */
	 sprintf(*(ppstrDatei+i), "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr+1-wY, strHelp);
         break;

      case 'L':                                      /* Daten-Lexikon        */
	 stradd (*(ppstrDatei+i), strDat_g,
            strHelp, ".BTR", NULL);
         break;

      case 'T':                                      /*Teilnehmer-Verzeichnis*/
	 stradd (*(ppstrDatei+i), strTeiln_g,
            strHelp, ".BTR", NULL);
         break;

      case 'X':                                      /* TXT-Verzeichnis       */
	 stradd (*(ppstrDatei+i), strTxt_g,
            strHelp, ".TXT", NULL);
         break;

      case 'E':                                      /* Exe-Verzeichnis      */
	 stradd (*(ppstrDatei+i), strExe_g,	       /* mit Lnderextension  */
            strHelp, ".", strExt_g, NULL);
         break;

      case 'H':                                      /* Hlp-Verzeichnis      */
	 stradd (*(ppstrDatei+i), strHlp_g,
            strHelp, ".", strExt_g, NULL);
         break;

      case 'S':                                      /* Exe-Verzeichnis      */
	 stradd (*(ppstrDatei+i), strExe_g,	       /* mit BTR-Extension    */
            strHelp, ".BTR", NULL);                  /* == Systemfile        */
         break;

      case 'Z':                                      /* KHK-Verzeichnis etc. */
	 stradd (*(ppstrDatei+i), strZug_g,	       /* mit BTR-Extension    */
            strHelp, ".BTR", NULL);                  /* == Zugangsfile       */

         if(*strHelp=='M')                           /* Wenn der Dateiname   */
	   {stradd(*(ppstrDatei+i), strZug_g,	       /* M beginnt, dann tau- */
           &strMan_g[1],&strHelp[1],".BTR",NULL);}   /* sche mit Mandanten-Nr*/
         break;

      default:                                      /*Fehler-Meldung bringen */
	 sprintf(*(ppstrDatei+i), "%c.%s",
            acVerzeichnisName[i], strHelp);
         wRetCode = 710;                             /* Falsche Verzeichnis- */
         break;                                      /* angabe (D,L,T etc.)  */
      } /* end switch */

      sprintf(strError,"M_Init(%s), - Verzeichnis:"  /*                      */
	" %s", pstrFehler, *(ppstrDatei+i) );		/*			*/

      /*{BOOL boTest=boTestModus_g; boTestModus_g=JA;
	Wi_TestPrintf(pWkbInfo_g,"\nppstrDatei[%d]=%s", i, *(ppstrDatei+i) );
	boTestModus_g=boTest;}*/

      Dl_ErrorHandler(wRetCode, strError, _F, _L, 0);/* 		     */

      /* if (awInitRecLen) */
        awInitRecLen[i] = awRecLen[i];

	{BOOL boTest=boTestModus_g; boTestModus_g=JA;
	Wi_TestPrintf(pWkbInfo_g, "\n<%d>(%d/%d)=%s", i, awRecLen[i],
	  _msize(apstrRecord_g[i]), *(ppstrDatei+i) );
	  /* _msize(*appstrRecord[i], *(ppstrDatei+i) ); */
	boTestModus_g=boTest;}

      /* if(*appstrRecord) */
	Ut_Calloc(apstrRecord_g[i], awRecLen[i], CHAR);
	/* Ut_Calloc( *appstrRecord[i], awRecLen[i], CHAR); */

     } /* end for */

  Ut_Free(pD);
  } /* end if */

*pwNbFile = i;

for(j=0; *pTextBox[j]; j++)
  for(i=0; pTextBox[j][i]; i++)
    pTextBox[j][i]->wRecord = awDateiNummer[j][pTextBox[j][i]->wRecord];

for (j=0; j<(WORD)*pwNbFile; j++)
  awNbRecKeys[j] =
  awNbRefFields[j] =
  awNbRefCopies[j] =
  awNbMatchFields[j] = 0;


for(j=0; *pTextBox[j]; j++)
  {
  for(pInfoLauf_m=apRecInfo_m[j]; pInfoLauf_m;
    pInfoLauf_m=pInfoLauf_m->pNext)
    {
    WORD wDatei=pTextBox[j][pInfoLauf_m->wFeldNr]->wRecord;

     if (pInfoLauf_m->wArt == RECMATCH ||
         pInfoLauf_m->wArt == REFMATCH)
       {
        pInfoLauf_m->wDatei = awDateiNummer[j][pInfoLauf_m->wDatei];
        awNbMatchFields[wDatei]++;
       }
     else if (pInfoLauf_m->wArt == ADDMATCH)
       pInfoLauf_m->wDatei = awDateiNummer[j][pInfoLauf_m->wDatei];
     else if (pInfoLauf_m->wArt == RECKEY)
       awNbRecKeys[wDatei]++;
     else if (pInfoLauf_m->wArt == COPYFIELD)
       awNbRefCopies[wDatei]++;              /* Copy */
     else if (pInfoLauf_m->wArt == REFFIELD)
       if (pTextBox[j][pInfoLauf_m->wFeldNr]->pRefField)
         awNbRefCopies[wDatei]++;            /* Copy */
       else
         awNbRefFields[wDatei]++;            /* No Copy */
    }
  }


for (i=0; i < (WORD)*pwNbFile; i++)
  {
   if(awNbRefCopies[i])
     Ut_Calloc(pFiles[i].apRefFields, awNbRefCopies[i], PTEXTBOX);

   if(awNbMatchFields[i])
     Ut_Calloc(pFiles[i].aMatch, awNbMatchFields[i], MATCH);

   if(awNbRecKeys[i])
     Ut_Calloc(pFiles[i].apKeys, awNbRecKeys[i], PTEXTBOX);

   if(awNbRecKeys[i])
     Ut_Calloc(pFiles[i].awKeyOffset, awNbRecKeys[i], WORD);

   if(awNbRecKeys[i])
     Ut_Calloc(pFiles[i].awKeyLength, awNbRecKeys[i], WORD);

   pFiles[i].wNbRefFields   = awNbRefCopies[i];
   pFiles[i].wNbRefLooks    = awNbRefFields[i];
   pFiles[i].wNbMatchFields = awNbMatchFields[i];
   pFiles[i].wNbKeyFields   = awNbRecKeys[i];

   awNbRefCopies[i]   = 0;
   awNbMatchFields[i] = 0;
   awNbRecKeys[i]     = 0;
  }

for(j=0; *pTextBox[j]; j++)
  for(pInfoLauf_m=apRecInfo_m[j], pLastMatch=NULL;
    pInfoLauf_m; pInfoLauf_m=pInfoLauf_m->pNext)
    {
     WORD wRec=pTextBox[j][pInfoLauf_m->wFeldNr]->wRecord;

     switch (pInfoLauf_m->wArt)
       {
        case RECMATCH:
        case REFMATCH:
          {
           WORD wDatei = pInfoLauf_m->wDatei, wI1, wI2, wLaufNb;
           REC_INFO_MC *pLauf;

	   pFiles[wRec].aMatch
               [awNbMatchFields[wRec]].pMatchField =
                 pTextBox[j][pInfoLauf_m->wFeldNr];

	   pFiles[wRec].aMatch
               [awNbMatchFields[wRec]].pstrFieldName =
                 pInfoLauf_m->pstrTxt;

	   pFiles[wRec].aMatch
               [awNbMatchFields[wRec]].wNbAddFields = 0;

           for (wI1=0; *pTextBox[wI1]; wI1++)
             for (wI2=0; pTextBox[wI1][wI2]; wI2++)
               if (pTextBox[wI1][wI2]->wRecord == wDatei &&
                   !strcmp(pTextBox[wI1][wI2]->strDatenfeld, pInfoLauf_m->strDatenfeld))
                 goto ENDE_MATCH;

       ENDE_MATCH:
           for (pLauf=pInfoLauf_m, wLaufNb=0;
                pLauf; pLauf=pLauf->pNext)
             if (pLauf->wArt == ADDMATCH &&
                 pLauf->wFeldNr == pInfoLauf_m->wFeldNr)
               wLaufNb++;

	   pLastMatch = &pFiles[wRec].
                aMatch[awNbMatchFields[wRec]];

           pLastMatch->wNbAddFields = 0;

           if (wLaufNb)
             {
	      Ut_Calloc(pLastMatch->apAddField, wLaufNb, PTEXTBOX);
	      Ut_Calloc(pLastMatch->apstrAddName, wLaufNb, PSTR);
             }
           else
             {
              pLastMatch->apAddField = NULL;
              pLastMatch->apstrAddName = NULL;
             }

	   pFiles[wRec].aMatch
               [awNbMatchFields[wRec]].ppKey = (VOID*) pTextBox[wI1][wI2];

           awNbMatchFields[wRec]++;
          }
          break;

        case ADDMATCH:
          if (!pLastMatch)
            break;
          else
            {
             PSTR pstrFeld = pInfoLauf_m->strDatenfeld;
             WORD wDatei = pInfoLauf_m->wDatei,
                  wNb = pLastMatch->wNbAddFields,
                  wI1, wI2;

             pLastMatch->apstrAddName[wNb] = pInfoLauf_m->pstrTxt;

             for (wI1=0; *pTextBox[wI1]; wI1++)
               for (wI2=0; pTextBox[wI1][wI2]; wI2++)
                 if (pTextBox[wI1][wI2]->wRecord == wDatei &&
                     !strcmp(pTextBox[wI1][wI2]->strDatenfeld, pstrFeld))
                   goto ENDE_ADD;

         ENDE_ADD:
             pLastMatch->apAddField[wNb] = pTextBox[wI1][wI2];

             pLastMatch->wNbAddFields++;
            }
          break;

        case RECKEY:
          {
           WORD wNb = awNbRecKeys[wRec];

	   pFiles[wRec].apKeys[wNb] =
                  pTextBox[j][pInfoLauf_m->wFeldNr];

	   pFiles[wRec].awKeyOffset[wNb] =
                  pTextBox[j][pInfoLauf_m->wFeldNr]->wOffset;

	   pFiles[wRec].awKeyLength[wNb] =
                  pTextBox[j][pInfoLauf_m->wFeldNr]->wMaxL;

           awNbRecKeys[wRec]++;
          }
          break;

        case REFFIELD:
          if (pTextBox[j][pInfoLauf_m->wFeldNr]->pRefField)
            {
             WORD wNb = awNbRefCopies[wRec];

	     pFiles[wRec].apRefFields[wNb] =
                    pTextBox[j][pInfoLauf_m->wFeldNr];

             awNbRefCopies[wRec]++;
            }
          break;

        case COPYFIELD:
          /*if (pTextBox[j][pInfoLauf_m->wFeldNr]->pRefField)*/
            {
             WORD wNb = awNbRefCopies[wRec];

	     pFiles[wRec].apRefFields[wNb] =
                    pTextBox[j][pInfoLauf_m->wFeldNr];

             awNbRefCopies[wRec]++;
            }
          break;

        default:
          break;
       }

    }

for(j=0; *pTextBox[j]; j++)
  {
  for(pRecInfo=apRecInfo_m[j]; pRecInfo; pRecInfo=pRecInfo->pNext)
    {pInfoLauf_m=pRecInfo;
    Ut_Free(pInfoLauf_m);}

  Ut_Free(apRecInfo_m[j]);
  }

for(i=0; i < (WORD)*pwNbFile; i++)
  for(j=0; j< (WORD)pFiles[i].wNbMatchFields; j++)
    for(l=0; l < (WORD)*pwNbFile; l++)
      for(k=0; k< (WORD)pFiles[l].wNbKeyFields; k++)
	if((VOID*)pFiles[l].apKeys[k] ==
	  (VOID*)pFiles[i].aMatch[j].ppKey)
	  {
	  Wi_TestPrintf(pWkbInfo_g,
	    "\npFiles[%d].aMatch[%d].ppKey=&pFiles[%d].apKeys[%d].",i,j,l,k);

	  pFiles[i].aMatch[j].ppKey = &pFiles[l].apKeys[k];
          l=*pwNbFile;
	  k=pFiles[l].wNbKeyFields;
          }

Dl_Nachricht( NULL, 32, 12);                         /* Nachricht lschen    */
return (wRetCode);
}  /* end M_Init */


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ iM_Init()								     บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID iM_Init(WORD wM, WORD awDateiNummer[][20],
	      CHAR acVerzeichnisName[], PSTR pstrApp, PWKB apWkbMask[],
	      PSTR apstrText[][25], PSTR apstrBrowseText[][25],
	      PTEXTBOX pTextBox[][99], PWORD pwMasks,
	      PWORD pwFirstFieldNumber, WORD awBlocks[][2],
	      WORD awScroll[][4], PPSTR appstrDatei[],
	      PWORD pwRecLen, WORD awFileMode[], PPSTR ppstrIndexKey,
	      PSTR pstrFehler)
{
REGISTER i;
WORD wBufLen=MAX_RECORD_SIZE, wRetCode, wTemp;
CHAR strBuffer[200];
PSTR pstrPos=NULL;
PSTR pstrPos1=NULL;
WORD wSpalte, wZeile, wBreite, wHoehe;
WORD wTitelAttr, wRahmenAttr, wInnenAttr, wTitelPos;
CHAR strTitel[80];
WORD wAttri, wFensterS, wFensterZ, wFensterB, wCursorS, wMaxL,
     wSequenz, wModus, wRecord, wOffset, wMaxMask;
CHOICES  *ptempchoice=NULL;
FELDINFO *ptempinfo=NULL;
BOOL boInsert;
PSTR pstrTemp=NULL;
CHAR strError[TB_MAX];
PSTR pstrDateiName=NULL;
CHAR cColor='\0';

{REGISTER j;
for(j=0; *(pwMasks+j); j++) wMaxMask=j;}	   /* Anzahl Masken ermitteln*/


memset(pstrMaskKey_m, '\0', 20);

if(*(pwMasks+wM)>999)
  sprintf(pstrMaskKey_m, "%#04d", *(pwMasks+wM));
else
  sprintf(pstrMaskKey_m, "%#03d", *(pwMasks+wM));

wRetCode=BTRV(B_GET_EQ, strFileBlock_m,
  pstrDataBuffer_g, &wBufLen, pstrMaskKey_m, 0);

sprintf(strError,"M_Init(B_GET_EQ/%s), - "	     /* 		     */
  "Schlssel: %s",pstrFehler,pstrMaskKey_m,0);	     /* 		     */
Dl_ErrorHandler(wRetCode, strError, _F, _L, 0);      /* 		     */

pstrPos=pstrDataBuffer_g+ 85;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        MASKENTEXT-ZUORDNUNG                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
for(i=0; *pstrPos; i++)
  {
  if(i < 25)
    {/* LONG lBlock=BLOCK, lBrowse=BROWSE;
    if(lBlockVer_g&lBrowse)  wird erst spter belegt */
    Ut_Calloc(apstrBrowseText[wM][i], 121, CHAR);

    Ut_Calloc(apstrText[wM][i], 121, CHAR);
    strcpy(apstrText[wM][i], pstrPos);
    }

  pstrPos = strchr(pstrPos, '\0') + 1;
  }

apstrText[wM][i]=NULL;			  /* Null-Pointer Felder */
apstrBrowseText[wM][i]=NULL;		  /* Null-Pointer Felder */
pstrPos++;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                    WINDOWEINRICHTEN-ZUORDNUNG                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
strcpy(strBuffer, pstrPos);
pstrPos=strchr(pstrPos, '\0') + 1;

sscanf(strBuffer, "%3d", &wSpalte);
sscanf(&strBuffer[4], "%3d", &wZeile);
sscanf(&strBuffer[8], "%3d", &wBreite);
sscanf(&strBuffer[12], "%3d", &wHoehe);
sscanf(&strBuffer[16], "%3d", &wTitelAttr);
sscanf(&strBuffer[20], "%3d", &wRahmenAttr);
sscanf(&strBuffer[24], "%3d", &wInnenAttr);
sscanf(&strBuffer[28], "%3d", &wTitelPos);
sscanf(&strBuffer[32], "%s",  strTitel);

{PSTR pstr=strrchr(strTitel, '๙');
if(pstr) {*pstr='\0'; cColor=*(pstr+1);}}

if(*strTitel != 'ฤ')
  sprintf(&strTitel[strlen(strTitel)], " - %1d/%1d", wM+1, wMaxMask+1);

if((wM % 2 && wBreite < 80 && cColor!='1') || cColor=='0')
  {
  wTitelAttr = aCS_g[wCSInd_g].wCs_m_r2;	/* Masken-Rahmen 2	*/
  wRahmenAttr= aCS_g[wCSInd_g].wCs_m_r2;       /* Masken-Rahmen 2      */
  wInnenAttr = aCS_g[wCSInd_g].wCs_m_i2;	/* Maske-Innen 2	*/
  }
else
  {
  wTitelAttr = aCS_g[wCSInd_g].wCs_m_r1;	/* Masken-Rahmen 1	*/
  wRahmenAttr= aCS_g[wCSInd_g].wCs_m_r1;       /* Masken-Rahmen 1      */
  wInnenAttr = aCS_g[wCSInd_g].wCs_m_i1;	/* Maske-Innen 1	*/
  }

apWkbMask[wM] = Wi_Einrichten(wSpalte, wZeile, wBreite, wHoehe);

if(*(strTitel+1) != 'ฤ' || *strTitel	!= 'ฤ')
  Wi_SetTitel(apWkbMask[wM], strTitel, wTitelPos);

Wi_SetAttri(apWkbMask[wM], wTitelAttr, wRahmenAttr, wInnenAttr);

if(wBreite < 78 && wHoehe < 22)
  Wi_SchattenEin(apWkbMask[wM]);


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                       TEXTBOX-ZUORDNUNG                                  บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
for(i=0; *pstrPos; i++)
  {
  strcpy(strBuffer, pstrPos);
  pstrPos=strchr(pstrPos, '\0') + 1;

  if(i <= 99)
    {
    sscanf(strBuffer, "%3d", &wAttri);
    sscanf(&strBuffer[4], "%3d", &wFensterS);
    sscanf(&strBuffer[8], "%3d", &wFensterZ);
    sscanf(&strBuffer[12], "%3d", &wFensterB);
    sscanf(&strBuffer[16], "%3d", &wCursorS);
    sscanf(&strBuffer[20], "%3d", &wMaxL);
    sscanf(&strBuffer[24], "%3d", &boInsert);
    sscanf(&strBuffer[28], "%3d", &wSequenz);
    sscanf(&strBuffer[32], "%3d", &wModus);
    sscanf(&strBuffer[36], "%2d", &wRecord);
    sscanf(&strBuffer[39], "%4d", &wOffset);

    if((wM % 2 && wBreite < 80 && cColor!='1') || cColor=='0')
      wAttri = aCS_g[wCSInd_g].wCs_m_itb2;  /* Inaktive TextBox 2   */
    else
      wAttri = aCS_g[wCSInd_g].wCs_m_itb1;  /* Inaktive TextBox 1   */

    pTextBox[wM][i]=SetTextBox(pTextBox[wM][i], wAttri,
      wFensterS, wFensterZ, wFensterB, wCursorS, wMaxL,   boInsert,
      wSequenz,  wModus,  wRecord, wOffset);

    sscanf(&strBuffer[44], "%8s", pTextBox[wM][i]->acHelpFile);
    sscanf(&strBuffer[53], "%6s", pTextBox[wM][i]->acHelpKey);
    pTextBox[wM][i]->wHelpTextLength = 0;
    sscanf(&strBuffer[60], "%5d", &pTextBox[wM][i]->wRefCode);
    sscanf(&strBuffer[66], "%3d", &pTextBox[wM][i]->bTyp);
    sscanf(&strBuffer[70], "%3d", &pTextBox[wM][i]->bKomma);
    sscanf(&strBuffer[74], "%11s",pTextBox[wM][i]->strDatenfeld);
    sscanf(&strBuffer[86], "%3d", &pTextBox[wM][i]->bVKS);
    sscanf(&strBuffer[90], "%3d", &pTextBox[wM][i]->bNKS);
    sscanf(&strBuffer[94], "%3d", &pTextBox[wM][i]->wHide);

    pTextBox[wM][i]->pRefField = NULL;

    Ut_Calloc(pTextBox[wM][i]->pFeld, 1, FELDINFO);
    ptempinfo = pTextBox[wM][i]->pFeld;
    for(;*pstrPos;)
      {
      REGISTER k;
      PSTR pstrHilf;

      strcpy (strBuffer, pstrPos);
      pstrPos = strchr (pstrPos, '\0') + 1;
      pstrHilf = strBuffer;

      sscanf (pstrHilf, "%3d", &ptempinfo->bArt);
      pstrHilf += 4;
      sscanf (pstrHilf, "%3d", &ptempinfo->bLaenge);
      pstrHilf += 4;

      for(k=0; k < 20; k++)
	{
	if(*pstrHilf != '')
	  {sscanf(pstrHilf, "%3d", &ptempinfo->abFormat[k]);
	  pstrHilf += 4;}
	else
	  ptempinfo->abFormat[k] = 0;
	}

       if(*pstrPos)
	 {Ut_Calloc(ptempinfo->pNext, 1, FELDINFO);
	 ptempinfo = ptempinfo->pNext;}
      }

    pstrPos++;

    if(*pstrPos)		 /* Choicefeld !!! */
      {
      pTextBox[wM][i]->pSelect = NULL;

      Ut_Calloc(pTextBox[wM][i]->pstrChoiceTitel,
	strlen (pstrPos), CHAR);
      strcpy( pTextBox[wM][i]->pstrChoiceTitel, pstrPos+1);

      pstrPos = strchr (pstrPos, '\0') + 1;

      Ut_Calloc(pTextBox[wM][i]->pChoice, 1, CHOICES);
      ptempchoice = pTextBox[wM][i]->pChoice;

      while(*pstrPos)
	{
	Ut_Calloc(ptempchoice->pstrWert,
	  strlen (pstrPos) + 1, CHAR);
	strcpy (ptempchoice->pstrWert, pstrPos);
	pstrPos = strchr (pstrPos, '\0') + 1;

	Ut_Calloc(ptempchoice->pstrFormat,
	  strlen (pstrPos) + 1, CHAR);
	strcpy (ptempchoice->pstrFormat, pstrPos);
	pstrPos = strchr (pstrPos, '\0') + 1;

	if(*pstrPos)
	  {Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
	  ptempchoice = ptempchoice->pNext;}
	else
	  ptempchoice->pNext = NULL;
	}
      }
    else
      {pTextBox[wM][i]->pstrChoiceTitel = NULL;
       pTextBox[wM][i]->pChoice = NULL;}

    pstrPos++;

    if(*pstrPos)		 /* Selectfeld !!! */
      {
      pTextBox[wM][i]->pChoice = NULL;

      Ut_Calloc(pTextBox[wM][i]->pstrChoiceTitel,
	strlen (pstrPos), CHAR);
      strcpy ( pTextBox[wM][i]->pstrChoiceTitel, pstrPos+1);

      pstrPos = strchr (pstrPos, '\0') + 1;

      Ut_Calloc(pTextBox[wM][i]->pSelect, 1, CHOICES);
      ptempchoice = pTextBox[wM][i]->pSelect;

      while(*pstrPos)
	{
	Ut_Calloc(ptempchoice->pstrWert,
	  strlen (pstrPos) + 1, CHAR);
	strcpy (ptempchoice->pstrWert, pstrPos);
	pstrPos = strchr (pstrPos, '\0') + 1;

	Ut_Calloc(ptempchoice->pstrFormat,
	  strlen (pstrPos) + 1, CHAR);
	strcpy (ptempchoice->pstrFormat, pstrPos);
	pstrPos = strchr (pstrPos, '\0') + 1;

	if(*pstrPos)
	  {
	  Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
	    ptempchoice = ptempchoice->pNext;
	  }
	else
	  ptempchoice->pNext = NULL;

	}
      }
    else			    /* kein Choicefeld */
      pTextBox [wM][i]->pSelect = NULL;

    pstrPos++;

    if(*pstrPos)		 /* Defaultfeld !! */
      {
      /* pTextBox[wM][i]->pstrDefault = NULL; */
      Ut_Calloc(pTextBox[wM][i]->pstrDefault,
	strlen(pstrPos+1)+1, CHAR);
      strcpy(pTextBox[wM][i]->pstrDefault, pstrPos+1);

      pstrPos=strchr(pstrPos, '\0') + 1;
      }
    else			    /* kein Defaultfeld */
      pTextBox[wM][i]->pstrDefault=NULL;

    }

  pstrPos++;
  }  /* end for */


/* while(pTextBox[wM][wSequenz] &&
  pTextBox[wM][wSequenz]->wHide)
  wSequenz++; */

/*  *pwFirstFieldNumber++ = wSequenz;		  /* aus letzter Textbox */

/*  Ut_Free(pTextBox[wM][i-1]); 		   /* letzte Textbox frei-*/
/*  /*pTextBox[wM][i-1] = NULL; 		   /* geben, Null-Pointer */

*(pwFirstFieldNumber+wM)=			     /* +wM ist fr alle Msk */
  pTextBox[wM][i-1]->wSequenz;			     /* aus letzter Textbox */

/*{BOOL boTest=boTestModus_g; boTestModus_g=JA;
  Wi_TestPrintf(pWkbInfo_g, "\npTB[%d][%d]=%d.", wM, i-1,
    pTextBox[wM][i-1]->wSequenz);
  boTestModus_g=boTest;}*/

Ut_Free(pTextBox[wM][i-1]);			   /* letzte Box freigeb. */

pstrPos++;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                       REF_BOX-ZUORDNUNG                                  บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
for(i=98; *pstrPos; i--)
  {
  strcpy (strBuffer, pstrPos);
  pstrPos = strchr(pstrPos, '\0') + 1;

  if(i <= 99)
    {
    sscanf (strBuffer, "%3d", &wAttri);
    sscanf (&strBuffer[4], "%3d", &wFensterS);
    sscanf (&strBuffer[8], "%3d", &wFensterZ);
    sscanf (&strBuffer[12], "%3d", &wFensterB);
    sscanf (&strBuffer[16], "%3d", &wCursorS);
    sscanf (&strBuffer[20], "%3d", &wMaxL);
    sscanf (&strBuffer[24], "%3d", &boInsert);
    sscanf (&strBuffer[28], "%3d", &wSequenz);
    sscanf (&strBuffer[32], "%3d", &wModus);
    sscanf (&strBuffer[36], "%2d", &wRecord);
    sscanf (&strBuffer[39], "%4d", &wOffset);

    if((wM % 2 && wBreite < 80 && cColor!='1') || cColor=='0')
	wAttri = aCS_g[wCSInd_g].wCs_m_itb2;  /* Inaktive TextBox 2   */
    else
	wAttri = aCS_g[wCSInd_g].wCs_m_itb1;  /* Inaktive TextBox 1   */

    pTextBox[wM][i]=SetTextBox(pTextBox[wM][i], wAttri,
       wFensterS, wFensterZ, wFensterB,
       wCursorS, wMaxL,   boInsert,
       wSequenz,  wModus,  wRecord, wOffset);

    sscanf (&strBuffer[44], "%8s", pTextBox[wM][i]->acHelpFile);
    sscanf (&strBuffer[53], "%6s", pTextBox[wM][i]->acHelpKey);
    pTextBox[wM][i]->wHelpTextLength = 0;
    sscanf (&strBuffer[60], "%5d", &pTextBox[wM][i]->wRefCode);
    sscanf (&strBuffer[66], "%3d", &pTextBox[wM][i]->bTyp);
    sscanf (&strBuffer[70], "%3d", &pTextBox[wM][i]->bKomma);
    sscanf (&strBuffer[74], "%11s",pTextBox[wM][i]->strDatenfeld);
    sscanf (&strBuffer[86], "%3d", &pTextBox[wM][i]->bVKS);
    sscanf (&strBuffer[90], "%3d", &pTextBox[wM][i]->bNKS);
    sscanf (&strBuffer[94], "%3d", &pTextBox[wM][i]->wHide);

    Ut_Calloc(pTextBox[wM][i]->pFeld, 1, FELDINFO);
    ptempinfo = pTextBox[wM][i]->pFeld;
    for (;*pstrPos;)
      {
       REGISTER k;
       PSTR pstrHilf;

       strcpy (strBuffer, pstrPos);
       pstrPos = strchr (pstrPos, '\0') + 1;
       pstrHilf = strBuffer;

       sscanf (pstrHilf, "%3d", &ptempinfo->bArt);
       pstrHilf += 4;
       sscanf (pstrHilf, "%3d", &ptempinfo->bLaenge);
       pstrHilf += 4;

       for (k=0; k < 20; k++)
	 {
	  if (*pstrHilf != '')
	    {
	    sscanf (pstrHilf, "%3d", &ptempinfo->abFormat[k]);
	    pstrHilf += 4;
	    }
	  else
	    ptempinfo->abFormat[k] = 0;
	 }

       if (*pstrPos)
	{
	 Ut_Calloc(ptempinfo->pNext, 1, FELDINFO);
	 ptempinfo = ptempinfo->pNext;
	}
      }

    pstrPos++;

    if (*pstrPos)		  /* Choicefeld !!! */
      {
       pTextBox[wM][i]->pSelect = NULL;

       Ut_Calloc(pTextBox[wM][i]->pstrChoiceTitel, strlen (pstrPos), CHAR);
       strcpy( pTextBox[wM][i]->pstrChoiceTitel, pstrPos+1);

       pstrPos = strchr (pstrPos, '\0') + 1;

       Ut_Calloc(pTextBox[wM][i]->pChoice, 1, CHOICES);
       ptempchoice = pTextBox[wM][i]->pChoice;

       while (*pstrPos)
	 {
	  Ut_Calloc(ptempchoice->pstrWert,
	    strlen (pstrPos) + 1, CHAR);
	  strcpy (ptempchoice->pstrWert, pstrPos);
	  pstrPos = strchr (pstrPos, '\0') + 1;

	  Ut_Calloc(ptempchoice->pstrFormat,
	    strlen (pstrPos) + 1, CHAR);
	  strcpy (ptempchoice->pstrFormat, pstrPos);
	  pstrPos = strchr (pstrPos, '\0') + 1;

	  if (*pstrPos)
	    {
	     Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
	     ptempchoice = ptempchoice->pNext;
	    }
	  else
	    ptempchoice->pNext = NULL;
	 }
      }
    else
      {
       pTextBox[wM][i]->pstrChoiceTitel = NULL;
       pTextBox[wM][i]->pChoice = NULL;
      }

    pstrPos++;

    if (*pstrPos)		  /* Selectfeld !!! */
      {
       pTextBox[wM][i]->pChoice = NULL;
       Ut_Calloc(pTextBox[wM][i]->pstrChoiceTitel,
	 strlen (pstrPos), CHAR);
       strcpy ( pTextBox[wM][i]->pstrChoiceTitel, pstrPos+1);

       pstrPos = strchr (pstrPos, '\0') + 1;

       Ut_Calloc(pTextBox[wM][i]->pSelect, 1, CHOICES);
       ptempchoice = pTextBox[wM][i]->pSelect;

       while (*pstrPos)
	 {
	  Ut_Calloc(ptempchoice->pstrWert,
	    strlen (pstrPos) + 1, CHAR);
	  strcpy (ptempchoice->pstrWert, pstrPos);
	  pstrPos = strchr (pstrPos, '\0') + 1;

	  Ut_Calloc(ptempchoice->pstrFormat,
	    strlen (pstrPos) + 1, CHAR);
	  strcpy (ptempchoice->pstrFormat, pstrPos);
	  pstrPos = strchr (pstrPos, '\0') + 1;

	  if (*pstrPos)
	    {
	     Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
	     ptempchoice = ptempchoice->pNext;
	    }
	  else
	    ptempchoice->pNext = NULL;

	 }
      }
    else			    /* kein Choicefeld */
       pTextBox [wM][i]->pSelect = NULL;

    pstrPos++;

    if(*pstrPos)		 /* Defaultfeld !!! */
      {
      /* pTextBox[wM][i]->pstrDefault=NULL; */
      Ut_Calloc(pTextBox[wM][i]->pstrDefault,
	 strlen(pstrPos+1)+1, CHAR);
      strcpy(pTextBox[wM][i]->pstrDefault, pstrPos+1);

      pstrPos=strchr(pstrPos, '\0')+1;
      }
    else			    /* kein Defaultfeld */
      pTextBox[wM][i]->pstrDefault=NULL;

    }

    pstrPos++;

    if(pTextBox[wM][pTextBox[wM][i]->wRefCode]->wRefCode != i)
      {
      printf ("\nKeine Konsistenz in Ref-Handler !!!");

      E(); exit (-1);
      }

    pTextBox[wM][i]->pRefField =
	pTextBox[wM][pTextBox[wM][i]->wRefCode];

    pTextBox[wM][pTextBox[wM][i]->wRefCode]->pRefField =
	pTextBox[wM][i];

  } /* end for */

pstrPos++;

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        MATCHCODE ZUORDNEN                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
Ut_Calloc(apRecInfo_m[wM], 1, REC_INFO_MC);

for(i=0, pInfoLauf_m = apRecInfo_m[wM]; *pstrPos; i++)
  {
  sscanf(pstrPos, "%3d %3d",
	  &pInfoLauf_m->wFeldNr, &pInfoLauf_m->wArt);

  pstrPos=strchr (pstrPos, '\0') + 1;

  if(pInfoLauf_m->wArt == RECMATCH ||
    pInfoLauf_m->wArt == REFMATCH ||
    pInfoLauf_m->wArt == ADDMATCH)
    {
    pInfoLauf_m->pstrTxt = strdup(pstrPos);

    pstrPos = strchr (pstrPos, '\0') + 1;

    sscanf (pstrPos, "%3d %11s",
	     &pInfoLauf_m->wDatei, pInfoLauf_m->strDatenfeld);

    pstrPos = strchr (pstrPos, '\0') + 1;
    }
  else
    {pInfoLauf_m->pstrTxt = NULL;
    pInfoLauf_m->wDatei = 0;
    *pInfoLauf_m->strDatenfeld = '\0';}

  if(*pstrPos)
    {Ut_Calloc(pInfoLauf_m->pNext, 1, REC_INFO_MC);
    pInfoLauf_m = pInfoLauf_m->pNext;}
  else
    pInfoLauf_m->pNext = NULL;
  }

pstrPos++;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                           DATEIEN-ZUORDNUNG                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/

for(i=0; *pstrPos; i++)
  {
  if(*appstrDatei)
    {
    REGISTER k;
    WORD wRecLen;
    CHAR strVerzName[50];

    sscanf(pstrPos + 11, "%10s", strVerzName);

    pstrDateiName=strVerzName;
    while(*pstrDateiName!='.' && *pstrDateiName!='\0')
      pstrDateiName++;

    if(*pstrDateiName=='\0')
      {pstrDateiName=strVerzName;
      *strVerzName='\0';}
    else
      {*pstrDateiName='\0';
      pstrDateiName++;}

    for(k=0; *appstrDatei[k]; k++)
      if(!strncmp(*appstrDatei[k], pstrDateiName, strlen(pstrDateiName))
	&& acVerzeichnisName[k]==*strVerzName )
	break;

    awDateiNummer[wM][i]=k;

    sscanf(pstrPos+22, "%5d", &wRecLen);
    sscanf(pstrPos+28, "%1d", &awFileMode[k]);

    if(k+1>=UPB_FILE_HANDLER)
	    Dl_Abbruch("File-Fehler",_L,_F,
	      str("apstrFileName_g[%d]",k));

    if(*appstrDatei[k]==NULL)
      {
      acVerzeichnisName[k] = strVerzName[0];
      Ut_Calloc(*appstrDatei[k], TB_MAX, CHAR);
      strcpy (*appstrDatei[k], pstrDateiName);
      *(pwRecLen+k)=0;
      *appstrDatei[k+1]=NULL;
      }

    if( *(pwRecLen+k) < wRecLen)
      *(pwRecLen+k) = wRecLen;

    {BOOL boTest=boTestModus_g; boTestModus_g=JA;
    Wi_TestPrintf(pWkbInfo_g, "\nRecLen<%d>(%d/%d)", k, *(pwRecLen+k), wRecLen);
    boTestModus_g=boTest;}
    }

  pstrPos=strchr(pstrPos, '\0') + 1;
  }

pstrPos++;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                      INDEXBEFEHLE-ZUORDNUNG                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/

if(!*ppstrIndexKey)
  {
  Ut_Calloc(*ppstrIndexKey, strlen(pstrPos)+1, CHAR);
  strcpy (*ppstrIndexKey, pstrPos);
  }

pstrPos = strchr(pstrPos, '\0') + 1;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                      BLOCKBEFEHLE-ZUORDNUNG                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
strcpy(strBuffer, pstrPos);

if(!strstr(strBuffer, "(null)"))
  {CHAR cCut;
  pstrPos1 = strchr(strBuffer, ':');
  pstrTemp = strchr(pstrPos1+1, ':');

  cCut=*(pstrPos1+1);				/* &BLOCK oder &BROWSE	*/
  if(cCut=='*') lBlockVer_g=BLOCK;		/* * == 1 == &BLOCK	*/
  else if(cCut=='#') lBlockVer_g=BROWSE;	/* # == 2 == &BROWSE	*/

  for(i=0; pstrTemp - pstrPos1 > 3; i++)
    {
    if(wM>=UPB_MASK || i>=3)
      Dl_Abbruch("Block-Fehler",_L,_F,
	str("awBlocks_g[%d][%d]",wM,i));

    pstrPos1 = strchr(pstrPos1, cCut) + 1;
    sscanf (pstrPos1, "%d",&wTemp);
    awBlocks[wM][i] = wTemp;
    }

  pstrPos1 = pstrTemp;
  pstrTemp = strchr(pstrTemp,'\0');

  for (i=0; pstrTemp - pstrPos1 > 2; i++)
    {
    if(wM>=UPB_MASK || i>=5)
      Dl_Abbruch("Scroll-Fehler",_L,_F,
	str("awScroll_g[%d][%d]",wM,i));

    pstrPos1 = strchr (pstrPos1, '*')+1;
    sscanf (pstrPos1, "%d",&wTemp);
    awScroll[wM][i] = wTemp;
    }

 } /* end if != "(null)" */

pstrPos=strchr(pstrPos, '\0') + 1;


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                      MASK-HILFE-ZUORDNUNG                                บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
pstrTemp=strstr(pstrPos, "~SMH");

if(pstrTemp && wM==0)
  {
  pstrPos=pstrTemp+4;
  if(!memcmp(pstrPos, "XX", 2)) memcpy(pstrPos, pstrApp, 2);
  else if(!memcmp(pstrPos, "XXX", 3)) memcpy(pstrPos, pstrApp, 3);

  memcpy(acHlpFile_g, pstrPos, HLPFL); /* Default-Name der Hilfedatei 2x[F1] */
  pstrPos = strchr(pstrPos, '\0') + 1;
  memcpy(acHlpKey_g, pstrPos, HLPKEY); /* Default-Schlssel bei 2x[F1]         */
  pstrPos = strchr(pstrPos, '\0') + 1;
  }

  /*{BOOL boTest=boTestModus_g; boTestModus_g=JA;
  Wi_TestPrintf(pWkbInfo_g, "\npstrSMH=%s/%s.", pstrTemp, acHlpFile_g);
  Wi_TestPrintf(pWkbInfo_g, "\nFile: <%s>, Line: %d.", _F, _L);
  Wi_TestPrintf(pWkbInfo_g, "\n%s/%s.", acHlpFile_g,acHlpKey_g);
  boTestModus_g=boTest;}*/

    {BOOL boTest=boTestModus_g; boTestModus_g=JA;
    Wi_TestPrintf(pWkbInfo_g, "\nA:<0>(%d) <1>(%d)", *pwRecLen, *(pwRecLen+1) );
    boTestModus_g=boTest;}

return;
} /* ฏฏฏ Ende der Informationszuordnung fr alle Bildschirmmasken !!! */


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    SetTextBox                                            บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
PTEXTBOX SetTextBox(PTEXTBOX pT, WORD wAttri, WORD wFensterS, WORD wFensterZ,
                WORD wFensterB, WORD wCursorS, WORD wMaxL, BOOL boInsert,
		WORD wSequenz, WORD wModus, WORD wRecord, WORD wOffset)
{
Ut_Calloc(pT, 1, TEXTBOX);

pT->wAttri    = wAttri;      pT->wFensterS = wFensterS;
pT->wFensterZ = wFensterZ;   pT->wFensterB = wFensterB;
pT->wCursorS  = wCursorS;    pT->wMaxL	   = wMaxL;
pT->boInsert  = boInsert;    pT->wSequenz  = wSequenz;
pT->wModus    = wModus;      pT->wRecord   = wRecord;
pT->wOffset   = wOffset;

return(pT);
}


/*
sprintf (pstrDataBuffer_g, "%sMASK", pstrApp);
strupr (strrev (pstrDataBuffer_g));
for (j=0; j < strlen(pstrDataBuffer_g); j++)
  if (j%2)
    pstrDataBuffer_g[j] = (CHAR) tolower(pstrDataBuffer_g[j]);

Wi_TestPrintf(pWkbInfo_g,   ฏz.B: KsAmSv fr mAsK vSฎ
     "\npstrDataBuffer_g=%s", pstrDataBuffer_g);
*/


     /* Wi_TestPrintf(pWkbInfo_g,
     "\napstrMaskText[%d][%d]=%s", i, j, apstrMaskText[i][j]); */

     Ut_Free (apstrMaskText[i][j]);
     /*apstrMaskText[i][j]=NULL;*/

     /* Wi_TestPrintf(pWkbInfo_g,
     "\napstrMaskText[%d][%d]=%s", i, j, apstrMaskText[i][j]); */
