/*.ta M_Init()
╔══════════════════════════════════════════════════════════════════════════════╗
║  M_Init()                                                                    ║
╚══════════════════════════════════════════════════════════════════════════════╝

Überblick:
────────────────────────────────────────────────────────────────────────────────
#include <eur_tool.h>
WORD M_Init (pstrApp, apWkbMask[], apstrText[][25], pTextBox[][99],
             pwMasks, pwFirstFieldNumber, awBlocks[][2],
             awScroll[][4], pwNbFile, apstrDatei[], apstrRecord[],
             awInitRecLen[], awRecLen[], pstrFehler)

Parameter:
────────────────────────────────────────────────────────────────────────────────
PSTR     pstrApp              Zeiger auf das Applikationskennzeichen.
PWKB     apWkbMask[]          Array von Zeigern auf die Maskenattribute.
PSTR     apstrText[][25]      Array von Zeigern auf den Maskentext.
PTEXTBOX pTextBox[][99]       Zeiger auf Array mit den Textboxen.
PWORD    pwMasks,             Zeiger auf Array mit den Maskennummern.
PWORD    pwFirstFieldNumber   Zeiger auf Array mit der ersten Feldnummer
                              jeder Maske.
WORD     awBlocks[][2]        Array mit der Information über Blocktyp 1.
WORD     awScroll[][4]        Array mit der Scrollinformation für Blocktyp 1.
PWORD    pwNbFile             Zeiger auf die Anzahl der verwendeten Dateien.
PSTR     apstrDatei[]         Array von Zeigern auf die Dateinamen.
PSTR     apstrRecord[]        Array von Zeigern auf die Dateibuffer.
WORD     awInitRecLen[]       Array mit den min. Datensatzlängen.
WORD     awRecLen[]           Array mit den akt. Datensatzlängen.
PSTR     pstrFehler           Zeiger auf die Fehlerinformation.


Beschreibung:
────────────────────────────────────────────────────────────────────────────────
Meldet alle angegebenen Maskennummern aus der Bibliothek , die durch
das in »pstrApp« übergebene Applikationskennzeichen festgelegt ist, an.
Die Masken können erst danach aufgerufen werden.
M_Init () speichert in der »Textbox«-Struktur alle für den Interpreter
wichtigen Informationen ab, damit dieser Sie nicht mehr aus der Bibliothek
lesen muß.
Aus diesem Grund müssen alle Masken, die im Programm(teil) verwendet werden
sollen, zuvor einmal angemeldet werden. Es ist ein wiederholten Aufruf
von M_Init () im gleichen Programm(teil) möglich.
Es ist möglich, die Masken bereits vor Start des nutzenden Programmes von
einem Initialisierungs- oder Menu-Programm anzumelden.
Ferner werden durch M_Init () auch allgemeine Initialisierungen vorgenommen
die direkt mit den Masken nichts zu tun haben. Durch einen Aufruf von
M_Init wird den zu den Masken gehörigen Dateibuffern Speicherplatz
zugewiesen und die Größe der aufrufenden Funktion mitgeteilt.
Da diese Variablen in fast allen Tool-Routinen benötigt wird, ist es ratsam
M_Init () als eine der ersten Routinen überhaupt aufzurufen.


Versorgung:

   Eingang:
      pstrApp:      Ein im allg. zweistelliges Applikationskennzeichen, das
                    zur Identifikation der Maskenbibliothek dient.
      pwMasks:      Ein Zeiger auf ein Array mit den zu initialisierenden
                    Maskennummern aus der Bibliothek.
      pstrFehler:   Zeiger auf die Fehlerinformation, die beim Auftreten
                    eines Fehlers oder beim Programmablauf im Testmodus
                    im Fehlerfenster zusätzlich angezeigt werden soll.
                    Sie dient zur eindeutigen Feststellung des Ortes
                    im Programm, an dem der Fehler aufgetreten ist.

   Ausgang:
      apWkbMask:    Ein Array von Zeigern auf sog. »Windowkontrollblöcke«.
                    Diese werden vom internen Windowmanager benötigt.
      apstrText:    Ein Array von Zeigern auf den auszugebenden Maskentext.
      pTextBox:     Ein Array von Zeigern auf die »Textbox«-Struktur,die
                    alle für den Interpreter wichtigen Informationen enthält.
      pwFirstFieldNumber : Ein Zeiger auf ein Array mit der ersten
                    anzuspringenden Feldnummer jeder Maske.
      awBlocks:     Ein Array mit den Blockinformationen zum Blocktyp 1.
      awScroll:     Ein Array mit der Scrollinformation zum Blocktyp 1.
      pwNbFile:     Ein Zeiger auf die Anzahl der initialisierten Dateibuffer.
      apstrDatei:   Ein Array von Zeigern auf die zu öffnenden Dateinamen.
      apstrRecord:  Ein Array von Zeigern auf die für die internen Dateibuffer
                    reservierten Speicherbereiche.
      awInitRecLen: Ein Array mit den minimalen Größen der Dateibuffer.
      awRecLen:     Ein Array mit den aktuellen Größen der Dateibuffer.
                    Diese Werte sind naturgemäß beim Verlassen der Funktion
                    M_Init () gleich der im Array awInitRecLen.


Rückgabewert:
────────────────────────────────────────────────────────────────────────────────
WORD  Fehlerinformation OK/ERROR


Benutzte globale Variablen (R/W):
────────────────────────────────────────────────────────────────────────────────
Variablen (R/W):  - aCS_g[]    (R)           - boTestModus_g (R)
                  - wCSInd_g   (R)           - strExe_g      (R)
                  - strDat_g   (R)           - strExt_g      (R)
                  - strMan_g   (R)
.ff
REM .de \euro\demo\dmohilf1.c
.te*/

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                         DEKLARATIONS-DATEIEN                             ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
#define NDEBUG 1                                       /* Checks ausschalten  */
#include <stdio.h>
#include <string.h>
#include <process.h>                                   /*  fuer execl()       */
#include <eur_tool.h>

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║              GLOBALE VARIABLEN, DEFINITION UND REFERENZEN                ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
IMPORT COLORSET aCS_g[];
IMPORT WORD     wCSInd_g;
IMPORT WORD     wVioMode_g;
IMPORT CHAR     strExe_g[];                          /* »EXE« Verzeichnis    */
IMPORT CHAR     strHlp_g[];                          /* »HLP« Verzeichnis    */
IMPORT CHAR     strExt_g[];                          /* Länderextension      */
IMPORT CHAR     strApp_g[];                          /* Für Create / Db_Open */
IMPORT CHAR     strTxt_g[];                          /* TextVerzeichnis      */
IMPORT CHAR     strDat_g[];                          /* Datenverzeichnis     */
IMPORT CHAR     strZug_g[];                          /* »KHK« Verzeichnis    */
IMPORT CHAR     strTeiln_g[];                        /* Teilnehmerverzeichn. */
IMPORT CHAR     strMan_g[];                          /* Mandantennummer      */
IMPORT PSTR     pstrDataBuffer_g;
IMPORT CHAR     acHlpFile_g[];              /* Name der Hilfedatei / _MSK 0 */
IMPORT CHAR     acHlpKey_g[];               /* Hilfstext-Schlüssel / 2x[F1] */
IMPORT PEVENT   pEvent_g;                   /* Für Menu_Handler()           */
IMPORT BOOL     boTestModus_g;              /* -"-                          */
IMPORT PWKB	pWkbInfo_g;
IMPORT	ERRINFO errInfo_g;
IMPORT LONG	lBlockVer_g;			     /* 0==Kein Block	     */
						     /* BLOCK	 1==&BLOCK   */
						     /* BROWSE	 2==&BROWSE  */
						     /* BLK_TYP2 4==mbc.exe  */

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                        MODULGLOBALE FUNKTIONEN                           ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
STATIC PTEXTBOX SetTextBox(PTEXTBOX, WORD, WORD, WORD, WORD,
                       WORD, WORD, BOOL, WORD, WORD, WORD, WORD);

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                        MODULGLOBALE VARIABLEN                            ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
#define RECMATCH   1
#define REFMATCH   2
#define ADDMATCH   4
#define RECKEY     8
#define REFFIELD  16
#define COPYFIELD 32

typedef struct tagFLAG
  {
   WORD wFeldNr;
   WORD wArt;
   PSTR pstrTxt;
   WORD wDatei;
   CHAR strDatenfeld[11];
   struct tagFLAG *pNext;
  } REC_INFO_MC;

REC_INFO_MC *apRecInfo_m[20], *pInfoLauf_m, *pRecInfo;

STATIC CHAR strFileBlock_m[128];                            /* Fileblock für Btrieve */
STATIC PSTR pstrMaskKey_m;

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                          FUNKTIONS-DEFINITION                            ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
GLOBAL
WORD M_Init  (PSTR pstrApp,  PWKB apWkbMask[], PSTR apstrText[][25],
  PSTR apstrBrowseText[][25], PTEXTBOX pTextBox[][99], PWORD pwMasks,
  PFILEINFO pFiles, PWORD pwFirstFieldNumber, WORD awBlocks[][2],
  WORD awScroll[][4], PWORD pwNbFile, PSTR apstrDatei[],
  PSTR apstrRecord[], WORD awInitRecLen[], WORD awRecLen[],
  WORD awFileMode[], PPSTR ppstrIndexKey, PSTR pstrFehler)
{
SWORD wRetCode, wBufferLength;
SWORD i, j, k;
FELDINFO *ptempinfo=NULL;
CHOICES  *ptempchoice=NULL;
WORD wAttri, wFensterS, wFensterZ, wFensterB, wCursorS, wMaxL,
     wSequenz, wModus, wRecord, wOffset, wTemp, wMaxMask;
BOOL boInsert;
WORD wSpalte, wZeile, wBreite, wHoehe;
PSTR pstrMaskenDatei=NULL;
CHAR strTitel[80];
WORD wNull;
CHAR strError[TB_MAX], strNull[TB_MAX];
CHAR strBuffer[120];
WORD wTitelPos;
WORD wTitelAttr, wRahmenAttr, wInnenAttr;
PSTR pstrDateiName=NULL;
PSTR pstrPos=NULL;
PSTR pstrPos1=NULL;
PSTR pstrTemp=NULL;
CHAR acVerzeichnisName[20];
WORD awDateiNummer[20][20];    /* Die Indices der Arrays gelten unter der An- */
                               /* nahme, daß max. 20 Masken und 20 Dateien    */
                               /* gleichen Zeit benötigt werden. Der erste    */
                               /* Index steht für die Anzahl der Masken, der  */
                               /* zweite für die Anzahl der Dateien.          */

WORD awNbRecKeys[20];
WORD awNbRefFields[20];
WORD awNbRefCopies[20];
WORD awNbMatchFields[20];

MATCH *pLastMatch=NULL;
strncpy(strApp_g, pstrApp, 3);                       /* Für Create / Db_Open */

*ppstrIndexKey=NULL;
Ut_Calloc(pstrMaskKey_m, 20, CHAR);	     /* Reservieren von 20 Zeichen    */
                                             /* für den Schlüssel der Maske   */
                                             /* in der Bibliothek .           */

Ut_Calloc(pstrMaskenDatei, TB_MAX, CHAR);    /* Maskendateiname, max. 128     */
                                             /* Zeichen.                      */

/*printf("\n\nIn M_Init_2 / _msize(%u), pstr(%u).",
  _msize(pstrMaskenDatei), pstrMaskenDatei);*/

memcpy(acHlpFile_g, "SYHLP10", HLPFL); /* Default-Name der Hilfedatei 2x[F1] */
memcpy(acHlpKey_g, "blank", HLPKEY);   /* Default-Schlüssel bei 2x[F1]       */

sprintf(pstrMaskenDatei, "%s%s%s%s", strExe_g,      /* Maskendatei aus glo-  */
  pstrApp, "MASK.", strExt_g);                      /* balen Variablen bilden*/

for(j=0; *(pwMasks+j); j++)                        /* Anzahl Masken ermitteln*/
  wMaxMask=j;

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                         ÖFFNEN-BIBLIOTHEK                                ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
    strcpy(pstrDataBuffer_g, "(c)Mayer");
    wBufferLength=strlen(pstrDataBuffer_g)+1;
    wRetCode=BTRV (B_OPEN, strFileBlock_m, pstrDataBuffer_g,
      &wBufferLength, pstrMaskenDatei, O_NORMAL);

    sprintf(strError,"M_Init(B_OPEN/%s), - "         /*                      */
      "Datei: %s", pstrFehler, pstrMaskenDatei);

    Dl_ErrorHandler(wRetCode, strError, _F, _L, 0);  /* 		     */

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║ »»» Start der Informationszuordnung für alle Bildschirmmasken !!!        ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
for(j=0; *(pwMasks+j); j++)
   {
    CHAR cColor='\0';
    memset (pstrMaskKey_m, '\0', 20);

    if(*(pwMasks+j)>999)
      sprintf(pstrMaskKey_m, "%#04d", *(pwMasks+j));
    else
      sprintf(pstrMaskKey_m, "%#03d", *(pwMasks+j));

    wBufferLength = MAX_RECORD_SIZE;

    wRetCode = BTRV (B_GET_EQ, strFileBlock_m, pstrDataBuffer_g,
                      &wBufferLength, pstrMaskKey_m, 0);  /* -(i12)- */

      sprintf(strError,"M_Init(B_GET_EQ/%s), - "     /*                      */
        "Schlüssel: %s",pstrFehler,pstrMaskKey_m,0); /*                      */

      Dl_ErrorHandler(wRetCode, strError, _F, _L, 0);/* 		     */

    pstrPos = pstrDataBuffer_g + 85;

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                        MASKENTEXT-ZUORDNUNG                              ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
    for(i=0; *pstrPos; i++)
       {
       if(i < 25)
	 {/* LONG lBlock=BLOCK, lBrowse=BROWSE;
	 if(lBlockVer_g&lBrowse)  wird erst später belegt */
	   Ut_Calloc(apstrBrowseText[j][i], 121, CHAR);

	 Ut_Calloc(apstrText[j][i], 121, CHAR);
	 strcpy(apstrText[j][i], pstrPos);
	 }
       pstrPos = strchr(pstrPos, '\0') + 1;
       }
    apstrText[j][i]=NULL;		     /* Null-Pointer Felder */
    apstrBrowseText[j][i]=NULL; 	     /* Null-Pointer Felder */
    pstrPos++;

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                    WINDOWEINRICHTEN-ZUORDNUNG                            ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/

    strcpy (strBuffer, pstrPos);
    pstrPos = strchr(pstrPos, '\0') + 1;

    sscanf (strBuffer, "%3d", &wSpalte);
    sscanf (&strBuffer[4], "%3d", &wZeile);
    sscanf (&strBuffer[8], "%3d", &wBreite);
    sscanf (&strBuffer[12], "%3d", &wHoehe);
    sscanf (&strBuffer[16], "%3d", &wTitelAttr);
    sscanf (&strBuffer[20], "%3d", &wRahmenAttr);
    sscanf (&strBuffer[24], "%3d", &wInnenAttr);
    sscanf (&strBuffer[28], "%3d", &wTitelPos);
    sscanf (&strBuffer[32], "%s",  strTitel);

    {PSTR pstr=strrchr(strTitel, '¨');
    if(pstr) {*pstr='\0'; cColor=*(pstr+1);}}

    if (*strTitel != '─')
      sprintf(&strTitel[strlen(strTitel)], " - %1d/%1d", j+1, wMaxMask+1);

    if((j % 2 && wBreite < 80 && cColor!='1') || cColor=='0')
      {
       wTitelAttr = aCS_g[wCSInd_g].wCs_m_r2;	     /* Masken-Rahmen 2      */
       wRahmenAttr = aCS_g[wCSInd_g].wCs_m_r2;	     /* Masken-Rahmen 2      */
       wInnenAttr = aCS_g[wCSInd_g].wCs_m_i2;	     /* Maske-Innen 2	     */
      }
    else
      {
       wTitelAttr = aCS_g[wCSInd_g].wCs_m_r1;	     /* Masken-Rahmen 1      */
       wRahmenAttr = aCS_g[wCSInd_g].wCs_m_r1;	     /* Masken-Rahmen 1      */
       wInnenAttr = aCS_g[wCSInd_g].wCs_m_i1;	     /* Maske-Innen 1	     */
      }

    apWkbMask[j] = Wi_Einrichten(wSpalte, wZeile, wBreite, wHoehe);

    if (*(strTitel+1) != '─' ||
         *strTitel    != '─')
      Wi_SetTitel(apWkbMask[j], strTitel, wTitelPos);

    Wi_SetAttri(apWkbMask[j], wTitelAttr, wRahmenAttr, wInnenAttr);

    if (wBreite < 78 && wHoehe < 22)
      Wi_SchattenEin(apWkbMask[j]);

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                       TEXTBOX-ZUORDNUNG                                  ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
    for(i=0; *pstrPos; i++)
       {
        strcpy (strBuffer, pstrPos);
        pstrPos = strchr(pstrPos, '\0') + 1;

        if (i <= 99)
         {
           sscanf (strBuffer, "%3d", &wAttri);
           sscanf (&strBuffer[4], "%3d", &wFensterS);
           sscanf (&strBuffer[8], "%3d", &wFensterZ);
           sscanf (&strBuffer[12], "%3d", &wFensterB);
           sscanf (&strBuffer[16], "%3d", &wCursorS);
           sscanf (&strBuffer[20], "%3d", &wMaxL);
           sscanf (&strBuffer[24], "%3d", &boInsert);
           sscanf (&strBuffer[28], "%3d", &wSequenz);
	   sscanf (&strBuffer[32], "%3d", &wModus);
           sscanf (&strBuffer[36], "%2d", &wRecord);
           sscanf (&strBuffer[39], "%4d", &wOffset);

	   if((j % 2 && wBreite < 80 && cColor!='1') || cColor=='0')
	       wAttri = aCS_g[wCSInd_g].wCs_m_itb2;  /* Inaktive TextBox 2   */
           else
	       wAttri = aCS_g[wCSInd_g].wCs_m_itb1;  /* Inaktive TextBox 1   */

           pTextBox[j][i]=SetTextBox(pTextBox[j][i], wAttri,
                 wFensterS, wFensterZ, wFensterB, wCursorS, wMaxL,   boInsert,
				       wSequenz,  wModus,  wRecord, wOffset);

           sscanf (&strBuffer[44], "%8s", pTextBox[j][i]->acHelpFile);
           sscanf (&strBuffer[53], "%6s", pTextBox[j][i]->acHelpKey);
           pTextBox[j][i]->wHelpTextLength = 0;
           sscanf (&strBuffer[60], "%5d", &pTextBox[j][i]->swRefCode);
           sscanf (&strBuffer[66], "%3d", &pTextBox[j][i]->bTyp);
           sscanf (&strBuffer[70], "%3d", &pTextBox[j][i]->sbKomma);
           sscanf (&strBuffer[74], "%11s",pTextBox[j][i]->strDatenfeld);
           sscanf (&strBuffer[86], "%3d", &pTextBox[j][i]->bVKS);
           sscanf (&strBuffer[90], "%3d", &pTextBox[j][i]->bNKS);
           sscanf (&strBuffer[94], "%3d", &pTextBox[j][i]->wHide);

           pTextBox[j][i]->pRefField = NULL;

	   Ut_Calloc(pTextBox[j][i]->pFeld, 1, FELDINFO);
           ptempinfo = pTextBox[j][i]->pFeld;
           for (;*pstrPos;)
             {
              REGISTER k;
              PSTR pstrHilf;

              strcpy (strBuffer, pstrPos);
              pstrPos = strchr (pstrPos, '\0') + 1;
              pstrHilf = strBuffer;

              sscanf (pstrHilf, "%3d", &ptempinfo->bArt);
              pstrHilf += 4;
              sscanf (pstrHilf, "%3d", &ptempinfo->sbLaenge);
              pstrHilf += 4;

              for (k=0; k < 20; k++)
                {
                 if (*pstrHilf != '■')
                   {
                   sscanf (pstrHilf, "%3d", &ptempinfo->abFormat[k]);
                   pstrHilf += 4;
                   }
                 else
                   ptempinfo->abFormat[k] = 0;
                }

              if (*pstrPos)
               {
		Ut_Calloc(ptempinfo->pNext, 1, FELDINFO);
                ptempinfo = ptempinfo->pNext;
               }
             }

           pstrPos++;

           if (*pstrPos)                 /* Choicefeld !!! */
             {
	      pTextBox[j][i]->pSelect = NULL;

	      Ut_Calloc(pTextBox[j][i]->pstrChoiceTitel,
                strlen (pstrPos), CHAR);
              strcpy ( pTextBox[j][i]->pstrChoiceTitel, pstrPos+1);

              pstrPos = strchr (pstrPos, '\0') + 1;

	      Ut_Calloc(pTextBox[j][i]->pChoice, 1, CHOICES);
              ptempchoice = pTextBox[j][i]->pChoice;

              while (*pstrPos)
                {
		 Ut_Calloc(ptempchoice->pstrWert,
                   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrWert, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

		 Ut_Calloc(ptempchoice->pstrFormat,
                   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrFormat, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

                 if (*pstrPos)
                   {
		    Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
                    ptempchoice = ptempchoice->pNext;
                   }
                 else
                   ptempchoice->pNext = NULL;
                }
             }
           else
             {
              pTextBox[j][i]->pstrChoiceTitel = NULL;
              pTextBox[j][i]->pChoice = NULL;
             }

           pstrPos++;

           if (*pstrPos)                 /* Selectfeld !!! */
             {
	      pTextBox[j][i]->pChoice = NULL;

	      Ut_Calloc(pTextBox[j][i]->pstrChoiceTitel,
                strlen (pstrPos), CHAR);
              strcpy ( pTextBox[j][i]->pstrChoiceTitel, pstrPos+1);

              pstrPos = strchr (pstrPos, '\0') + 1;

	      Ut_Calloc(pTextBox[j][i]->pSelect, 1, CHOICES);
              ptempchoice = pTextBox[j][i]->pSelect;

              while (*pstrPos)
                {
		 Ut_Calloc(ptempchoice->pstrWert,
                   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrWert, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

		 Ut_Calloc(ptempchoice->pstrFormat,
                   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrFormat, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

                 if (*pstrPos)
                   {
		    Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
                    ptempchoice = ptempchoice->pNext;
                   }
                 else
                   ptempchoice->pNext = NULL;

                }
             }
           else                            /* kein Choicefeld */
              pTextBox [j][i]->pSelect = NULL;

           pstrPos++;

	   if (*pstrPos)		 /* Defaultfeld !! */
             {
	      /* pTextBox[j][i]->pstrDefault = NULL; */
	      Ut_Calloc(pTextBox[j][i]->pstrDefault,
		strlen(pstrPos+1)+1, CHAR);
	      strcpy(pTextBox[j][i]->pstrDefault, pstrPos+1);

	      pstrPos=strchr(pstrPos, '\0') + 1;
             }
	   else 			   /* kein Defaultfeld */
	      pTextBox[j][i]->pstrDefault=NULL;

         }

        pstrPos++;

       }  /* end for */


    /* while(pTextBox[j][wSequenz] &&
      pTextBox[j][wSequenz]->wHide)
      wSequenz++; */

    /*	*pwFirstFieldNumber++ = wSequenz;	      /* aus letzter Textbox */

    /*	Ut_Free(pTextBox[j][i-1]);		      /* letzte Textbox frei-*/
    /*	/*pTextBox[j][i-1] = NULL;		      /* geben, Null-Pointer */

    *pwFirstFieldNumber++ =			      /* ++ ist für alle Msk */
      pTextBox[j][i-1]->wSequenz;		      /* aus letzter Textbox */

    Ut_Free(pTextBox[j][i-1]);			      /* letzte Box freigeb. */

    pstrPos++;


/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                       REF_BOX-ZUORDNUNG                                  ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
    for (i=98; *pstrPos; i--)
       {
        strcpy (strBuffer, pstrPos);
        pstrPos = strchr(pstrPos, '\0') + 1;

        if (i <= 99)
         {
           sscanf (strBuffer, "%3d", &wAttri);
           sscanf (&strBuffer[4], "%3d", &wFensterS);
           sscanf (&strBuffer[8], "%3d", &wFensterZ);
           sscanf (&strBuffer[12], "%3d", &wFensterB);
           sscanf (&strBuffer[16], "%3d", &wCursorS);
           sscanf (&strBuffer[20], "%3d", &wMaxL);
           sscanf (&strBuffer[24], "%3d", &boInsert);
           sscanf (&strBuffer[28], "%3d", &wSequenz);
	   sscanf (&strBuffer[32], "%3d", &wModus);
           sscanf (&strBuffer[36], "%2d", &wRecord);
           sscanf (&strBuffer[39], "%4d", &wOffset);

	   if((j % 2 && wBreite < 80 && cColor!='1') || cColor=='0')
	       wAttri = aCS_g[wCSInd_g].wCs_m_itb2;  /* Inaktive TextBox 2   */
           else
	       wAttri = aCS_g[wCSInd_g].wCs_m_itb1;  /* Inaktive TextBox 1   */

           pTextBox[j][i]=SetTextBox(pTextBox[j][i], wAttri,
              wFensterS, wFensterZ, wFensterB,
              wCursorS, wMaxL,   boInsert,
	      wSequenz,  wModus,  wRecord, wOffset);

           sscanf (&strBuffer[44], "%8s", pTextBox[j][i]->acHelpFile);
           sscanf (&strBuffer[53], "%6s", pTextBox[j][i]->acHelpKey);
           pTextBox[j][i]->wHelpTextLength = 0;
           sscanf (&strBuffer[60], "%5d", &pTextBox[j][i]->swRefCode);
           sscanf (&strBuffer[66], "%3d", &pTextBox[j][i]->bTyp);
           sscanf (&strBuffer[70], "%3d", &pTextBox[j][i]->sbKomma);
           sscanf (&strBuffer[74], "%11s",pTextBox[j][i]->strDatenfeld);
           sscanf (&strBuffer[86], "%3d", &pTextBox[j][i]->bVKS);
           sscanf (&strBuffer[90], "%3d", &pTextBox[j][i]->bNKS);
           sscanf (&strBuffer[94], "%3d", &pTextBox[j][i]->wHide);

	   Ut_Calloc(pTextBox[j][i]->pFeld, 1, FELDINFO);
           ptempinfo = pTextBox[j][i]->pFeld;
           for (;*pstrPos;)
             {
              REGISTER k;
              PSTR pstrHilf;

              strcpy (strBuffer, pstrPos);
              pstrPos = strchr (pstrPos, '\0') + 1;
              pstrHilf = strBuffer;

              sscanf (pstrHilf, "%3d", &ptempinfo->bArt);
              pstrHilf += 4;
              sscanf (pstrHilf, "%3d", &ptempinfo->sbLaenge);
              pstrHilf += 4;

              for (k=0; k < 20; k++)
                {
                 if (*pstrHilf != '■')
                   {
                   sscanf (pstrHilf, "%3d", &ptempinfo->abFormat[k]);
                   pstrHilf += 4;
                   }
                 else
                   ptempinfo->abFormat[k] = 0;
                }

              if (*pstrPos)
               {
		Ut_Calloc(ptempinfo->pNext, 1, FELDINFO);
                ptempinfo = ptempinfo->pNext;
               }
             }

           pstrPos++;

           if (*pstrPos)                 /* Choicefeld !!! */
             {
              pTextBox[j][i]->pSelect = NULL;

	      Ut_Calloc(pTextBox[j][i]->pstrChoiceTitel, strlen (pstrPos), CHAR);
              strcpy( pTextBox[j][i]->pstrChoiceTitel, pstrPos+1);

              pstrPos = strchr (pstrPos, '\0') + 1;

	      Ut_Calloc(pTextBox[j][i]->pChoice, 1, CHOICES);
              ptempchoice = pTextBox[j][i]->pChoice;

              while (*pstrPos)
                {
		 Ut_Calloc(ptempchoice->pstrWert,
                   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrWert, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

		 Ut_Calloc(ptempchoice->pstrFormat,
                   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrFormat, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

                 if (*pstrPos)
                   {
		    Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
                    ptempchoice = ptempchoice->pNext;
                   }
                 else
                   ptempchoice->pNext = NULL;
                }
             }
           else
             {
              pTextBox[j][i]->pstrChoiceTitel = NULL;
              pTextBox[j][i]->pChoice = NULL;
             }

           pstrPos++;

           if (*pstrPos)                 /* Selectfeld !!! */
             {
              pTextBox[j][i]->pChoice = NULL;
	      Ut_Calloc(pTextBox[j][i]->pstrChoiceTitel,
                strlen (pstrPos), CHAR);
              strcpy ( pTextBox[j][i]->pstrChoiceTitel, pstrPos+1);

              pstrPos = strchr (pstrPos, '\0') + 1;

	      Ut_Calloc(pTextBox[j][i]->pSelect, 1, CHOICES);
              ptempchoice = pTextBox[j][i]->pSelect;

              while (*pstrPos)
                {
		 Ut_Calloc(ptempchoice->pstrWert,
                   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrWert, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

		 Ut_Calloc(ptempchoice->pstrFormat,
                   strlen (pstrPos) + 1, CHAR);
                 strcpy (ptempchoice->pstrFormat, pstrPos);
                 pstrPos = strchr (pstrPos, '\0') + 1;

                 if (*pstrPos)
                   {
		    Ut_Calloc(ptempchoice->pNext, 1, CHOICES);
                    ptempchoice = ptempchoice->pNext;
                   }
                 else
                   ptempchoice->pNext = NULL;

                }
             }
           else                            /* kein Choicefeld */
              pTextBox [j][i]->pSelect = NULL;

           pstrPos++;

	   if(*pstrPos) 		/* Defaultfeld !!! */
             {
	     /* pTextBox[j][i]->pstrDefault=NULL; */
	     Ut_Calloc(pTextBox[j][i]->pstrDefault,
		strlen(pstrPos+1)+1, CHAR);
	     strcpy(pTextBox[j][i]->pstrDefault, pstrPos+1);

	     pstrPos=strchr(pstrPos, '\0')+1;
             }
	   else 			   /* kein Defaultfeld */
	     pTextBox[j][i]->pstrDefault=NULL;

         }

        pstrPos++;

        if (pTextBox[j][pTextBox[j][i]->swRefCode]->swRefCode != i)
          {
           printf ("\nKeine Konsistenz in Ref-Handler !!!");

	   E(); exit (-1);
          }

        pTextBox[j][i]->pRefField =
            pTextBox[j][pTextBox[j][i]->swRefCode];

        pTextBox[j][pTextBox[j][i]->swRefCode]->pRefField =
            pTextBox[j][i];

       }  /* end for */

    pstrPos++;

/*╔════════════════════════════════════════════════════════════════════════╗
  ║                        MATCHCODE ZUORDNEN                              ║
  ╚════════════════════════════════════════════════════════════════════════╝*/
    Ut_Calloc(apRecInfo_m[j], 1, REC_INFO_MC);

    for (i=0,
         pInfoLauf_m = apRecInfo_m[j];
         *pstrPos; i++)
      {
       sscanf (pstrPos, "%3d %3d",
               &pInfoLauf_m->wFeldNr, &pInfoLauf_m->wArt);

       pstrPos = strchr (pstrPos, '\0') + 1;

       if (pInfoLauf_m->wArt == RECMATCH ||
           pInfoLauf_m->wArt == REFMATCH ||
           pInfoLauf_m->wArt == ADDMATCH)
         {
          pInfoLauf_m->pstrTxt = strdup(pstrPos);

          pstrPos = strchr (pstrPos, '\0') + 1;

          sscanf (pstrPos, "%3d %11s",
                  &pInfoLauf_m->wDatei, pInfoLauf_m->strDatenfeld);

          pstrPos = strchr (pstrPos, '\0') + 1;
         }
       else
         {
          pInfoLauf_m->pstrTxt = NULL;
          pInfoLauf_m->wDatei = 0;
          *pInfoLauf_m->strDatenfeld = '\0';
         }

       if (*pstrPos)
         {
	  Ut_Calloc(pInfoLauf_m->pNext, 1, REC_INFO_MC);
          pInfoLauf_m = pInfoLauf_m->pNext;
         }
       else
         pInfoLauf_m->pNext = NULL;
      }

    pstrPos++;


/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                           DATEIEN-ZUORDNUNG                              ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/

    for (i=0; *pstrPos; i++)
      {
       if(apstrDatei)
         {
          WORD wRecLen;
          CHAR strVerzName[50];

          sscanf (pstrPos + 11, "%10s", strVerzName);

          pstrDateiName=strVerzName;
          while (*pstrDateiName!='.' && *pstrDateiName!='\0')
             pstrDateiName++;

          if (*pstrDateiName=='\0')
             {
              pstrDateiName=strVerzName;
              *strVerzName = '\0';
             }
          else
             {
              *pstrDateiName='\0';
              pstrDateiName++;
             }

	  for(k=0; apstrDatei[k]; k++)
	     if(!strncmp(apstrDatei[k],pstrDateiName,strlen(pstrDateiName))
	       && acVerzeichnisName[k]==*strVerzName )
	     break;

	  awDateiNummer[j][i]=k;

          sscanf (pstrPos+22, "%5d", &wRecLen);
          sscanf (pstrPos+28, "%1d", &awFileMode[k]);

	  if(k+1>=UPB_FILE_HANDLER)
	    Dl_Abbruch("File-Fehler",_L,_F,
	      str("apstrFileName_g[%d]",k));

	  if(apstrDatei[k] == NULL)
            {
	    acVerzeichnisName[k] = strVerzName[0];
	    Ut_Calloc(apstrDatei[k], TB_MAX, CHAR);
	    strcpy (apstrDatei[k], pstrDateiName);
	    awRecLen[k] = 0;

	    apstrDatei[k+1]=NULL;
            }

          if (awRecLen[k] < wRecLen)
            awRecLen[k] = wRecLen;
         }
       pstrPos = strchr (pstrPos, '\0') + 1;
      }

    pstrPos++;


/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                      INDEXBEFEHLE-ZUORDNUNG                              ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/

if(!*ppstrIndexKey)
  {
  Ut_Calloc(*ppstrIndexKey, strlen(pstrPos)+1, CHAR);
  strcpy (*ppstrIndexKey, pstrPos);
  }

pstrPos = strchr(pstrPos, '\0') + 1;

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                      BLOCKBEFEHLE-ZUORDNUNG                              ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
    strcpy(strBuffer, pstrPos);

    if(!strstr(strBuffer, "(null)"))
      {CHAR cCut;
      pstrPos1 = strchr(strBuffer, ':');
      pstrTemp = strchr(pstrPos1+1, ':');

      cCut=*(pstrPos1+1);			    /* &BLOCK oder &BROWSE  */
      if(cCut=='*') lBlockVer_g=BLOCK;		    /* * == 1 == &BLOCK     */
      else if(cCut=='#') lBlockVer_g=BROWSE;	    /* # == 2 == &BROWSE    */

      for(i=0; pstrTemp - pstrPos1 > 3; i++)
	{
	if(j>=UPB_MASK || i>=3)
	  Dl_Abbruch("Block-Fehler",_L,_F,
	    str("awBlocks_g[%d][%d]",j,i));

	pstrPos1 = strchr(pstrPos1, cCut) + 1;
	sscanf (pstrPos1, "%d",&wTemp);
	awBlocks[j][i] = wTemp;
	}

      pstrPos1 = pstrTemp;
      pstrTemp = strchr(pstrTemp,'\0');

      for (i=0; pstrTemp - pstrPos1 > 2; i++)
	{
	if(j>=UPB_MASK || i>=5)
	  Dl_Abbruch("Scroll-Fehler",_L,_F,
	    str("awScroll_g[%d][%d]",j,i));

	pstrPos1 = strchr (pstrPos1, '*')+1;
	sscanf (pstrPos1, "%d",&wTemp);
	awScroll[j][i] = wTemp;
	}

     } /* end if != "(null)" */

pstrPos=strchr(pstrPos, '\0') + 1;

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                      MASK-HILFE-ZUORDNUNG                                ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
pstrTemp=strstr(pstrPos, "~SMH");

if(pstrTemp && j==0)
  {
  pstrPos=pstrTemp+4;
  if(!memcmp(pstrPos, "XX", 2)) memcpy(pstrPos, pstrApp, 2);
  else if(!memcmp(pstrPos, "XXX", 3)) memcpy(pstrPos, pstrApp, 3);

  memcpy(acHlpFile_g, pstrPos, HLPFL); /* Default-Name der Hilfedatei 2x[F1] */
  pstrPos = strchr(pstrPos, '\0') + 1;
  memcpy(acHlpKey_g, pstrPos, HLPKEY); /* Default-Schlüssel bei 2x[F1]         */
  pstrPos = strchr(pstrPos, '\0') + 1;
  }

  /*{BOOL boTest=boTestModus_g; boTestModus_g=JA;
  Wi_TestPrintf(pWkbInfo_g, "\npstrSMH=%s/%s.", pstrTemp, acHlpFile_g);
  Wi_TestPrintf(pWkbInfo_g, "\nFile: <%s>, Line: %d.", _F, _L);
  Wi_TestPrintf(pWkbInfo_g, "\n%s/%s.", acHlpFile_g,acHlpKey_g);
  boTestModus_g=boTest;}*/
  /*╔══════════════════════════════════════════════════════════════════════╗
    ║ »»» Ende der Informationszuordnung für alle Bildschirmmasken !!!	   ║
    ╚══════════════════════════════════════════════════════════════════════╝*/
  } /* end for (pwMasks[j]) */

*apstrText[j]=NULL;				      /* Null-Pointer Masken */
*apstrBrowseText[j]=NULL;			      /* Null-Pointer Masken */
*pTextBox[j]=NULL;				      /* Null-Pointer Masken */
apWkbMask[j]=NULL;				      /* Null-Pointer Masken */

/*╔══════════════════════════════════════════════════════════════════════════╗
  ║                        SCHLIESSEN-BIBLIOTHEK                             ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
wRetCode=BTRV(B_CLOSE, strFileBlock_m, strNull,
  &wNull, strNull, wNull);                           /* -(i04)- */
  sprintf(strError,"M_Init(B_CLOSE/%s), - "          /*                      */
    "Datei: %s", pstrFehler, pstrMaskenDatei);	     /* 		     */

  Dl_ErrorHandler(wRetCode, strError, _F, _L, 0);    /* 		     */

Ut_Free(pstrMaskKey_m);
Ut_Free(pstrMaskenDatei);

wRetCode = 0;
if(apstrDatei)
  {
  D_DATE *pD=NULL;
  pD=D_get_date(pD);

  for(i=0; apstrDatei[i]; i++)
    {
    CHAR strHelp[TB_MAX];
    strcpy(strHelp, apstrDatei[i]);

    switch(acVerzeichnisName[i])
      {
      case '5': 				     /* Daten vor 5 Jahren   */
	 sprintf(apstrDatei[i], "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-5, strHelp);
         break;

      case '4': 				     /* Daten vor 4 Jahren   */
	 sprintf(apstrDatei[i], "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-4, strHelp);
         break;

      case '3': 				     /* Daten vor 3 Jahren   */
	 sprintf(apstrDatei[i], "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-3, strHelp);
         break;

      case '2': 				     /* Daten vor 2 Jahren   */
	 sprintf(apstrDatei[i], "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-2, strHelp);
         break;

      case 'V': 				     /* Daten-Vohrjahr	     */
	 sprintf(apstrDatei[i], "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr-1, strHelp);
         break;

      case 'D':                                      /* Daten-Verzeichnis    */
	 sprintf(apstrDatei[i], "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr, strHelp);
	 break;

      case 'N': 				     /* Daten-Verzeichnis    */
	 sprintf(apstrDatei[i], "%sD%s\\%#04d\\%s.BTR",
	   strDat_g, strMan_g, pD->wJahr+1, strHelp);
         break;

      case 'L':                                      /* Daten-Lexikon        */
         stradd (apstrDatei[i], strDat_g,
            strHelp, ".BTR", NULL);
         break;

      case 'T':                                      /*Teilnehmer-Verzeichnis*/
         stradd (apstrDatei[i], strTeiln_g,
            strHelp, ".BTR", NULL);
         break;

      case 'X':                                      /* TXT-Verzeichnis       */
         stradd (apstrDatei[i], strTxt_g,
            strHelp, ".TXT", NULL);
         break;

      case 'E':                                      /* Exe-Verzeichnis      */
         stradd (apstrDatei[i], strExe_g,            /* mit Länderextension  */
            strHelp, ".", strExt_g, NULL);
         break;

      case 'H':                                      /* Hlp-Verzeichnis      */
         stradd (apstrDatei[i], strHlp_g,
            strHelp, ".", strExt_g, NULL);
         break;

      case 'S':                                      /* Exe-Verzeichnis      */
         stradd (apstrDatei[i], strExe_g,            /* mit BTR-Extension    */
            strHelp, ".BTR", NULL);                  /* == Systemfile        */
         break;

      case 'Z':                                      /* KHK-Verzeichnis etc. */
         stradd (apstrDatei[i], strZug_g,            /* mit BTR-Extension    */
            strHelp, ".BTR", NULL);                  /* == Zugangsfile       */

         if(*strHelp=='M')                           /* Wenn der Dateiname   */
           {stradd(apstrDatei[i], strZug_g,          /* M beginnt, dann tau- */
           &strMan_g[1],&strHelp[1],".BTR",NULL);}   /* sche mit Mandanten-Nr*/
         break;

      default:                                      /*Fehler-Meldung bringen */
	 sprintf(apstrDatei[i], "%c.%s",
            acVerzeichnisName[i], strHelp);
         wRetCode = 710;                             /* Falsche Verzeichnis- */
         break;                                      /* angabe (D,L,T etc.)  */
      } /* end switch */

      sprintf(strError,"M_Init(%s), - Verzeichnis:"  /*                      */
	" %s", pstrFehler, apstrDatei[i]);	     /* 		     */

/*{BOOL boTest=boTestModus_g; boTestModus_g=JA;
  Wi_TestPrintf(pWkbInfo_g,"\napstrDatei[%d]=%s", i, apstrDatei[i]);
  boTestModus_g=boTest;}*/

      Dl_ErrorHandler(wRetCode, strError, _F, _L, 0);/* 		     */

      if (awInitRecLen)
        awInitRecLen[i] = awRecLen[i];

      if(apstrRecord)
	Ut_Calloc(apstrRecord[i], awRecLen[i], CHAR);
     } /* end for */

  Ut_Free(pD);
  } /* end if */

*pwNbFile = i;

for(j=0; *pTextBox[j]; j++)
  for(i=0; pTextBox[j][i]; i++)
    pTextBox[j][i]->wRecord = awDateiNummer[j][pTextBox[j][i]->wRecord];

{REGISTER j;
for (j=0; j<*pwNbFile; j++)
  awNbRecKeys[j] =
  awNbRefFields[j] =
  awNbRefCopies[j] =
  awNbMatchFields[j]=0; }


for(j=0; *pTextBox[j]; j++)
  {
  for(pInfoLauf_m=apRecInfo_m[j]; pInfoLauf_m;
    pInfoLauf_m=pInfoLauf_m->pNext)
    {
    WORD wDatei=pTextBox[j][pInfoLauf_m->wFeldNr]->wRecord;

     if (pInfoLauf_m->wArt == RECMATCH ||
         pInfoLauf_m->wArt == REFMATCH)
       {
        pInfoLauf_m->wDatei = awDateiNummer[j][pInfoLauf_m->wDatei];
        awNbMatchFields[wDatei]++;
       }
     else if (pInfoLauf_m->wArt == ADDMATCH)
       pInfoLauf_m->wDatei = awDateiNummer[j][pInfoLauf_m->wDatei];
     else if (pInfoLauf_m->wArt == RECKEY)
       awNbRecKeys[wDatei]++;
     else if (pInfoLauf_m->wArt == COPYFIELD)
       awNbRefCopies[wDatei]++;              /* Copy */
     else if (pInfoLauf_m->wArt == REFFIELD)
       if (pTextBox[j][pInfoLauf_m->wFeldNr]->pRefField)
         awNbRefCopies[wDatei]++;            /* Copy */
       else
         awNbRefFields[wDatei]++;            /* No Copy */
    }
  }


{REGISTER i;
for(i=0; i < *pwNbFile; i++)
  {
   if(awNbRefCopies[i])
     Ut_Calloc(pFiles[i].apRefFields, awNbRefCopies[i], PTEXTBOX);

   if(awNbMatchFields[i])
     Ut_Calloc(pFiles[i].aMatch, awNbMatchFields[i], MATCH);

   if(awNbRecKeys[i])
     Ut_Calloc(pFiles[i].apKeys, awNbRecKeys[i], PTEXTBOX);

   if(awNbRecKeys[i])
     Ut_Calloc(pFiles[i].awKeyOffset, awNbRecKeys[i], WORD);

   if(awNbRecKeys[i])
     Ut_Calloc(pFiles[i].awKeyLength, awNbRecKeys[i], WORD);

   pFiles[i].wNbRefFields   = awNbRefCopies[i];
   pFiles[i].wNbRefLooks    = awNbRefFields[i];
   pFiles[i].wNbMatchFields = awNbMatchFields[i];
   pFiles[i].wNbKeyFields   = awNbRecKeys[i];

   awNbRefCopies[i]   = 0;
   awNbMatchFields[i] = 0;
   awNbRecKeys[i]     = 0;
  } }

for(j=0; *pTextBox[j]; j++)
  for(pInfoLauf_m=apRecInfo_m[j], pLastMatch=NULL;
    pInfoLauf_m; pInfoLauf_m=pInfoLauf_m->pNext)
    {
     WORD wRec=pTextBox[j][pInfoLauf_m->wFeldNr]->wRecord;

     switch (pInfoLauf_m->wArt)
       {
        case RECMATCH:
        case REFMATCH:
          {
           WORD wDatei = pInfoLauf_m->wDatei, wI1, wI2, wLaufNb;
           REC_INFO_MC *pLauf;

	   pFiles[wRec].aMatch
               [awNbMatchFields[wRec]].pMatchField =
                 pTextBox[j][pInfoLauf_m->wFeldNr];

	   pFiles[wRec].aMatch
               [awNbMatchFields[wRec]].pstrFieldName =
                 pInfoLauf_m->pstrTxt;

	   pFiles[wRec].aMatch
               [awNbMatchFields[wRec]].wNbAddFields = 0;

           for (wI1=0; *pTextBox[wI1]; wI1++)
             for (wI2=0; pTextBox[wI1][wI2]; wI2++)
               if (pTextBox[wI1][wI2]->wRecord == wDatei &&
                   !strcmp(pTextBox[wI1][wI2]->strDatenfeld, pInfoLauf_m->strDatenfeld))
                 goto ENDE_MATCH;

       ENDE_MATCH:
           for (pLauf=pInfoLauf_m, wLaufNb=0;
                pLauf; pLauf=pLauf->pNext)
             if (pLauf->wArt == ADDMATCH &&
                 pLauf->wFeldNr == pInfoLauf_m->wFeldNr)
               wLaufNb++;

	   pLastMatch = &pFiles[wRec].
                aMatch[awNbMatchFields[wRec]];

           pLastMatch->wNbAddFields = 0;

           if (wLaufNb)
             {
	      Ut_Calloc(pLastMatch->apAddField, wLaufNb, PTEXTBOX);
	      Ut_Calloc(pLastMatch->apstrAddName, wLaufNb, PSTR);
             }
           else
             {
              pLastMatch->apAddField = NULL;
              pLastMatch->apstrAddName = NULL;
             }

	   pFiles[wRec].aMatch
               [awNbMatchFields[wRec]].ppKey = (VOID*) pTextBox[wI1][wI2];

           awNbMatchFields[wRec]++;
          }
          break;

        case ADDMATCH:
          if (!pLastMatch)
            break;
          else
            {
             PSTR pstrFeld = pInfoLauf_m->strDatenfeld;
             WORD wDatei = pInfoLauf_m->wDatei,
                  wNb = pLastMatch->wNbAddFields,
                  wI1, wI2;

             pLastMatch->apstrAddName[wNb] = pInfoLauf_m->pstrTxt;

             for (wI1=0; *pTextBox[wI1]; wI1++)
               for (wI2=0; pTextBox[wI1][wI2]; wI2++)
                 if (pTextBox[wI1][wI2]->wRecord == wDatei &&
                     !strcmp(pTextBox[wI1][wI2]->strDatenfeld, pstrFeld))
                   goto ENDE_ADD;

         ENDE_ADD:
             pLastMatch->apAddField[wNb] = pTextBox[wI1][wI2];

             pLastMatch->wNbAddFields++;
            }
          break;

        case RECKEY:
          {
           WORD wNb = awNbRecKeys[wRec];

	   pFiles[wRec].apKeys[wNb] =
                  pTextBox[j][pInfoLauf_m->wFeldNr];

	   pFiles[wRec].awKeyOffset[wNb] =
                  pTextBox[j][pInfoLauf_m->wFeldNr]->wOffset;

	   pFiles[wRec].awKeyLength[wNb] =
                  pTextBox[j][pInfoLauf_m->wFeldNr]->wMaxL;

           awNbRecKeys[wRec]++;
          }
          break;

        case REFFIELD:
          if (pTextBox[j][pInfoLauf_m->wFeldNr]->pRefField)
            {
             WORD wNb = awNbRefCopies[wRec];

	     pFiles[wRec].apRefFields[wNb] =
                    pTextBox[j][pInfoLauf_m->wFeldNr];

             awNbRefCopies[wRec]++;
            }
          break;

        case COPYFIELD:
          /*if (pTextBox[j][pInfoLauf_m->wFeldNr]->pRefField)*/
            {
             WORD wNb = awNbRefCopies[wRec];

	     pFiles[wRec].apRefFields[wNb] =
                    pTextBox[j][pInfoLauf_m->wFeldNr];

             awNbRefCopies[wRec]++;
            }
          break;

        default:
          break;
       }

    }

for(j=0; *pTextBox[j]; j++)
  {
  for(pRecInfo=apRecInfo_m[j]; pRecInfo; pRecInfo=pRecInfo->pNext)
    {pInfoLauf_m=pRecInfo;
    Ut_Free(pInfoLauf_m);}

  Ut_Free(apRecInfo_m[j]);
  }

{REGISTER i, j, k, l;
for(i=0; i < *pwNbFile; i++)
  for(j=0; j<pFiles[i].wNbMatchFields; j++)
    for(l=0; l < *pwNbFile; l++)
      for(k=0; k<pFiles[l].wNbKeyFields; k++)
	if((VOID*)pFiles[l].apKeys[k] ==
	  (VOID*)pFiles[i].aMatch[j].ppKey)
	  {
	  Wi_TestPrintf(pWkbInfo_g,
	    "\npFiles[%d].aMatch[%d].ppKey=&pFiles[%d].apKeys[%d].",i,j,l,k);

	  pFiles[i].aMatch[j].ppKey = &pFiles[l].apKeys[k];
          l=*pwNbFile;
	  k=pFiles[l].wNbKeyFields;
	  } }

Dl_Nachricht( NULL, 32, 12);                         /* Nachricht löschen    */
return (wRetCode);
}  /* end M_Init */


/*╔══════════════════════════════════════════════════════════════════════════╗
  ║  Funktionsname:    SetTextBox                                            ║
  Ã──────────────────────────────────────────────────────────────────────────Â
  ║                                                                          ║
  ║  Beschreibung:     Diese Funktion                                        ║
  ║                                                                          ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
STATIC
PTEXTBOX SetTextBox(PTEXTBOX pT, WORD wAttri, WORD wFensterS, WORD wFensterZ,
                WORD wFensterB, WORD wCursorS, WORD wMaxL, BOOL boInsert,
		WORD wSequenz, WORD wModus, WORD wRecord, WORD wOffset)
{
Ut_Calloc(pT, 1, TEXTBOX);

pT->wAttri    = wAttri;                     /* Initialisieren           */
pT->wFensterS = wFensterS;
pT->wFensterZ = wFensterZ;
pT->wFensterB = wFensterB;
pT->wCursorS  = wCursorS;
pT->wMaxL     = wMaxL;
pT->boInsert  = boInsert;
pT->wSequenz  = wSequenz;
pT->wModus    = wModus;
pT->wRecord   = wRecord;
pT->wOffset   = wOffset;

return(pT);
}


/*╔══════════════════════════════════════════════════════════════════════════╗
  ║  Funktionsname:    Aufraeumen  -  Verstecken                             ║
  Ã──────────────────────────────────────────────────────────────────────────Â
  ║                                                                          ║
  ║  Beschreibung:     Diese Funktion wird nach Eingabe von ESC auf-         ║
  ║                    gerufen und ruft für alle noch vorhandenen            ║
  ║                    Windows die Funktion Wi_Verstecken() auf.             ║
  ║                                                                          ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
WORD M_Verstecken (PWKB apWkbMask[], WORD wMaxFenster)
{
WORD wRetCode;
REGISTER i;
PWKB pWkb;

    while ( (pWkb=Wi_GetAktivPwkb()) != NULL )      /* zuerst alle aktiven  */
    {                                               /* Windows entfernen    */
        wRetCode = Wi_Verstecken(pWkb);
        for (i=0;                                   /* Index in pwkbArray[] */
            i<=wMaxFenster && pWkb != apWkbMask[i]; /* bestimmen            */
            i++)
            ;
        /* apWkbMask[i] = NULL;                     /* Zeiger löschen       */
    }


    for (i=0; i <= wMaxFenster; i++)                /* jetzt noch die ver-  */
        if (apWkbMask[i] != NULL)                   /* steckten Windows ent-*/
            wRetCode = Wi_Verstecken(apWkbMask[i]); /* fernen               */


return(wRetCode);
}


/*╔══════════════════════════════════════════════════════════════════════════╗
  ║  Funktionsname:    Aufraeumen - Entfernen                                ║
  Ã──────────────────────────────────────────────────────────────────────────Â
  ║                                                                          ║
  ║  Beschreibung:     Diese Funktion wird bei Programmende auf-             ║
  ║                    gerufen und ruft für alle noch vorhandenen            ║
  ║                    Windows die Funktion Wi_Entfernen() auf.              ║
  ║                                                                          ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
WORD M_Close (PWKB apWkbMask[], WORD wMaxFenster)
{
    WORD wRetCode;
    REGISTER i;
    PWKB pWkb;

    while ( (pWkb=Wi_GetAktivPwkb()) != NULL )      /* zuerst alle aktiven  */
    {                                               /* Windows entfernen    */
        wRetCode = Wi_Entfernen(pWkb);
        for (i=0;                                   /* Index in pwkbArray[] */
            i<=wMaxFenster && pWkb != apWkbMask[i];  /* bestimmen            */
            i++)
            ;
        apWkbMask[i] = NULL;                        /* Zeiger löschen       */
    }


    for (i=0; i <= wMaxFenster; i++)               /* jetzt noch die ver-  */
        if (apWkbMask[i] != NULL)                  /* steckten Windows ent-*/
            wRetCode = Wi_Entfernen(apWkbMask[i]); /* fernen               */

/*system ("cls");*/
return (wRetCode);
}



/*╔══════════════════════════════════════════════════════════════════════════╗
  ║  Funktionsname:    M_CloseInit()                                         ║
  Ã──────────────────────────────────────────────────────────────────────────Â
  ║                                                                          ║
  ║  Beschreibung:     Diese Funktion wird bei Programmende auf-             ║
  ║                    gerufen und ruft für alle noch vorhandenen            ║
  ║                                                                          ║
  ╚══════════════════════════════════════════════════════════════════════════╝*/
GLOBAL
WORD M_CloseInit(PWKB	  apWkbMask[],
		 PSTR apstrMaskText[][25], PSTR apstrBrowseText[][25],
		 PTEXTBOX apTextBox[][99], PFILEINFO pFiles, PWORD pwNbFile,
		 PSTR	  apstrFileName[], PSTR     apstrRecord[])
{
REGISTER i, j;
WORD wRetCode, wMaxMask;

for (i=0; apWkbMask[i]; i++)                         /* jetzt noch die ver-  */
    {                                                /* steckten Windows ent-*/
    wRetCode = Wi_Entfernen(apWkbMask[i]);           /* fernen               */
    apWkbMask[i]=NULL;
    wMaxMask = i+1;
    }

/* Wi_TestPrintf(pWkbInfo_g,"\n1:(%d) apstrMaskText=%s apWkbMask=%d "
   "apTextBox=%d \napstrFileName=%s apstrRecord=%s (%d)",
   wMaxMask, apstrMaskText[0][0], apWkbMask[0], apTextBox[0][0],
   apstrFileName[0], apstrRecord[0], wMaxMask); */

for (i=0; i < wMaxMask; i++)
  {
  for(j=0; apstrMaskText[i][j] != NULL; j++)
    Ut_Free(apstrMaskText[i][j]);

  for(j=0; apstrBrowseText[i][j] != NULL; j++)
    Ut_Free(apstrBrowseText[i][j]);

  for(j=0; apTextBox[i][j] != NULL; j++)
     {
     if(apTextBox[i][j]->swRefCode >= 0)
       Ut_Free(apTextBox[i][apTextBox[i][j]->swRefCode]);

     Ut_Free(apTextBox[i][j]);			      /* Masken-Texte	     */
     }
  }

for(i=0; apstrFileName[i]; i++)
   {Ut_Free(apstrFileName[i]);
   Ut_Free(apstrRecord[i]);}

for(i=0; i < *pwNbFile; i++)
  {
  if(pFiles[i].apRefFields)  Ut_Free(pFiles[i].apRefFields);
  if(pFiles[i].aMatch)	     Ut_Free(pFiles[i].aMatch);
  if(pFiles[i].apKeys)	     Ut_Free(pFiles[i].apKeys);
  if(pFiles[i].awKeyOffset)  Ut_Free(pFiles[i].awKeyOffset);
  if(pFiles[i].awKeyLength)  Ut_Free(pFiles[i].awKeyLength);

  pFiles[i].wNbRefFields=pFiles[i].wNbRefLooks=
  pFiles[i].wNbMatchFields=pFiles[i].wNbKeyFields=0;
  }

/*{BOOL boTest=boTestModus_g; boTestModus_g=JA;
  Wi_TestPrintf(pWkbInfo_g,"\napstrFileName[%d]=%d", i, apstrFileName[i]);
  Wi_TestPrintf(pWkbInfo_g,"\napstrRecord[%d]=%d", i, _msize(apstrRecord[i]));
  Ut_Free(apstrFileName[i]);
  Ut_Free(apstrRecord[i]);
  boTestModus_g=boTest;}*/

/* Wi_TestPrintf(pWkbInfo_g,"\n2:apWkbMask=%d apstrMaskText=%d"
   "apTextBox=%d \napstrFileName=%d apstrRecord=%d",
   apWkbMask[0], apstrMaskText[0][0], apTextBox[0][0],
   apstrFileName[0], apstrRecord[0] ); */

if (wVioMode_g == MONOCHROM)
   Wi_SetCursorTyp(11,12);                           /* Linien-Cursor         */
else
   Wi_SetCursorTyp(6,7);
Wi_Cursor(EIN);
return (OK);
}


/*
sprintf (pstrDataBuffer_g, "%sMASK", pstrApp);
strupr (strrev (pstrDataBuffer_g));
for (j=0; j < strlen(pstrDataBuffer_g); j++)
  if (j%2)
    pstrDataBuffer_g[j] = (CHAR) tolower(pstrDataBuffer_g[j]);

Wi_TestPrintf(pWkbInfo_g,   »z.B: KsAmSv für mAsK vS«
     "\npstrDataBuffer_g=%s", pstrDataBuffer_g);
*/


     /* Wi_TestPrintf(pWkbInfo_g,
     "\napstrMaskText[%d][%d]=%s", i, j, apstrMaskText[i][j]); */

     Ut_Free (apstrMaskText[i][j]);
     /*apstrMaskText[i][j]=NULL;*/

     /* Wi_TestPrintf(pWkbInfo_g,
     "\napstrMaskText[%d][%d]=%s", i, j, apstrMaskText[i][j]); */
