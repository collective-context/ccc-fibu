// (C)WINware Software, P.Mayer  Letztes Update am 02-Mar-1996 / 15:24:47 - Sat

/*.ta M_InsertBlock()
ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
บ  M_InsertBlock()                                                             บ
ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ

berblick:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <process.h>
#include <eur_tool.h>


SWORD M_InsertBlock (PMASKS pMask, PSSTR pstrBlockName, SWORD wBlockNummer)


Parameter:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ


Beschreibung:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ


Versorgung:

   Eingang:


   Ausgang:



Rckgabewert:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
SWORD  Fehlerinformation OK/ERROR


Benutzte globale Variablen (R/W):
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
Variablen (R/W):

.te*/

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                         DEKLARATIONS-DATEIEN                             บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
#define NDEBUG 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <process.h>
#include <eur_tool.h>

#define POS_LENGTH 28                /* Lnge der Eintrge im Positionsrecord */


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ         GLOBALE DATEN, DIE AUS DER TOOLBOX IMPORTIERT WERDEN             บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
IMPORT	SWORD wMausda_g;
IMPORT  BOOL boTestModus_g;
IMPORT	PWKB pWkbInfo_g;
IMPORT	ERRINFO errInfo_g;

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                          FUNKTIONS-DEFINITION                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC	VOID i_ManageTBL	  (PMASKS);
STATIC	VOID i_ResolveSequenz	  (PBLOCKS);
STATIC	SWORD i_KopiereBlock	   (PBLOCKS, PINITBLOCKS, PSSTR, PSWORD);
STATIC	SWORD i_KopiereInitTBL	   (PINITBLOCKS, PBLOCKS, PSWORD);
STATIC	VOID i_BSchreibBox	  (PTEXTBOXLIST);
STATIC	VOID i_AdjustRecLength	  (PMASKS, PBLOCKS, PBLOCKS, PSSTR[],
				   SWORD[], PSSTR[], SWORD[], PSSTR);
STATIC	VOID i_SetLastVisualLine  (PMASKS);
STATIC	VOID i_SetLastVisualColumn(PMASKS);
STATIC	SWORD i_InsertBlockY	   (PMASKS, PSSTR, SWORD, SWORD, PSSTR[],
				   SWORD[], PSSTR[], SWORD[], PSSTR, SWORD);
STATIC	VOID i_DeleteBlockY	  (PMASKS, SWORD, SWORD, PSSTR[], SWORD[],
				   PSSTR[], SWORD[], SWORD);
GLOBAL	VOID i_BFormatSchreiben   (PTEXTBOXLIST, PSSTR[]);


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                          FUNKTIONS-DEFINITION                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_BlockMaskAufbau               Datum: 2.1.90       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID M_BlockMaskAufbau (PMASKS pInitMasks, PSSTR apstrRec[],
			SWORD awRecLen[], PSSTR apstrPos[], SWORD awPosLen[])
{
 PSSTR pstrTmp;
 PMASKS pMask;
 SWORD wBlockX, wBlockY, wRec;
 CHAR strBlockName[POS_LENGTH];

 for (pMask=pInitMasks, wRec=0;
      pMask;pMask=pMask->pNext, wRec++)
  if (awPosLen[wRec] >= POS_LENGTH)
    {
     for (pstrTmp=apstrPos[wRec], wBlockX=1, wBlockY=1;
	  (SWORD)(pstrTmp-apstrPos[wRec]) < awPosLen[wRec];
          pstrTmp = strchr (pstrTmp,'\0') + 1, wBlockY++)
       {
       memset(strBlockName, '\0', POS_LENGTH);

       if(*pstrTmp=='\0')
	 Dl_Abbruch("M_BlockMaskAufbau",_L,_F,str("no Blockname"));
       else
	 /*ncpy(strBlockName, pstrTmp, POS_LENGTH-1);*/
	 sscanf(pstrTmp, "%s", strBlockName);

       //boTestModus_g=JA;
       Wi_TestPrintf(pWkbInfo_g, "\nBlock: ฏ%sฎ, "
	 "size/PosLen(%d/%d)\npstrTmp: ฏ%sฎ",
	 strBlockName, _msize(apstrPos[wRec]), awPosLen[wRec], pstrTmp);
       //boTestModus_g=NEIN;

       i_InsertBlockY (pMask, strBlockName, wBlockX, wBlockY,
                        apstrRec, awRecLen, apstrPos, awPosLen,
                        "INSERT_Y_NEW_MASK", 0);

       }

     M_SetVisualBlock (pMask, 1, 1);
    }

 return;
}



/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_ExchangeBlock                Datum:16.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID M_ExchangeBlock (PMASKS pMask, PBLOCKCOLUMN pColumn,
                      PBLOCKLINE pLine,
		      PBLOCKS* ppBlock, PSSTR pstrBlockName,
		      PSSTR apstrRecord[], SWORD awRecLen[],
		      PSSTR apstrPosition[], SWORD awPosLen[])
{
 PBLOCKS pBl2=NULL, pBlock = *ppBlock;
 PINITBLOCKS pBlInit;
 PTEXTBOXLIST pTBL;
 SWORD	 wDiff;


 for (pBlInit = pMask->pBlInitWurzel;
      pBlInit && strcmp (pBlInit->pstrBlockName, pstrBlockName);
      pBlInit = pBlInit->pNext)
    ;

 if (!pBlInit)
   {
    system ("cls");                             /* nur temporr, zu ersetzen */
    printf ("\n\n\nUnbekannter Blockname %s in ExchangeBlock\n", pstrBlockName);
    E(); exit(-1);				/* ev. weitere Errorinfo */
   }

 Ut_Calloc(pBl2, 1, BLOCKS);
 pBl2->wBlSignatur = BLOCKSIGNATUR;

 i_KopiereBlock (pBl2, pBlInit, "EXCHANGE", NULL);

 pBl2->wBlockX = pBlock->wBlockX;
 pBl2->wBlockY = pBlock->wBlockY;
 pBl2->wBlockSpalte = pBlock->wBlockSpalte;
 pBl2->wBlockZeile = pBlock->wBlockZeile;

 wDiff = pBl2->wBlockBreite - pColumn->wMaxBreite;

 if (wDiff > 0)
   {
    PBLOCKCOLUMN pC1;
    PBLOCKS      pB1;

    pColumn->wMaxBreite += wDiff;

    for (pC1=pColumn->pNext; pC1; pC1=pC1->pNext)
      {
       pC1->wPhysicalColumn += wDiff;

       for (pB1=pC1->pBlWurzel; pB1; pB1=pB1->pNextLine)
         pB1->wBlockSpalte = pC1->wPhysicalColumn;
      }
   }
 else if (pColumn->pBlWurzel == pColumn->pBlEnd)
   pColumn->wMaxBreite = pBl2->wBlockBreite;

 wDiff = pBl2->wBlockHoehe - pLine->wMaxHoehe;

 if (wDiff > 0)
   {
    PBLOCKLINE   pL1;
    PBLOCKS      pB1;

    pLine->wMaxHoehe += wDiff;

    for (pL1=pLine->pNext; pL1; pL1=pL1->pNext)
      {
       pL1->wPhysicalLine += wDiff;

       for (pB1=pL1->pBlWurzel; pB1; pB1=pB1->pNextColumn)
         pB1->wBlockZeile = pL1->wPhysicalLine;
      }
   }
 else if (pLine->pBlWurzel == pLine->pBlEnd)
   pLine->wMaxHoehe = pBl2->wBlockHoehe;


 /* Korrektur der Dateigroessen */

 pBl2->wBlockOffset = pBlock->wBlockOffset;


 i_AdjustRecLength (pMask, pBl2, pBlock,
                    apstrRecord, awRecLen,
                    apstrPosition, awPosLen, "EXCHANGE");


 /* Die folgende for-Schleife ist nur fr Masken mit nur einer Spalte korrekt,*/
 /* da sie nur die Offsetwerte der aktuellen Blockspalte korrigiert.          */
 /* Ebenso wie i_AdjustRecLength() muแ sie noch korrigiert werden !!!!        */

 wDiff = pBl2->wBlockLength - pBlock->wBlockLength;

 if (wDiff && pLine->pNext)
   {
    PBLOCKS pB1;

    for (pB1=pLine->pNext->pBlWurzel; pB1; pB1=pB1->pNextLine)
      pB1->wBlockOffset += wDiff;
   }

 if (pBlock->pNextColumn)
   pBlock->pNextColumn->pLastColumn = pBl2;

 if (pBlock->pLastColumn)
   pBlock->pLastColumn->pNextColumn = pBl2;

 if (pBlock->pNextLine)
   pBlock->pNextLine->pLastLine = pBl2;

 if (pBlock->pLastLine)
   pBlock->pLastLine->pNextLine = pBl2;

 pBl2->pNextColumn = pBlock->pNextColumn;
 pBl2->pLastColumn = pBlock->pLastColumn;
 pBl2->pNextLine = pBlock->pNextLine;
 pBl2->pLastLine = pBlock->pLastLine;

 if(pLine->pBlWurzel==pBlock)
   pLine->pBlWurzel=pBl2;

 if(pLine->pBlEnd==pBlock)
   pLine->pBlEnd=pBl2;

 if(pColumn->pBlWurzel==pBlock)
   pColumn->pBlWurzel=pBl2;

 if(pColumn->pBlEnd==pBlock)
   pColumn->pBlEnd=pBl2;

 for(pTBL=pBlock->pTBLWurzel; pTBL; pTBL=pTBL->pNext)
  {
  PTEXTBOXLIST pT=pTBL;
  if(pTBL->pRefField)
    {
    Ut_Free(pTBL->pRefField->pstrText);
    Ut_Free(pTBL->pRefField);
    }

  Ut_Free(pTBL->pstrText);
  Ut_Free(pT);
  }

 Ut_Free(pBlock->pstrBlockName);
 Ut_Free(pBlock);

 M_SetVisualBlock (pMask, pBl2->wBlockX, pBl2->wBlockY);

 *ppBlock = pBl2;

 return;
}

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_InsertBlockX                 Datum: 4.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/

#ifdef FULLVERSION

GLOBAL
SWORD M_InsertBlockX (PMASKS pMask, PSSTR pstrBlockName,
		     SWORD wBlockX, SWORD wBlockY, PSSTR apstrRecord[],
		     SWORD awRecLen[], PSSTR apstrPosition[],
		     SWORD awPosLen[])
{
 return (OK);
}

#endif

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_DeleteAllBlocks              Datum:20.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID M_DeleteAllBlocks(PMASKS pMask)
{
PBLOCKCOLUMN pColumn;
PBLOCKLINE   pLine;
PBLOCKS      pBlock;
PTEXTBOXLIST pTBL;

for(pColumn=pMask->pBlColumnEnd; pColumn &&
  strcmp(pColumn->pBlWurzel->pstrBlockName, "(null)");
  pColumn=pColumn->pLast)
  {PBLOCKCOLUMN pC=pColumn;
  Ut_Free(pC);}

pMask->pBlColumnWurzel=pMask->pBlColumnEnd=pColumn;

for(pLine=pMask->pBlLineEnd; pLine &&
  strcmp(pLine->pBlWurzel->pstrBlockName, "(null)");
  pLine=pLine->pLast)
  {
  PBLOCKLINE pL=pLine;
  for(pBlock=pLine->pBlWurzel; pBlock;pBlock=pBlock->pNextColumn)
    {
    PBLOCKS pB=pBlock;
    for(pTBL=pBlock->pTBLWurzel; pTBL; pTBL=pTBL->pNext)
      {
      PTEXTBOXLIST pT=pTBL;
      if(pTBL->pRefField)
	{
	Ut_Free(pTBL->pRefField->pstrText);
	Ut_Free(pTBL->pRefField);
	}

      Ut_Free(pTBL->pstrText);
      Ut_Free(pT);
      }

    Ut_Free(pBlock->pstrBlockName);
    Ut_Free(pB);
    }  /* End Block  */

  Ut_Free(pL);
  } /* End Line   */

 pMask->pBlLineWurzel =
 pMask->pBlLineEnd    = pLine;

 pMask->pBlAktSpalte     =
 pMask->pBlAlteSpalte    =
 pMask->pBlLastSpalte    =
 pMask->pBlOldLastSpalte = NULL;

 pMask->pBlAktZeile      =
 pMask->pBlAlteZeile     =
 pMask->pBlLastZeile     =
 pMask->pBlOldLastZeile  = NULL;

 if (pMask->pBlColumnWurzel)
   pMask->pBlColumnWurzel->pNext = NULL;

 if (pMask->pBlLineWurzel)
   pMask->pBlLineWurzel->pNext   = NULL;

 pMask->boWriteBlocks = JA;

 return;
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_DeleteBlockY                 Datum:19.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID M_DeleteBlockY (PMASKS pMask, SWORD wBlockX, SWORD wBlockY,
		     PSSTR apstrRecord[], SWORD awRecLen[],
		     PSSTR apstrPosition[], SWORD awPosLen[])
{

i_DeleteBlockY (pMask, wBlockX, wBlockY, apstrRecord,
                awRecLen, apstrPosition, awPosLen, 1);

return;
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_DelNotVisualBlockY           Datum:19.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID M_DelNotVisualBlockY (PMASKS pMask, SWORD wBlockX, SWORD wBlockY,
		     PSSTR apstrRecord[], SWORD awRecLen[],
		     PSSTR apstrPosition[], SWORD awPosLen[])
{

i_DeleteBlockY (pMask, wBlockX, wBlockY, apstrRecord,
                awRecLen, apstrPosition, awPosLen, 0);

return;
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_DeleteBlockY                 Datum:19.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_DeleteBlockY (PMASKS pMask, SWORD wBlockX, SWORD wBlockY,
		     PSSTR apstrRecord[], SWORD awRecLen[],
		     PSSTR apstrPosition[], SWORD awPosLen[], SWORD wMode)
{
PBLOCKS pBl1, pBl2;
PBLOCKLINE pLine1;
PBLOCKCOLUMN pColumn1;
PTEXTBOXLIST pTBL;

for(pLine1=pMask->pBlLineWurzel;
  pLine1 && pLine1->wLogicalLine != wBlockY;
  pLine1=pLine1->pNext)
  ;

if(!pLine1)
  {
  system("cls");			       /* nur temporr, zu ersetzen */
  printf("\n\n\nUngltige Blockzeilennummer %d in DeleteBlock\n", wBlockY);
  E(); exit (-1);				       /* ev. weitere Errorinfo */
  }

for(pColumn1=pMask->pBlColumnWurzel;
  pColumn1 && pColumn1->wLogicalColumn != wBlockX;
  pColumn1=pColumn1->pNext)
  ;

if(!pColumn1)
  {
  system ("cls");			      /* nur temporr, zu ersetzen */
  printf ("\n\n\nUngltige Blockspaltennummer %d in DeleteBlock\n", wBlockX);
  E(); exit (-1);				       /* ev. weitere Errorinfo */
  }

for(pBl1=pLine1->pBlWurzel;
  pBl1 && pBl1->wBlockX != pColumn1->wLogicalColumn;
  pBl1=pBl1->pNextColumn)
  ;

if(!pBl1)
  {
  system("cls");			     /* nur temporr, zu ersetzen */
  printf ("\n\n\nKein Block an Position X=%d/Y=%d in DeleteBlock\n", wBlockX, wBlockY);
  E(); exit (-1);				       /* ev. weitere Errorinfo */
  }

i_AdjustRecLength (pMask, pBl1, pBl1, apstrRecord,
  awRecLen, apstrPosition, awPosLen, "DELETE_Y");

/* Die folgende for-Schleife ist nur fr Masken mit nur einer Spalte korrekt,*/
/* da sie nur die Offsetwerte der aktuellen Blockspalte korrigiert.	     */
/* Ebenso wie i_AdjustRecLength() muแ sie noch korrigiert werden !!!!	     */

for(pBl2=pBl1->pNextLine; pBl2; pBl2=pBl2->pNextLine)
  pBl2->wBlockOffset -= pBl1->wBlockLength;

if(pColumn1->pBlWurzel==pBl1)
  pColumn1->pBlWurzel=pBl1->pNextLine;

if(pColumn1->pBlEnd==pBl1)
  pColumn1->pBlEnd=pBl1->pLastLine;

if(pLine1->pBlWurzel==pBl1)
  pLine1->pBlWurzel=pBl1->pNextColumn;

if(pLine1->pBlEnd==pBl1)
  pLine1->pBlEnd=pBl1->pLastColumn;

if(pBl1->pLastColumn)
  pBl1->pLastColumn->pNextColumn=pBl1->pNextColumn;

if(pBl1->pNextColumn)
  pBl1->pNextColumn->pLastColumn=pBl1->pLastColumn;

if(pBl1->pLastLine)
  pBl1->pLastLine->pNextLine=pBl1->pNextLine;

if(pBl1->pNextLine)
  pBl1->pNextLine->pLastLine=pBl1->pLastLine;

for(pTBL=pBl1->pTBLWurzel; pTBL; pTBL=pTBL->pNext)
  {
  PTEXTBOXLIST pT=pTBL;
  if(pTBL->pRefField)
    {
    Ut_Free(pTBL->pRefField->pstrText);
    Ut_Free(pTBL->pRefField);
    }

  Ut_Free(pTBL->pstrText);
  Ut_Free(pT);
  }

Ut_Free(pBl1->pstrBlockName);
Ut_Free(pBl1);

if(!pLine1->pBlWurzel)
  {
  PBLOCKLINE pL;
  if(pMask->pBlLineWurzel==pLine1)
    pMask->pBlLineWurzel=pLine1->pNext;

  if(pMask->pBlLineEnd==pLine1)
    pMask->pBlLineEnd=pLine1->pLast;

  if(pMask->pBlAktZeile==pLine1)
    if(pLine1->pNext)
      pMask->pBlAktZeile=pLine1->pNext;
    else if (pLine1->pLast)
      pMask->pBlAktZeile=pLine1->pLast;
    else
      pMask->pBlAktZeile=NULL;

  if(pMask->pBlAlteZeile==pLine1)
    pMask->pBlAlteZeile=pMask->pBlAktZeile;

  if(pMask->pBlLastZeile==pLine1)
    if(pLine1->pNext)
      pMask->pBlLastZeile=pLine1->pNext;
    else if (pLine1->pLast)
      pMask->pBlLastZeile=pLine1->pLast;
    else
      pMask->pBlLastZeile=NULL;

  if(pMask->pBlOldLastZeile==pLine1)
    pMask->pBlOldLastZeile=pMask->pBlLastZeile;

  if(pLine1->pNext)
    {
    PBLOCKLINE pLine2;
    PBLOCKS pBl2;
    pLine1->pNext->pLast=pLine1->pLast;

    for(pLine2=pLine1->pNext; pLine2; pLine2=pLine2->pNext)
      {
      pLine2->wPhysicalLine -= pLine1->wMaxHoehe;
      pLine2->wLogicalLine--;

      for(pBl2=pLine2->pBlWurzel; pBl2; pBl2=pBl2->pNextColumn)
	 {
	 pBl2->wBlockY = pLine2->wLogicalLine;
	 pBl2->wBlockZeile = pLine2->wPhysicalLine;
	 }
      }
    }

  if(pLine1->pLast)
    pLine1->pLast->pNext=pLine1->pNext;

  pL=pLine1;
  Ut_Free(pL);

  if(wMode)
    {
    i_SetLastVisualLine(pMask);
    i_ManageTBL(pMask);
    }
  }


if(!pColumn1->pBlWurzel)
  {
  PBLOCKCOLUMN pC;
  if(pMask->pBlColumnWurzel==pColumn1)
    pMask->pBlColumnWurzel=pColumn1->pNext;

  if(pMask->pBlColumnEnd==pColumn1)
    pMask->pBlColumnEnd=pColumn1->pLast;

  if(pColumn1->pNext)
    pColumn1->pNext->pLast=pColumn1->pLast;

  if(pColumn1->pLast)
    pColumn1->pLast->pNext=pColumn1->pNext;

  pC=pColumn1;
  Ut_Free(pC);
  }

return;
}

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_InsertBlockY                 Datum: 4.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
SWORD M_InsertBlockY (PMASKS pMask, PSSTR pstrBlockName,
		     SWORD wBlockX, SWORD wBlockY, PSSTR apstrRecord[],
		     SWORD awRecLen[], PSSTR apstrPosition[],
		     SWORD awPosLen[])
{
 return (i_InsertBlockY (pMask, pstrBlockName, wBlockX, wBlockY,
                         apstrRecord, awRecLen,
                         apstrPosition, awPosLen, "INSERT_Y_KORR_POS", 1));
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_InsNotVisualBlockY           Datum: 4.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
SWORD M_InsNotVisualBlockY (PMASKS pMask, PSSTR pstrBlockName,
		     SWORD wBlockX, SWORD wBlockY, PSSTR apstrRecord[],
		     SWORD awRecLen[], PSSTR apstrPosition[],
		     SWORD awPosLen[])
{
 return (i_InsertBlockY (pMask, pstrBlockName, wBlockX, wBlockY,
                         apstrRecord, awRecLen,
                         apstrPosition, awPosLen, "INSERT_Y_KORR_POS", 0));
}



/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_InsertBlockY                     Datum: 5.1.1990    บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
SWORD i_InsertBlockY (PMASKS pMask, PSSTR pstrBlockName,
		     SWORD wBlockX, SWORD wBlockY, PSSTR apstrRecord[],
		     SWORD awRecLen[], PSSTR apstrPosition[],
		     SWORD awPosLen[], PSSTR pstrMode, SWORD wMode)
{
 PBLOCKS pBl1, pBl2=NULL;
 PINITBLOCKS pBlInit;
 PBLOCKLINE pLine1, pLine2=NULL;
 PBLOCKCOLUMN pColumn1, pColumn2=NULL;
 SWORD i=0;

 for (pBlInit = pMask->pBlInitWurzel;
      pBlInit && strcmp (pBlInit->pstrBlockName, pstrBlockName);
      pBlInit = pBlInit->pNext)
    ;

 if(!pBlInit)
   Dl_Abbruch("InsertBlockY",_L,_F,str("NO Block: %s", pstrBlockName));


 for (pLine1 = pMask->pBlLineWurzel;
      pLine1 && pLine1->wLogicalLine < wBlockY-1;
      pLine1=pLine1->pNext)
    ;

 if(!pLine1)	  /* Ungltige Blockzeilennummer %d in InsertBlock */
   Dl_Abbruch("InsertBlockY",_L,_F,str("no Line: %d", wBlockY));

 for (pColumn1 = pMask->pBlColumnWurzel;
      pColumn1 && pColumn1->wLogicalColumn < wBlockX-1;
      pColumn1=pColumn1->pNext)
    ;

 if (!pColumn1)    /* Ungltige Blockspaltennummer %d in InsertBlock */
   Dl_Abbruch("InsertBlockY",_L,_F,str("no Column: %d", wBlockX));

 if (pColumn1->pNext)
   pColumn1=pColumn1->pNext;
 else
   {
    Ut_Calloc(pColumn2, 1, BLOCKCOLUMN);
    pColumn2->wColumnSignatur = COLUMNSIGNATUR;

    pColumn2->wLogicalColumn = wBlockX;
    pColumn2->wPhysicalColumn = pColumn1->wPhysicalColumn+
                                pColumn1->wMaxBreite;

    pColumn2->pBlWurzel = NULL;
    pColumn2->pBlEnd = NULL;
    pColumn2->pNext = NULL;
    pColumn2->pLast = pColumn1;

    pColumn1->pNext = pColumn2;
    pMask->pBlColumnEnd = pColumn2;

    if (pMask->pBlAktSpalte &&
        pMask->pBlAktSpalte->wPhysicalColumn +
        pMask->wScrollBreite >
        pColumn2->wPhysicalColumn +
        pColumn2->wMaxBreite ||
        pMask->pBlLastSpalte)
      pMask->pBlLastSpalte = pColumn2;

    pColumn1 = pColumn2;
   }

 Ut_Calloc(pBl2, 1, BLOCKS);
 pBl2->wBlSignatur = BLOCKSIGNATUR;

 i_KopiereBlock (pBl2, pBlInit, pstrMode, NULL);

 pBl2->wBlockX = wBlockX;
 pBl2->wBlockY = wBlockY;

 i_AdjustRecLength (pMask, pBl2, pBl2, apstrRecord, awRecLen,
                    apstrPosition, awPosLen, pstrMode);

 pBl2->pNextColumn  = NULL;
 pBl2->pNextLine    = NULL;
 pBl2->pLastColumn  = NULL;
 pBl2->pLastLine    = NULL;

 Ut_Calloc(pLine2, 1, BLOCKLINE);
 pLine2->wLineSignatur = LINESIGNATUR;

 pLine2->wLogicalLine = wBlockY;
 pLine2->wPhysicalLine = pLine1->wPhysicalLine+pLine1->wMaxHoehe;
 pLine2->wMaxHoehe = pBl2->wBlockHoehe;
 pLine2->pBlWurzel = pBl2;
 pLine2->pBlEnd = pBl2;
 pLine2->pNext = pLine1->pNext;
 pLine2->pLast = pLine1;

 if (pLine1->pNext)
   pLine1->pNext->pLast = pLine2;
 else
   pMask->pBlLineEnd = pLine2;

 pLine1->pNext = pLine2;

 if (pColumn1->pBlWurzel && wBlockY != 1)
   {

    for (pBl1=pColumn1->pBlWurzel;
         pBl1 && pBl1->wBlockY < wBlockY-1;
         pBl1=pBl1->pNextLine)
      ;

    pBl2->pNextLine = pBl1->pNextLine;
    pBl2->pLastLine = pBl1;

    if (pBl1->pNextLine)
      pBl1->pNextLine->pLastLine = pBl2;
    else
      pColumn1->pBlEnd = pBl2;

    pBl1->pNextLine = pBl2;
   }
 else if (wBlockY == 1 && pColumn1->pBlWurzel)
   {
    pBl2->pNextLine = pColumn1->pBlWurzel;
    pBl2->pLastLine = NULL;
    pColumn1->pBlWurzel->pLastLine = pBl2;
    pColumn1->pBlWurzel = pBl2;
   }
 else
   {
    pColumn1->pBlWurzel = pBl2;
    pColumn1->pBlEnd = pBl2;

    pMask->pBlAktSpalte  = pColumn1;
    pMask->pBlAlteSpalte = pColumn1;
    pMask->pBlLastSpalte = pColumn1;
    pMask->pBlOldLastSpalte = pColumn1;
    pMask->pBlAktZeile   = pLine2;
    pMask->pBlAlteZeile  = pLine2;
    pMask->pBlLastZeile  = pLine2;
    pMask->pBlOldLastZeile  = pLine2;

    pBl2->pNextLine = NULL;
    pBl2->pLastLine = NULL;
   }

 /* Die folgende for-Schleife ist nur fr Masken mit nur einer Spalte korrekt,*/
 /* da sie nur die Offsetwerte der aktuellen Blockspalte korrigiert.          */
 /* Ebenso wie i_AdjustRecLength() muแ sie noch korrigiert werden !!!!        */

 if (!strcmp(pstrMode, "INSERT_Y_KORR_POS"))
   for (pBl1=pBl2->pNextLine; pBl1; pBl1=pBl1->pNextLine)
     pBl1->wBlockOffset += pBl2->wBlockLength;


 for (pLine1=pLine2->pNext, pBl1=pBl2->pNextLine;
      pLine1;pLine1=pLine1->pNext)
   {
    pLine1->wLogicalLine++;
    pLine1->wPhysicalLine += pLine2->wMaxHoehe;

    if (pBl1)
      {
       pBl1->wBlockZeile = pLine1->wPhysicalLine;
       pBl1=pBl1->pNextLine;
      }
   }

 for (pColumn1=pMask->pBlColumnWurzel;
      pColumn1;pColumn1=pColumn1->pNext)
   for (pBl1=pColumn1->pBlWurzel;
        pBl1;pBl1=pBl1->pNextLine)
     {
      pBl1->wBlockX = pColumn1->wLogicalColumn;
      pBl1->wBlockSpalte = pColumn1->wPhysicalColumn;
     }


 for (pLine1=pMask->pBlLineWurzel;
      pLine1;pLine1=pLine1->pNext)
   for (pBl1=pLine1->pBlWurzel;
        pBl1;pBl1=pBl1->pNextColumn)
     {
      pBl1->wBlockY = pLine1->wLogicalLine;
      pBl1->wBlockZeile = pLine1->wPhysicalLine;
     }

 if (wMode)
   M_SetVisualBlock (pMask, wBlockX, wBlockY);

 return (OK);
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_InsertFixBlock               Datum: 4.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion darf nur im Tool, und zwar in          บ
  บ                    der Funktion M_BInit aufgerufen werden.             บ
  บ                    Die Funktion kopiert den fixen Teil einer           บ
  บ                    Maske aus der initialisierten Liste in              บ
  บ                    den aktuellen Teil der Blockliste.                  บ
  บ                    Ein nochmaliger Aufruf dieser Funktion              บ
  บ                    (auแerhalb von M_BInit) wrde zwangslufig          บ
  บ                    dazu fhren, daแ reservierter Speicher fr          บ
  บ                    immer verlorenginge, da die Funktion keine          บ
  บ                    Test durchfhrt, ob Sie schon einmal                บ
  บ                    aufgerufen worden ist.                              บ
  บ                                                                        บ
  บ  Rckgabewert:     Rckgabewert ist eine Fehlerinformation.            บ
  บ                    (Zur Zeit (noch) nicht implementiert.)              บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
SWORD M_InsertFixBlock(PMASKS pMask, PSSTR pstrBlockName, SWORD awFixBlLen[])
{
PBLOCKS pBlHelp2=NULL;
PINITBLOCKS pBlInit;
PBLOCKLINE pLine1=NULL;
PBLOCKCOLUMN pColumn1=NULL;

for(pBlInit=pMask->pBlInitWurzel;
   pBlInit && strcmp(pBlInit->pstrBlockName, pstrBlockName);
   pBlInit=pBlInit->pNext)
   ;

if(!pBlInit)
  Dl_Abbruch("Blockname", _L, _F, str("ฏ%sฎ",pstrBlockName));

Ut_Calloc(pBlHelp2, 1, BLOCKS);
pBlHelp2->wBlSignatur = BLOCKSIGNATUR;
i_KopiereBlock(pBlHelp2, pBlInit, "FIX_BLOCK", awFixBlLen);

pBlHelp2->wBlockX     = pBlHelp2->wBlockY = 0;
pBlHelp2->pNextLine   = pBlHelp2->pLastLine = NULL;
pBlHelp2->pNextColumn = pBlHelp2->pLastColumn = NULL;

Ut_Calloc(pLine1, 1, BLOCKLINE);
pLine1->wLineSignatur = LINESIGNATUR;

pLine1->wLogicalLine = pLine1->wPhysicalLine = pLine1->wMaxHoehe = 0;
pLine1->pNext	     = pLine1->pLast	 = NULL;
pLine1->pBlWurzel    = pLine1->pBlEnd	 = pBlHelp2;
pMask->pBlLineWurzel = pMask->pBlLineEnd = pLine1;

Ut_Calloc(pColumn1, 1, BLOCKCOLUMN);
pColumn1->wColumnSignatur = COLUMNSIGNATUR;

pColumn1->wLogicalColumn = pColumn1->wPhysicalColumn = pColumn1->wMaxBreite = 0;
pColumn1->pNext 	 = pColumn1->pLast     = NULL;
pColumn1->pBlWurzel	 = pColumn1->pBlEnd    = pBlHelp2;
pMask->pBlLineWurzel	 = pMask->pBlLineEnd   = pLine1;
pMask->pBlColumnWurzel	 = pMask->pBlColumnEnd = pColumn1;
pMask->awFixBlockLength  = awFixBlLen;

i_ResolveSequenz(pBlHelp2);

return (OK);
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_SetVisualBlock()             Datum: 4.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID M_SetVisualBlock (PMASKS pMask, SWORD wBlockX, SWORD wBlockY)
{
 PBLOCKCOLUMN pColumn;
 PBLOCKLINE   pLine;

 if (!wBlockX || !wBlockY)                  /* Fixer Block immer sichtbar !! */
   return;

 i_SetLastVisualColumn (pMask);
 i_SetLastVisualLine   (pMask);

 if (!pMask->pBlAlteZeile)
   pMask->pBlAlteZeile = pMask->pBlAktZeile;

 if (!pMask->pBlOldLastZeile)
   pMask->pBlOldLastZeile = pMask->pBlLastZeile;

 for (pColumn=pMask->pBlColumnWurzel;
      pColumn && pColumn->wLogicalColumn != wBlockX;
      pColumn=pColumn->pNext)
    ;

 for (pLine=pMask->pBlLineWurzel;
      pLine && pLine->wLogicalLine != wBlockY;
      pLine=pLine->pNext)
    ;

 if (!pColumn)
   {
    system ("cls");                             /* nur temporr, zu ersetzen */
    printf ("\n\n\nUngltige Blockspaltennummer %d in InsertBlock\n", wBlockX);
    E(); exit (-1);					 /* ev. weitere Errorinfo */
   }

 if (!pLine)
   {
    system ("cls");                             /* nur temporr, zu ersetzen */
    printf ("\n\n\nUngltige Blockzeilennummer %d in InsertBlock\n", wBlockY);
    E(); exit (-1);					 /* ev. weitere Errorinfo */
   }

 if (pMask->pBlAktSpalte->wLogicalColumn > wBlockX)
   while (pMask->pBlAktSpalte->wLogicalColumn > wBlockX)
       pMask->pBlAktSpalte = pMask->pBlAktSpalte->pLast;
 else
   while (pMask->pBlLastSpalte->wPhysicalColumn +
          pMask->pBlLastSpalte->wMaxBreite <
          pColumn->wPhysicalColumn + pColumn->wMaxBreite)
      {
       pMask->pBlAktSpalte = pMask->pBlAktSpalte->pNext;
       i_SetLastVisualColumn (pMask);
      }

 if (pMask->pBlAktZeile->wLogicalLine > wBlockY)
   while (pMask->pBlAktZeile->wLogicalLine > wBlockY)
       pMask->pBlAktZeile = pMask->pBlAktZeile->pLast;
 else
   while (pMask->pBlLastZeile->wPhysicalLine +
          pMask->pBlLastZeile->wMaxHoehe <
          pLine->wPhysicalLine +
          pLine->wMaxHoehe)
      {
       pMask->pBlAktZeile = pMask->pBlAktZeile->pNext;
       i_SetLastVisualLine (pMask);
      }

 i_SetLastVisualColumn (pMask);
 i_SetLastVisualLine   (pMask);

 i_ManageTBL           (pMask);

 return;
}



/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_BlockOutput                  Datum: 4.12.89       บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion                                        บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID M_BlockOutput(PMASKS pMask, PSSTR apstrRecord[])
{
PBLOCKCOLUMN pColumnStart, pColumnLauf, pColumnEnd;
PBLOCKLINE   pLineStart, pLineLauf, pLineEnd;
PBLOCKS      pBlockLauf;
PTEXTBOXLIST pTBLLauf;
SWORD wSpalteStart, wZeileStart, wFensterS, wFensterZ;

if(!pMask->pBlAktSpalte || !pMask->pBlAktZeile)
  return;				  /* nur fixer Maskenteil vorhanden */

pMask->pBlAlteSpalte = pMask->pBlAktSpalte;
pMask->pBlAlteZeile  = pMask->pBlAktZeile;
pMask->pBlOldLastSpalte = pMask->pBlLastSpalte;
pMask->pBlOldLastZeile	= pMask->pBlLastZeile;

pColumnStart = pMask->pBlAktSpalte;
pLineStart = pMask->pBlAktZeile;

wSpalteStart = pColumnStart->wPhysicalColumn;
wZeileStart  = pLineStart->wPhysicalLine;

pColumnEnd = pMask->pBlLastSpalte;
pLineEnd   = pMask->pBlLastZeile;

for(pColumnLauf=pColumnStart;
  pColumnLauf != pColumnEnd->pNext;
  pColumnLauf=pColumnLauf->pNext)
  {
  for(pBlockLauf=pColumnLauf->pBlWurzel;
    pBlockLauf->wBlockY != pLineStart->wLogicalLine;
    pBlockLauf=pBlockLauf->pNextLine)
    ;

  for(pLineLauf = pLineStart;
     pLineLauf != pLineEnd->pNext;
     pLineLauf=pLineLauf->pNext)
     {
     for(; pBlockLauf &&
       pBlockLauf->wBlockY != pLineLauf->wLogicalLine;
       pBlockLauf=pBlockLauf->pNextLine)
       ;

       for(pTBLLauf=pBlockLauf->pTBLWurzel;
	 pTBLLauf && pBlockLauf;
	 pTBLLauf=pTBLLauf->pNext)
	 {
	 SWORD wOff;

	 wOff=pTBLLauf->wOffset;
         pTBLLauf->wOffset += pBlockLauf->wBlockOffset;

         i_BFormatSchreiben(pTBLLauf, apstrRecord);

         pTBLLauf->wOffset = wOff;

         wFensterS = pTBLLauf->wFensterS;
         wFensterZ = pTBLLauf->wFensterZ;

         pTBLLauf->wFensterS += pBlockLauf->wBlockSpalte - wSpalteStart +
                                pMask->wScrollSpalte;
         pTBLLauf->wFensterZ += pBlockLauf->wBlockZeile - wZeileStart +
                                pMask->wScrollZeile;

         i_BSchreibBox(pTBLLauf);

         pTBLLauf->wFensterS = wFensterS;
         pTBLLauf->wFensterZ = wFensterZ;
        }
     }

  }

 return;
}

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                          FUNKTIONS-DEFINITION                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:   i_AdjustRecLength                    Datum: 4.12.89    บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Bemerkung:                                                              บ
  บ                                                                          บ
  บ        Die Funktion i_AdjustRecLength behandelt zur Zeit (22.12.1989)    บ
  บ        nur Blockmasken, die nur eine Spalte enthalten. Tabellenartige    บ
  บ        Masken werden erst in einer spteren Version untersttzt werden.  บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_AdjustRecLength (PMASKS pMask, PBLOCKS pBl, PBLOCKS pBlock,
			PSSTR apstrRec[], SWORD awRecLen[],
			PSSTR apstrPos[], SWORD awPosLen[], PSSTR pstrMode)
{
 SWORD wRec = pBl->wBlockRecord, wOff, wPos;
 CHAR acPos[POS_LENGTH];
 PSSTR pstrTmp;
 PBLOCKS pBl1;


 if (!strcmp(pstrMode, "INSERT_Y_KORR_POS"))
   {
    if (awPosLen[wRec] > INIT_POSITION_LENGTH - POS_LENGTH)
      {
       system ("cls");                             /* nur temporr, zu ersetzen */
       printf ("\n\n\nPositionsrecord in i_AdjustRecLength(INSERT_Y) zu klein.\n");
       E(); exit (-1);					    /* ev. weitere Errorinfo */
      }

    if(awRecLen[wRec] > (SWORD)MAX_RECORD_SIZE - pBl->wBlockLength)
      {
       system ("cls");                             /* nur temporr, zu ersetzen */
       printf("\n\n\nDatenrecord in i_AdjustRecLength(INSERT_Y) zu klein.\n");
       printf("\nawRecLen[%d](%d) > MAX_RECORD_SIZE(%d) ",
	 "- pBl->wBlockLength(%d).\n", wRec, awRecLen[wRec],
	 MAX_RECORD_SIZE, pBl->wBlockLength);
       E(); exit (-1);					    /* ev. weitere Errorinfo */
      }

    wOff = (pBl->wBlockY - 1) * POS_LENGTH;

    if (awPosLen[wRec] > wOff)
      {
       for (pstrTmp=&apstrPos[wRec][wOff];
	    (SWORD)(pstrTmp-apstrPos[wRec]) < awPosLen[wRec];
            pstrTmp += POS_LENGTH)
         {
          strcpy (acPos, pstrTmp);
	  wPos = atoi (&acPos[22]);		     /* in POS_LENGTH	     */
          wPos += pBl->wBlockLength;
	  sprintf (&acPos[22], "%5d", wPos);	     /* in POS_LENGTH	     */
          strcpy (pstrTmp, acPos);
         }

       memmove (&apstrPos[wRec][wOff+POS_LENGTH],
                &apstrPos[wRec][wOff],
                awPosLen[wRec] - wOff);

       wOff = atoi (&apstrPos[wRec][wOff+22+POS_LENGTH]) -
              pBl->wBlockLength;

       pBl->wBlockOffset = wOff;

       memmove (&apstrRec[wRec][wOff+pBl->wBlockLength],
                &apstrRec[wRec][wOff],
                awRecLen[wRec] - wOff);

       memset (&apstrRec[wRec][wOff], '\0', pBl->wBlockLength);
      }
    else if (awPosLen[wRec])
      {
       pBl1=pMask->pBlLineWurzel->pBlWurzel;
       if (!strcmp(pBl1->pstrBlockName, "(null)"))
         pBl1=pMask->pBlLineWurzel->pNext->pBlWurzel;

       for (;pBl1->pNextLine;pBl1=pBl1->pNextLine)
         ;

       pBl->wBlockOffset = pBl1->wBlockOffset +
                           pBl1->wBlockLength;
      }
    else
      pBl->wBlockOffset = (pMask->awFixBlockLength)[wRec];

    awPosLen[wRec] += POS_LENGTH;
    awRecLen[wRec] += pBl->wBlockLength;

    sprintf (acPos, "%21s %5d", pBl->pstrBlockName, pBl->wBlockOffset);

    wOff = (pBl->wBlockY - 1) * POS_LENGTH;

    strcpy (&apstrPos[wRec][wOff], acPos);
   }
 else if (!strcmp (pstrMode, "INSERT_Y_NEW_MASK"))
   {

    if (awRecLen[wRec] > (SWORD)MAX_RECORD_SIZE - pBl->wBlockLength)
      {
       system ("cls");                             /* nur temporr, zu ersetzen */
       printf ("\n\n\nDatenrecord in i_AdjustRecLength(INSERT_Y) zu klein.\n");
       E(); exit (-1);					    /* ev. weitere Errorinfo */
      }

    wOff = (pBl->wBlockY - 1) * POS_LENGTH;

    wOff = atoi (&apstrPos[wRec][wOff+22]);	     /* in POS_LENGTH	     */

    pBl->wBlockOffset = wOff;

   }
 else if (!strcmp (pstrMode, "EXCHANGE"))
   {
    SWORD wDiff, i=1;

    wDiff = pBl->wBlockLength - pBlock->wBlockLength;

    if (awRecLen[wRec] + wDiff > MAX_RECORD_SIZE)
      {
       system ("cls");                             /* nur temporr, zu ersetzen */
       printf ("\n\n\nDatenrecord in i_AdjustRecLength(EXCHANGE) zu klein.\n");
       E(); exit (-1);					    /* ev. weitere Errorinfo */
      }

    wOff = (pBlock->wBlockY - 1) * POS_LENGTH;


    for (pstrTmp=&apstrPos[wRec][wOff];
	 (SWORD)(pstrTmp-apstrPos[wRec]) < awPosLen[wRec];
         pstrTmp += POS_LENGTH)
      {
       strcpy (acPos, pstrTmp);
       wPos = atoi (&acPos[22]);		     /* in POS_LENGTH	     */
       wPos += wDiff;
       sprintf (&acPos[22], "%5d", wPos);	     /* in POS_LENGTH	     */
       strcpy (pstrTmp, acPos);
      }

    wOff = atoi (&apstrPos[wRec][wOff+22]) -	     /* in POS_LENGTH	     */
           pBl->wBlockLength + pBlock->wBlockLength;

    pBl->wBlockOffset = wOff;

    if (awPosLen[wRec] > POS_LENGTH)
      memmove (&apstrRec[wRec][wOff + wDiff],
               &apstrRec[wRec][wOff],
               awRecLen[wRec] - wOff);

    memset (&apstrRec[wRec][wOff], '\0', pBl->wBlockLength);

    awRecLen[wRec] += pBl->wBlockLength - pBlock->wBlockLength;

    sprintf (acPos, "%21s %5d", pBl->pstrBlockName, pBl->wBlockOffset);

    wOff = (pBl->wBlockY - 1) * POS_LENGTH;

    strcpy (&apstrPos[wRec][wOff], acPos);

   }
 else if (!strcmp (pstrMode, "DELETE_Y"))
   {
    wOff = pBl->wBlockY * POS_LENGTH;

    for (pstrTmp=&apstrPos[wRec][wOff];
	 (SWORD)(pstrTmp-apstrPos[wRec]) < awPosLen[wRec];
         pstrTmp += POS_LENGTH)
      {
       strcpy (acPos, pstrTmp);
       wPos = atoi (&acPos[22]);		     /* in POS_LENGTH	     */
       wPos -= pBl->wBlockLength;
       sprintf (&acPos[22], "%5d", wPos);	     /* in POS_LENGTH	     */
       strcpy (pstrTmp, acPos);
      }

    memmove (&apstrPos[wRec][wOff-POS_LENGTH],
             &apstrPos[wRec][wOff],
             awPosLen[wRec]-wOff);

    wOff = pBl->wBlockOffset + pBl->wBlockLength;
    memmove (&apstrRec[wRec][wOff - pBl->wBlockLength],
             &apstrRec[wRec][wOff],
             awRecLen[wRec] - wOff);

    memset (&apstrPos[wRec][awPosLen[wRec] - POS_LENGTH],
            '\0', POS_LENGTH);

    awRecLen[wRec] -= pBl->wBlockLength;
    awPosLen[wRec] -= POS_LENGTH;
   }

 return;
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_KopiereBlock                     Datum: 5.1.1990    บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
SWORD i_KopiereBlock (PBLOCKS pBlDest, PINITBLOCKS pBlSource,
		     PSSTR pstrMode, PSWORD awFixBlLen)
{

 pBlDest->wBlockX = 0;
 pBlDest->wBlockY = 0;
 Ut_Calloc(pBlDest->pstrBlockName,
   strlen(pBlSource->pstrBlockName)+1, CHAR);

 strcpy (pBlDest->pstrBlockName, pBlSource->pstrBlockName);

 pBlDest->wBlockSpalte = 0;
 pBlDest->wBlockZeile  = 0;
 pBlDest->wBlockHoehe  = pBlSource->wBlockHoehe;
 pBlDest->wBlockBreite = pBlSource->wBlockBreite;
 pBlDest->wBlockOffset = pBlSource->wBlockOffset;
 pBlDest->wBlockLength = pBlSource->wBlockLength;
 pBlDest->pNextLine =
 pBlDest->pLastLine = NULL;
 pBlDest->pNextColumn =
 pBlDest->pLastColumn = NULL;
 pBlDest->wBlockRecord = pBlSource->wBlockRecord;

 if (!strcmp (pstrMode, "EXCHANGE")  ||
     !strcmp (pstrMode, "FIX_BLOCK")  ||
     !strcmp (pstrMode, "INSERT_Y_KORR_POS"))
   {

    return (i_KopiereInitTBL (pBlSource, pBlDest, awFixBlLen) );
   }
 else
   {

    pBlDest->pTBLWurzel=NULL;
    pBlDest->pTBLEnd   =NULL;

    return (0);
   }

}

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_KopiereInitTBL                   Datum: 18.1.1990   บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
SWORD i_KopiereInitTBL (PINITBLOCKS pBlSource, PBLOCKS pBlDest, PSWORD awFixBlLen)
{
 PTEXTBOXLIST pTBL2, pTBLAlt=NULL;
 PTEXTBOXINIT pTBLInit;
 SWORD wMaxL;

 Ut_Calloc(pBlDest->pTBLWurzel, 1, TEXTBOXLIST);
 pTBL2=pBlDest->pTBLWurzel;

 for(pTBLInit=pBlSource->pTBLWurzel; pTBLInit;
   pTBLInit=pTBLInit->pNext, pTBL2=NULL)
   {
    /* pTBL2 wird am Ende jedesmal auf NULL gesetzt ! */

    if(pTBL2==NULL)   /* ??? */
      Ut_Calloc(pTBL2, 1, TEXTBOXLIST);

    pBlDest->pTBLEnd=pTBL2;

    pTBL2->wTBLSignatur = pTBLInit->wTBLSignatur;
    pTBL2->wFensterB = pTBLInit->wFensterB;
    pTBL2->wFensterZ = pTBLInit->wFensterZ;
    pTBL2->wFensterS = pTBLInit->wFensterS;
    pTBL2->wCursorS  = pTBLInit->wCursorS;
    pTBL2->wAttri    = pTBLInit->wAttri;
    pTBL2->wMaxL     = pTBLInit->wMaxL;
    pTBL2->boInsert  = pTBLInit->boInsert;
    pTBL2->pTBLSequenz  = NULL;
    pTBL2->wSequenz  = pTBLInit->wSequenz;
    pTBL2->wModus    = pTBLInit->wModus;
    pTBL2->wOffset   = pTBLInit->wOffset;
    pTBL2->wRecord   = pTBLInit->wRecord;
    pTBL2->wHide     = pTBLInit->wHide;
    pTBL2->pstrHelpFile=pTBLInit->acHelpFile;
    pTBL2->pstrHelpKey=pTBLInit->acHelpKey;
    pTBL2->wHelpTextLength = 0;
    memset (pTBL2->acBuffer, '\0', 8);
    pTBL2->bTyp      = pTBLInit->bTyp;
    pTBL2->pFeld     = pTBLInit->pFeld;
    pTBL2->bVKS      = pTBLInit->bVKS;
    pTBL2->bNKS      = pTBLInit->bNKS;
    pTBL2->bKomma   = pTBLInit->bKomma;
    pTBL2->pstrDatenfeld = pTBLInit->strDatenfeld;
    pTBL2->pChoice   = pTBLInit->pChoice;
    pTBL2->pstrChoiceTitel = pTBLInit->pstrChoiceTitel;
    pTBL2->pSelect   = pTBLInit->pSelect;
    pTBL2->pNext = NULL;
    pTBL2->pLast = pTBLAlt;

    /* if(pTBL2->pChoice || pTBL2->pSelect || !pTBL2->bTyp || 1)
      wMaxL=TB_MAX;
    else if (!pTBL2->bTyp)
      wMaxL=pTBL2->wMaxL + 1;
    else
      wMaxL=30; */

    wMaxL=TB_MAX;

    Ut_Calloc(pTBL2->pstrText, wMaxL, CHAR);
    if(pTBLInit->pRefField)
      {
      Ut_Calloc(pTBL2->pRefField, 1, TEXTBOXLIST);

       pTBL2->pRefField->wTBLSignatur = pTBLInit->pRefField->wTBLSignatur;
       pTBL2->pRefField->wFensterB = pTBLInit->pRefField->wFensterB;
       pTBL2->pRefField->wFensterZ = pTBLInit->pRefField->wFensterZ;
       pTBL2->pRefField->wFensterS = pTBLInit->pRefField->wFensterS;
       pTBL2->pRefField->wCursorS  = pTBLInit->pRefField->wCursorS;
       pTBL2->pRefField->wAttri    = pTBLInit->pRefField->wAttri;
       pTBL2->pRefField->wMaxL     = pTBLInit->pRefField->wMaxL;
       pTBL2->pRefField->boInsert  = pTBLInit->pRefField->boInsert;
       pTBL2->pRefField->pTBLSequenz  = NULL;
       pTBL2->pRefField->wSequenz  = pTBLInit->pRefField->wSequenz;
       pTBL2->pRefField->wModus    = pTBLInit->pRefField->wModus;
       pTBL2->pRefField->wOffset   = pTBLInit->pRefField->wOffset;
       pTBL2->pRefField->wRecord   = pTBLInit->pRefField->wRecord;
       pTBL2->pRefField->wHide     = pTBLInit->pRefField->wHide;
       pTBL2->pRefField->pstrHelpFile = pTBLInit->pRefField->acHelpFile;
       pTBL2->pRefField->pstrHelpKey =pTBLInit->pRefField->acHelpKey;
       pTBL2->pRefField->wHelpTextLength = 0;
       memset (pTBL2->pRefField->acBuffer, '\0', 8);
       pTBL2->pRefField->bTyp      = pTBLInit->pRefField->bTyp;
       pTBL2->pRefField->pFeld     = pTBLInit->pRefField->pFeld;
       pTBL2->pRefField->bVKS      = pTBLInit->pRefField->bVKS;
       pTBL2->pRefField->bNKS      = pTBLInit->pRefField->bNKS;
       pTBL2->pRefField->bKomma   = pTBLInit->pRefField->bKomma;
       pTBL2->pRefField->pstrDatenfeld = pTBLInit->pRefField->strDatenfeld;
       pTBL2->pRefField->pChoice   = pTBLInit->pRefField->pChoice;
       pTBL2->pRefField->pstrChoiceTitel = pTBLInit->pRefField->pstrChoiceTitel;
       pTBL2->pRefField->pSelect   = pTBLInit->pRefField->pSelect;
       pTBL2->pRefField->pNext = NULL;
       pTBL2->pRefField->pLast = NULL;
       pTBL2->pRefField->pRefField = pTBL2;

       /* if(pTBL2->pRefField->pChoice ||
	 pTBL2->pRefField->pSelect ||
	 !pTBL2->pRefField->bTyp || 1)
	 wMaxL = TB_MAX;
       else if(!pTBL2->pRefField->bTyp)
	 wMaxL = pTBL2->pRefField->wMaxL + 1;
       else
	 wMaxL = 30; */

      wMaxL=TB_MAX;

      Ut_Calloc(pTBL2->pRefField->pstrText, wMaxL, CHAR);
      }
    else
      pTBL2->pRefField = NULL;

    if (pTBLAlt)
      pTBLAlt->pNext = pTBL2;

    pTBLAlt = pTBL2;

    if (awFixBlLen &&
        awFixBlLen[pTBL2->wRecord] <
        pTBL2->wOffset + pTBL2->wMaxL +
        (pTBL2->bTyp ? 0 : 1))
      awFixBlLen[pTBL2->wRecord] =
                pTBL2->wOffset + pTBL2->wMaxL +
               (pTBL2->bTyp ? 0 : 1);
   }

 i_ResolveSequenz (pBlDest);

 return (OK);
}

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_ManageTBL                        Datum: 5.1.1990    บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_ManageTBL (PMASKS pMask)
{
 PTEXTBOXLIST pTBL;
 PBLOCKLINE   pLine;
 SWORD	       wLastLine;

 /* In Version 1.00 werden erst Masken mit einer Spalte untersttzt,          */
 /* deshalb werden hier nur die Zeilen der ersten Spalte behandelt.           */
 /* Fr sptere Versionen muแ diese Routine noch erweitert werden.            */

 if (pMask->pBlOldLastZeile->wLogicalLine <
     pMask->pBlAktZeile->wLogicalLine ||
     pMask->pBlAlteZeile->wLogicalLine >
     pMask->pBlLastZeile->wLogicalLine)
   wLastLine = pMask->pBlAlteZeile->wLogicalLine;
 else
   wLastLine = pMask->pBlLastZeile->wLogicalLine + 1; /* ACHTUNG: letzte sich.*/
                                                      /* Zeile darf nie frei- */
                                                      /* gegeben werden, da ja*/
                                                      /* auf Sie pField_m in  */
                                                      /* der Applikation zeigt*/


for(pLine = pMask->pBlOldLastZeile; pLine &&
  pLine->wLogicalLine >= wLastLine;
  pLine=pLine->pLast)
  {
  for(pTBL=pLine->pBlWurzel->pTBLWurzel; pTBL;
    pTBL=pTBL->pNext)
    {
    PTEXTBOXLIST pT=pTBL;
    if(pTBL->pRefField)
      {
      Ut_Free(pTBL->pRefField->pstrText);
      Ut_Free(pTBL->pRefField);
      }

    Ut_Free(pTBL->pstrText);
    Ut_Free(pT);
    }

  pLine->pBlWurzel->pTBLWurzel=NULL;
  pLine->pBlWurzel->pTBLEnd=NULL;
  }

 if (pMask->pBlOldLastZeile->wLogicalLine <
     pMask->pBlAktZeile->wLogicalLine ||
     pMask->pBlAlteZeile->wLogicalLine >
     pMask->pBlLastZeile->wLogicalLine)
   wLastLine = pMask->pBlOldLastZeile->wLogicalLine;
 else
   wLastLine = pMask->pBlAktZeile->wLogicalLine - 1;  /* ACHTUNG: erste sicht.*/
                                                      /* Zeile darf nie frei- */
                                                      /* gegeben werden, da ja*/
                                                      /* auf Sie pField_m in  */
                                                      /* der Applikation zeigt*/

for(pLine = pMask->pBlAlteZeile; pLine &&
  pLine->wLogicalLine <= wLastLine;
  pLine = pLine->pNext)
  {
  for(pTBL=pLine->pBlWurzel->pTBLWurzel; pTBL;
    pTBL=pTBL->pNext)
    {
    PTEXTBOXLIST pT=pTBL;
    if(pTBL->pRefField)
      {
      Ut_Free(pTBL->pRefField->pstrText);
      Ut_Free(pTBL->pRefField);
      }

    Ut_Free(pTBL->pstrText);
    Ut_Free(pT);
    }

  pLine->pBlWurzel->pTBLWurzel=
  pLine->pBlWurzel->pTBLEnd=NULL;
  }

for(pLine = pMask->pBlAktZeile; pLine &&
  pLine != pMask->pBlLastZeile->pNext;
  pLine=pLine->pNext)
  if(!pLine->pBlWurzel->pTBLWurzel)
    i_InsertTBL(pLine->pBlWurzel, pMask);

return;
}

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_InsertTBL                         Datum: 5.1.1990   บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID i_InsertTBL (PBLOCKS pBlock, PMASKS pMask)
{
 PINITBLOCKS pBlSource;

 for (pBlSource = pMask->pBlInitWurzel;
      pBlSource &&
      strcmp (pBlSource->pstrBlockName,
              pBlock->pstrBlockName);
      pBlSource = pBlSource->pNext)
    ;

 if (!pBlSource)
   {
    system ("cls");                         /* nur temporr, zu ersetzen */
    printf ("\n\n\nUnbekannter Blockname %s in InsertBlock\n",
            pBlock->pstrBlockName);
    E(); exit (-1);				     /* ev. weitere Errorinfo */
   }

 i_KopiereInitTBL (pBlSource, pBlock, NULL);

 return;
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_ResolveSequenz               Datum: 27.11.1989      บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_ResolveSequenz(PBLOCKS pBlock)
{
 PTEXTBOXLIST pTBL1, pTBL2;

 for (pTBL1=pBlock->pTBLWurzel; pTBL1; pTBL1 = pTBL1->pNext)
   {
    for (pTBL2 = pBlock->pTBLWurzel;
	 pTBL2 && pTBL2->wModus != pTBL1->wSequenz;
         pTBL2 = pTBL2->pNext)
       ;

    if (pTBL2)
      pTBL1->pTBLSequenz = pTBL2;
    else
      pTBL1->pTBLSequenz = pTBL1->pNext;
   }

 return;
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_BSchreibBox                   Datum: 24.12.88     บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:        SWORD   wSpalte	 Absolute Startspalte		    บ
  บ		       PSWORD  pwFirst	 Zeiger auf erstes auszugebendes    บ
  บ                                     Zeichen                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion aktualisiert den Inhalt der Textbox    บ
  บ                    auf dem Bildschirm. Sie gibt dazu ab der durch      บ
  บ                    ฏwSpalteฎ bestimmten Position Zeichen des Textbox-  บ
  บ                    buffers ฏ->acTextฎ in dem Textfenster aus.          บ
  บ                    Die Funktion beendet die Ausgabe wenn sie den       บ
  บ                    rechten Rand der Textbox erreicht hat.              บ
  บ                    Die aufrufende Funktion muแ sicherstellen, daแ      บ
  บ                    der Buffer nicht ber sein Ende hinaus ausgegeben   บ
  บ                    wird.                                               บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_BSchreibBox(PTEXTBOXLIST pTB)
{
    SWORD  wStatus;
    CHAR  acText[TB_MAX];

    wStatus = Ms_CursorOff();

    if (pTB->wHide)
      *acText = '\0';
    else
      strcpy (acText, pTB->pstrText);

    if (strlen(acText) > (SIZE_T)pTB->wFensterB)
      acText[pTB->wFensterB] = '\0';
    else strpad(acText, pTB->wFensterB);

    Vi_Ssa(pTB->wFensterS,
         pTB->wFensterZ,
         acText,
         pTB->wAttri);

    if (wStatus == MSM_WAR_AN && wMausda_g)
        Ms_CursorOn();
}



/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_SetLastVisualColumn          Datum: 18.12.1989      บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_SetLastVisualColumn (PMASKS pMask)
{
 PBLOCKCOLUMN pColumn = pMask->pBlColumnEnd;

 return;   /* Zur Zeit (noch) ohne Auswirkungen, da nur horizontal scrollbar  */

 /* while(pColumn->pLast &&
	pColumn->wPhysicalColumn+
        pColumn->wMaxBreite >
        pMask->pBlAktSpalte->wPhysicalColumn +
        pMask->wScrollBreite - 1)
    pColumn = pColumn->pLast;

 pMask->pBlLastSpalte = pColumn;

 return; */
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_SetLastVisualLine            Datum: 18.12.1989      บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                          บ
  บ  Beschreibung:     Diese Funktion                                        บ
  บ                                                                          บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_SetLastVisualLine (PMASKS pMask)
{
 PBLOCKLINE pLine = pMask->pBlLineEnd;

 while (pLine->pLast &&
        pLine->wPhysicalLine +
        pLine->wMaxHoehe >
        pMask->pBlAktZeile->wPhysicalLine +
        pMask->wScrollHoehe)
    pLine = pLine->pLast;

 pMask->pBlLastZeile = pLine;

 return;
}
