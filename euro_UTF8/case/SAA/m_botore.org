// (C) WINware Software P.Mayer: letztes Update am 12-Feb-1996

/*.ta M_BoxToRecord()
ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
บ  M_BoxToRecord()							       บ
ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ

berblick:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
#include <eur_tool.h>
BOOL M_BoxToRecord(PSSTR apstrRecord[], PTEXTBOX pT)

Parameter:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
PWKB   apWkbMask[]        Zeiger auf Array fr die Maskenattribute.

Beschreibung:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
Diese Funktion bildet aus der Sicht des Applikations-Programmierers die


Rckgabewert:
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
SWORD  Fehlerinformation OK/ERROR


Benutzte globale Variablen (R/W):
ฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤ
Variablen (R/W):  - aCS_g[]    (R)	     - pstrEsc_g   (R)

.ff
REM .de \euro\demo\dmohilf1.c
.te*/

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                        DEKLARATIONS-DATEIEN                            บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <ctype.h>              /* isdigit(),                                */
#include <eur_tool.h>

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ                      FUNKTIONS-PROTOTYPEN                              บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC VOID  i_BoxToRecord	 (PSSTR[], PTEXTBOX);

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ         GLOBALE DATEN, DIE AUS DER TOOLBOX IMPORTIERT WERDEN           บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
/* IMPORT PWKB pWkbInfo_g; */
/* IMPORT BOOL boTestModus_g; */
/* IMPORT SWORD   wMausda_g; */

STATIC VOID i_DateOK   (PTEXTBOX);

/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    M_BoxToRecord		      Datum: 6.9.89	   บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion prft die Gltigkeit der Eingabe       บ
  บ		       durch Vergleich mit der Maskendefinition 	   บ
  บ                    (nur numerische Eingaben erlaubt etc.)              บ
  บ		       und kopiert die Textbox auf das Record.		   บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
BOOL M_BoxToRecord(PSSTR apstrRecord[], PTEXTBOX pT)
{
CHOICES *pchoices;
SWORD wIndex;
PCHAR pc;
FELDINFO *ptemp;
D_DATE *pD=NULL;
D_TIME *pZ=NULL;

pc = pT->acText;
if(pT->bTyp==7 && (*pc=='s'||*pc=='S'||*pc=='d'||*pc=='D') )
   {
   pD = D_get_date (pD);
   if(pT->wFensterB==8)
     {pD->wJahr=pD->wJahr % 100;
     sprintf(pc, "%#02d.%#02d.%#02d", pD->cTag, pD->cMonat, pD->wJahr);}
   else
     sprintf(pc, "%#02d.%#02d.%#04d", pD->cTag, pD->cMonat, pD->wJahr);

   Ut_Free(pD);
   }
else if (pT->bTyp==8 && (*pc=='s'||*pc=='S'||*pc=='z'||*pc=='Z'))
   {
   pZ = D_get_time (pZ);
   sprintf (pc, "%#02d.%#02d", pZ->cStd, pZ->cMin);
   Ut_Free (pZ);
   }

if (!pT->pChoice && !pT->pSelect)
  {
   i_FormatLoeschen (pT);

   if(pT->bTyp==5 || pT->bTyp==25)
     {
     PCHAR pc=strchr(pT->acText, KOMMA);
     DOUBLE dHelp=0.0;

     if(pc) *pc = '.';
     dHelp=atof(pT->acText);
     if(pc) *pc = KOMMA;

     memcpy(pT->acBuffer, &dHelp, 8);
     }
   else if(pT->bTyp==13 || pT->bTyp==23)
     {
     PCHAR pc=strchr(pT->acText, KOMMA);
     FLOAT fHelp;

     if(pc) *pc = '.';
     fHelp=(FLOAT)atof(pT->acText);
     if(pc) *pc = KOMMA;

     memcpy(pT->acBuffer, &fHelp, 4);
     }
   else if (pT->bTyp==1 || pT->bTyp==2)
     {
     SWORD wHelp;

     wHelp = atoi (pT->acText);
     memcpy (pT->acBuffer, &wHelp, 2);
     }
   else if (pT->bTyp==3 || pT->bTyp==4 || pT->bTyp==11)
     {
     SLONG lHelp;

     lHelp = atol (pT->acText);
     memcpy (pT->acBuffer, &lHelp, 4);
     }

   if(i_Formatiere(pT))
     return(JA);

   ptemp = pT->pFeld;
   pc = pT->acText;

   while (ptemp)
     {
      SWORD i;
      wIndex = 0;
      for (i=0; *pc && i < (SWORD)ptemp->bLaenge; i++, pc++)
         if (i + 1 == (ptemp->abFormat[wIndex] & 63))
            wIndex++;
         else if ((ptemp->bArt & IS_ASCII) && (ptemp->bArt & IS_LEXIKOGRAPH))
           {
            if (!(isprint(*pc) || *pc == '' || *pc == '' || *pc == '' ||
                *pc == '' || *pc == '' || *pc == '' || *pc ==  'แ'))
              {
               i_Beep();
               return (JA);
              }
           }
         else if (!(ptemp->bArt & IS_ASCII))
           {
            if (!(isdigit(*pc) || *pc == ' ' || *pc == SIGN) &&
		  pc - pT->acText != pT->bKomma - 1)
              {
               i_Beep();
               return (JA);
              }
           }
                /* Ende for - Schleife !!! */
      ptemp = ptemp->pNext;
     }
   }   /* Ende if kein Choicefeld und kein Selectfeld*/
else if(pT->pChoice)
  for(pchoices=pT->pChoice; pchoices;
    pchoices=pchoices->pNext)
    if(!strcmp(pchoices->pstrFormat, pT->acText))
      strcpy(pT->acText, pchoices->pstrWert);


/* i_DateOK(pT); */
i_BoxToRecord(apstrRecord, pT);
return (NEIN);
} /* end M_BoxToRecord() */


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  i_DateOK() 							   บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
STATIC
VOID i_DateOK(PTEXTBOX pTB)
{
SWORD wY;
SBYTE bD, bM;
CHAR acText[TB_MAX];

strcpy(acText, pTB->acText);
acText[2]='\0'; acText[5]='\0';

bD=(SBYTE)atoi(pTB->acText);
bM=(SBYTE)atoi(&pTB->acText[3]);
wY=atoi(&pTB->acText[6]);

if(bM<1)  bM=(SBYTE) 1;
if(bM>12) bM=(SBYTE)12;
if(bD<1)  bD=(SBYTE) 1;

if(bD>(SBYTE)31 && (bM==(SBYTE)1||bM==(SBYTE)3||
  bM==(SBYTE)5||bM==(SBYTE)7||
  bM==(SBYTE)8||bM==(SBYTE)10||bM==(SBYTE)12))
  bD=(SBYTE)31;

if(bD>(SBYTE)30 && (bM==(SBYTE)4||bM==(SBYTE)6||
  bM==(SBYTE)9||bM==(SBYTE)11))
  bD=(SBYTE)30;

if(bD>(SBYTE)29 && bM==(SBYTE)2 && wY%4==0)
  bD=(SBYTE)29;

if(bD>(SBYTE)28 && bM==(SBYTE)2 && wY%4!=0)
  bD=(SBYTE)28;

if(pTB->wFensterB==8)
  sprintf(pTB->acText, "%#02d.%#02d.%#02d", bD, bM, wY);
else
  sprintf(pTB->acText, "%#02d.%#02d.%#04d", bD, bM, wY);

return;
}


/*ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
  บ  Funktionsname:    i_BoxToRecord		      Datum: 4.9.89	   บ
  วฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤฤถ
  บ                                                                        บ
  บ  Parameter:                                                            บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Beschreibung:     Die Funktion liest den Feldinhalt aus der Textbox   บ
  บ                    und kopiert ihn in das Record.                      บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Rckgabewert:     Die Funktion hat keinen Rckgabewert.               บ
  บ                                                                        บ
  บ                                                                        บ
  บ  Benutzte globale                                                      บ
  บ  Variablen (R/W):                                                      บ
  บ                                                                        บ
  ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ*/
GLOBAL
VOID i_BoxToRecord(PSSTR apstrRecord[], PTEXTBOX pTB)
{
 CHOICES *ptempchoice;
 SWORD wRec = pTB->wRecord;
 SWORD wOff = pTB->wOffset;
 SBYTE bHelp;
 SWORD wHelp;
 UWORD uwHelp;
 SLONG lHelp;
 ULONG ulHelp;
 DOUBLE dHelp=0.0, dMsHelp=0.0;
 FLOAT fHelp, fMsHelp;
 PTEXTBOX pT=NULL;

Ut_Calloc(pT, 1, TEXTBOX);

Dl_KopierBox(pT, pTB);
M_RecordToBox(pT, apstrRecord);
if(!strcmp(pTB->acText, pT->acText))
 {Ut_Free(pT); return;}

 pT->bTyp = pTB->bTyp;
 memcpy (pT->acBuffer, pTB->acBuffer, 8);
 memset (pT->acText, '\0', TB_MAX);
 strcpy (pT->acText, pTB->acText);
 pT->bNKS = pTB->bNKS;
 pT->pFeld = pTB->pFeld;

 if(pT->bTyp && !pTB->pSelect && !pTB->pChoice)
   i_FormatLoeschen(pT);

 switch (pT->bTyp)
     {
     PCHAR pc; CHAR ac[10];

      case 0:
	 for(ptempchoice=pTB->pChoice; ptempchoice;
	   ptempchoice=ptempchoice->pNext)
	   if(!strcmp(ptempchoice->pstrWert, pT->acText))
	     strcpy(pT->acText, ptempchoice->pstrFormat);

	 strcpy(&apstrRecord[wRec][wOff], pT->acText);
         break;

      case 1:
         i_KommaLoeschen(pT);
	 wHelp = atoi (pT->acText);
	 memcpy (pT->acBuffer, &wHelp, 2);
	 memcpy (&apstrRecord[wRec][wOff], &wHelp, 2);
         break;

      case 2:
         i_KommaLoeschen(pT);
	 uwHelp = atoi (pT->acText);
	 memcpy (pT->acBuffer, &uwHelp, 2);
	 memcpy (&apstrRecord[wRec][wOff], &uwHelp, 2);
         break;

      case 3:
         i_KommaLoeschen(pT);
	 lHelp = atol (pT->acText);
	 memcpy (pT->acBuffer, &lHelp, 4);
	 memcpy (&apstrRecord[wRec][wOff], &lHelp, 4);
         break;

      case 4:
         if (!pT->pSelect)
           {
            i_KommaLoeschen(pT);
	    ulHelp = atol (pT->acText);
	    memcpy (pT->acBuffer, &ulHelp, 4);
           }
         memcpy (&apstrRecord[wRec][wOff], pT->acBuffer, 4);
         break;

      case 5:
      case 25:
	 pc=strchr(pT->acText, KOMMA);
         if(pc) *pc ='.';
         dHelp=atof(pT->acText);
         memcpy(pT->acBuffer, &dHelp, 8);

         if(pT->bTyp==25)
           {dieeetomsbin(&dHelp, &dMsHelp);
           memcpy(&apstrRecord[wRec][wOff], &dMsHelp, 8);}
         else
           memcpy(&apstrRecord[wRec][wOff], &dHelp, 8);
         break;

      case 13:
      case 23:
	 pc=strchr(pT->acText, KOMMA);
         if(pc) *pc ='.';
	 fHelp=(FLOAT)atof(pT->acText);
	 memcpy(pT->acBuffer, &fHelp, 4);

	 if(pT->bTyp==23)
	   {fieeetomsbin(&fHelp, &fMsHelp);
	   memcpy(&apstrRecord[wRec][wOff], &fMsHelp, 4);}
         else
	   memcpy(&apstrRecord[wRec][wOff], &fHelp, 4);
         break;

      case 6:
         memcpy (pT->acBuffer, pT->acText, 2);
         memcpy (&apstrRecord[wRec][wOff], pT->acBuffer, 2);
         break;

      case 7:
         if(strlen(pT->acText)%2)               /* Wenn ungerade Stellenzahl */
           ins(' ', pT->acText);                /* ( == Tag einstellig )     */
                                                /* vor Tag 1 Stelle einfgen */
         ins(' ', &pT->acText[2]);
         pT->acText[2] = '\0';
         ins(' ', &pT->acText[5]);
         pT->acText[5] = '\0';
	 pT->acText[10] = '\0';

	 i_DateOK(pT);

	 bHelp = (SBYTE) atoi(pT->acText);
         memcpy (pT->acBuffer, &bHelp, 1);

	 bHelp = (SBYTE) atoi(&pT->acText[3]);
         memcpy (&pT->acBuffer[1], &bHelp, 1);

         wHelp = atoi(&pT->acText[6]);
         memcpy (&pT->acBuffer[2], &wHelp, 2);

         memcpy (&lHelp, pT->acBuffer, 4);
	 if(lHelp > 5963776L)
	   memcpy(ac, pT->acBuffer, 8);

	 memcpy(&apstrRecord[wRec][wOff], pT->acBuffer, 4);

	 if(lHelp > 5963776L)
	   memcpy(&lHelp, ac, 4);
         break;

      case 8:
         while (strlen(pT->acText) < 4)
            ins(' ', pT->acText);
         ins('.',  &pT->acText[2]);
         pT->acText[2] = '\0';
         pT->acText[5] = '\0';

         bHelp = 0;
         memcpy (pT->acBuffer, &bHelp, 1);

         bHelp = 0;
         memcpy (&pT->acBuffer[1], &bHelp, 1);

	 bHelp = (SBYTE) atoi(&pT->acText[3]);
         memcpy (&pT->acBuffer[2], &bHelp, 1);

	 bHelp = (SBYTE) atoi(pT->acText);
         memcpy (&pT->acBuffer[3], &bHelp, 1);

         memcpy (&apstrRecord[wRec][wOff], pT->acBuffer, 4);
         break;

      case 9:
         break;

      case 10:
         break;

      case 11:
         lHelp = atol (pT->acText);
         memcpy (pT->acBuffer, &lHelp, 4);
         memcpy (&apstrRecord[wRec][wOff], &lHelp, 4);
         break;
     }

Ut_Free(pT);
return;
} /* end i_BoxToRecord() */
